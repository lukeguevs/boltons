# Copyright (c) 2013, Mahmoud Hashemi
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#    * Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials provided
#      with the distribution.
#
#    * The names of the contributors may not be used to endorse or
#      promote products derived from this software without specific
#      prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
A small set of utilities useful for debugging misbehaving
applications. Currently this focuses on ways to use :mod:`pdb`, the
built-in Python debugger.
"""

import sys
import time
from reprlib import Repr

_UNSET = object()

__all__ = ['pdb_on_signal', 'pdb_on_exception', 'wrap_trace']
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result


def x_pdb_on_signal__mutmut_orig(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_1(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_2(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = None

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_3(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = None

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_4(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(None)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_5(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(None, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_6(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, None)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_7(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_8(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, )
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_9(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(None)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_10(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(None, pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_11(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, None)
    return


def x_pdb_on_signal__mutmut_12(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(pdb_int_handler)
    return


def x_pdb_on_signal__mutmut_13(signalnum=None):
    """Installs a signal handler for *signalnum*, which defaults to
    ``SIGINT``, or keyboard interrupt/ctrl-c. This signal handler
    launches a :mod:`pdb` breakpoint. Results vary in concurrent
    systems, but this technique can be useful for debugging infinite
    loops, or easily getting into deep call stacks.

    Args:
        signalnum (int): The signal number of the signal to handle
            with pdb. Defaults to :mod:`signal.SIGINT`, see
            :mod:`signal` for more information.
    """
    import pdb
    import signal
    if not signalnum:
        signalnum = signal.SIGINT

    old_handler = signal.getsignal(signalnum)

    def pdb_int_handler(sig, frame):
        signal.signal(signalnum, old_handler)
        pdb.set_trace()
        pdb_on_signal(signalnum)  # use 'u' to find your code and 'h' for help

    signal.signal(signalnum, )
    return

x_pdb_on_signal__mutmut_mutants : ClassVar[MutantDict] = {
'x_pdb_on_signal__mutmut_1': x_pdb_on_signal__mutmut_1, 
    'x_pdb_on_signal__mutmut_2': x_pdb_on_signal__mutmut_2, 
    'x_pdb_on_signal__mutmut_3': x_pdb_on_signal__mutmut_3, 
    'x_pdb_on_signal__mutmut_4': x_pdb_on_signal__mutmut_4, 
    'x_pdb_on_signal__mutmut_5': x_pdb_on_signal__mutmut_5, 
    'x_pdb_on_signal__mutmut_6': x_pdb_on_signal__mutmut_6, 
    'x_pdb_on_signal__mutmut_7': x_pdb_on_signal__mutmut_7, 
    'x_pdb_on_signal__mutmut_8': x_pdb_on_signal__mutmut_8, 
    'x_pdb_on_signal__mutmut_9': x_pdb_on_signal__mutmut_9, 
    'x_pdb_on_signal__mutmut_10': x_pdb_on_signal__mutmut_10, 
    'x_pdb_on_signal__mutmut_11': x_pdb_on_signal__mutmut_11, 
    'x_pdb_on_signal__mutmut_12': x_pdb_on_signal__mutmut_12, 
    'x_pdb_on_signal__mutmut_13': x_pdb_on_signal__mutmut_13
}

def pdb_on_signal(*args, **kwargs):
    result = _mutmut_trampoline(x_pdb_on_signal__mutmut_orig, x_pdb_on_signal__mutmut_mutants, args, kwargs)
    return result 

pdb_on_signal.__signature__ = _mutmut_signature(x_pdb_on_signal__mutmut_orig)
x_pdb_on_signal__mutmut_orig.__name__ = 'x_pdb_on_signal'


def x_pdb_on_exception__mutmut_orig(limit=100):
    """Installs a handler which, instead of exiting, attaches a
    post-mortem pdb console whenever an unhandled exception is
    encountered.

    Args:
        limit (int): the max number of stack frames to display when
            printing the traceback

    A similar effect can be achieved from the command-line using the
    following command::

      python -m pdb your_code.py

    But ``pdb_on_exception`` allows you to do this conditionally and within
    your application. To restore default behavior, just do::

      sys.excepthook = sys.__excepthook__
    """
    import pdb
    import sys
    import traceback

    def pdb_excepthook(exc_type, exc_val, exc_tb):
        traceback.print_tb(exc_tb, limit=limit)
        pdb.post_mortem(exc_tb)

    sys.excepthook = pdb_excepthook
    return


def x_pdb_on_exception__mutmut_1(limit=101):
    """Installs a handler which, instead of exiting, attaches a
    post-mortem pdb console whenever an unhandled exception is
    encountered.

    Args:
        limit (int): the max number of stack frames to display when
            printing the traceback

    A similar effect can be achieved from the command-line using the
    following command::

      python -m pdb your_code.py

    But ``pdb_on_exception`` allows you to do this conditionally and within
    your application. To restore default behavior, just do::

      sys.excepthook = sys.__excepthook__
    """
    import pdb
    import sys
    import traceback

    def pdb_excepthook(exc_type, exc_val, exc_tb):
        traceback.print_tb(exc_tb, limit=limit)
        pdb.post_mortem(exc_tb)

    sys.excepthook = pdb_excepthook
    return


def x_pdb_on_exception__mutmut_2(limit=100):
    """Installs a handler which, instead of exiting, attaches a
    post-mortem pdb console whenever an unhandled exception is
    encountered.

    Args:
        limit (int): the max number of stack frames to display when
            printing the traceback

    A similar effect can be achieved from the command-line using the
    following command::

      python -m pdb your_code.py

    But ``pdb_on_exception`` allows you to do this conditionally and within
    your application. To restore default behavior, just do::

      sys.excepthook = sys.__excepthook__
    """
    import pdb
    import sys
    import traceback

    def pdb_excepthook(exc_type, exc_val, exc_tb):
        traceback.print_tb(None, limit=limit)
        pdb.post_mortem(exc_tb)

    sys.excepthook = pdb_excepthook
    return


def x_pdb_on_exception__mutmut_3(limit=100):
    """Installs a handler which, instead of exiting, attaches a
    post-mortem pdb console whenever an unhandled exception is
    encountered.

    Args:
        limit (int): the max number of stack frames to display when
            printing the traceback

    A similar effect can be achieved from the command-line using the
    following command::

      python -m pdb your_code.py

    But ``pdb_on_exception`` allows you to do this conditionally and within
    your application. To restore default behavior, just do::

      sys.excepthook = sys.__excepthook__
    """
    import pdb
    import sys
    import traceback

    def pdb_excepthook(exc_type, exc_val, exc_tb):
        traceback.print_tb(exc_tb, limit=None)
        pdb.post_mortem(exc_tb)

    sys.excepthook = pdb_excepthook
    return


def x_pdb_on_exception__mutmut_4(limit=100):
    """Installs a handler which, instead of exiting, attaches a
    post-mortem pdb console whenever an unhandled exception is
    encountered.

    Args:
        limit (int): the max number of stack frames to display when
            printing the traceback

    A similar effect can be achieved from the command-line using the
    following command::

      python -m pdb your_code.py

    But ``pdb_on_exception`` allows you to do this conditionally and within
    your application. To restore default behavior, just do::

      sys.excepthook = sys.__excepthook__
    """
    import pdb
    import sys
    import traceback

    def pdb_excepthook(exc_type, exc_val, exc_tb):
        traceback.print_tb(limit=limit)
        pdb.post_mortem(exc_tb)

    sys.excepthook = pdb_excepthook
    return


def x_pdb_on_exception__mutmut_5(limit=100):
    """Installs a handler which, instead of exiting, attaches a
    post-mortem pdb console whenever an unhandled exception is
    encountered.

    Args:
        limit (int): the max number of stack frames to display when
            printing the traceback

    A similar effect can be achieved from the command-line using the
    following command::

      python -m pdb your_code.py

    But ``pdb_on_exception`` allows you to do this conditionally and within
    your application. To restore default behavior, just do::

      sys.excepthook = sys.__excepthook__
    """
    import pdb
    import sys
    import traceback

    def pdb_excepthook(exc_type, exc_val, exc_tb):
        traceback.print_tb(exc_tb, )
        pdb.post_mortem(exc_tb)

    sys.excepthook = pdb_excepthook
    return


def x_pdb_on_exception__mutmut_6(limit=100):
    """Installs a handler which, instead of exiting, attaches a
    post-mortem pdb console whenever an unhandled exception is
    encountered.

    Args:
        limit (int): the max number of stack frames to display when
            printing the traceback

    A similar effect can be achieved from the command-line using the
    following command::

      python -m pdb your_code.py

    But ``pdb_on_exception`` allows you to do this conditionally and within
    your application. To restore default behavior, just do::

      sys.excepthook = sys.__excepthook__
    """
    import pdb
    import sys
    import traceback

    def pdb_excepthook(exc_type, exc_val, exc_tb):
        traceback.print_tb(exc_tb, limit=limit)
        pdb.post_mortem(None)

    sys.excepthook = pdb_excepthook
    return


def x_pdb_on_exception__mutmut_7(limit=100):
    """Installs a handler which, instead of exiting, attaches a
    post-mortem pdb console whenever an unhandled exception is
    encountered.

    Args:
        limit (int): the max number of stack frames to display when
            printing the traceback

    A similar effect can be achieved from the command-line using the
    following command::

      python -m pdb your_code.py

    But ``pdb_on_exception`` allows you to do this conditionally and within
    your application. To restore default behavior, just do::

      sys.excepthook = sys.__excepthook__
    """
    import pdb
    import sys
    import traceback

    def pdb_excepthook(exc_type, exc_val, exc_tb):
        traceback.print_tb(exc_tb, limit=limit)
        pdb.post_mortem(exc_tb)

    sys.excepthook = None
    return

x_pdb_on_exception__mutmut_mutants : ClassVar[MutantDict] = {
'x_pdb_on_exception__mutmut_1': x_pdb_on_exception__mutmut_1, 
    'x_pdb_on_exception__mutmut_2': x_pdb_on_exception__mutmut_2, 
    'x_pdb_on_exception__mutmut_3': x_pdb_on_exception__mutmut_3, 
    'x_pdb_on_exception__mutmut_4': x_pdb_on_exception__mutmut_4, 
    'x_pdb_on_exception__mutmut_5': x_pdb_on_exception__mutmut_5, 
    'x_pdb_on_exception__mutmut_6': x_pdb_on_exception__mutmut_6, 
    'x_pdb_on_exception__mutmut_7': x_pdb_on_exception__mutmut_7
}

def pdb_on_exception(*args, **kwargs):
    result = _mutmut_trampoline(x_pdb_on_exception__mutmut_orig, x_pdb_on_exception__mutmut_mutants, args, kwargs)
    return result 

pdb_on_exception.__signature__ = _mutmut_signature(x_pdb_on_exception__mutmut_orig)
x_pdb_on_exception__mutmut_orig.__name__ = 'x_pdb_on_exception'

_repr_obj = Repr()
_repr_obj.maxstring = 50
_repr_obj.maxother = 50
brief_repr = _repr_obj.repr


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_orig(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_1(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = None
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_2(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(None), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_3(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.rjust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_4(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(7), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_5(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(None),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_6(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.ljust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_7(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(11),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_8(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event != 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_9(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'XXgetXX':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_10(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'GET':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_11(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = None
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_12(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = 'XX%s %s - %s - %s.%s -> %sXX'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_13(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%S %S - %S - %S.%S -> %S'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_14(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs = (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_15(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs -= (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_16(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(None),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_17(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event != 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_18(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'XXsetXX':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_19(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'SET':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_20(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = None
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_21(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = 'XX%s %s - %s - %s.%s = %sXX'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_22(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%S %S - %S - %S.%S = %S'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_23(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs = (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_24(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs -= (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_25(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(None),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_26(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[1]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_27(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event != 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_28(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'XXdelXX':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_29(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'DEL':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_30(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = None
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_31(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = 'XX%s %s - %s - %s.%sXX'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_32(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%S %S - %S - %S.%S'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_33(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = None
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_34(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = 'XX%s %s - %s - %s.%s(%s)XX'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_35(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%S %S - %S - %S.%S(%S)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_36(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs = (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_37(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs -= (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_38(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join(None),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_39(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += ('XX, XX'.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_40(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(None) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_41(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = None
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_42(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = 'XX%s %s - %s - %s.%s(%s, %s)XX'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_43(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%S %S - %S - %S.%S(%S, %S)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_44(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs = (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_45(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs -= (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_46(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join(None),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_47(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += ('XX, XX'.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_48(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(None)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_49(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_50(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl = ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_51(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl -= ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_52(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += 'XX -> %sXX'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_53(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %S'
            fargs += (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_54(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs = (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_55(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs -= (brief_repr(result),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_56(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(None),)
    print(tmpl % fargs)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_57(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(None)
    return


# events: call, return, get, set, del, raise
def x_trace_print_hook__mutmut_58(event, label, obj, attr_name,
                     args=(), kwargs={}, result=_UNSET):
    fargs = (event.ljust(6), time.time(), label.rjust(10),
             obj.__class__.__name__, attr_name)
    if event == 'get':
        tmpl = '%s %s - %s - %s.%s -> %s'
        fargs += (brief_repr(result),)
    elif event == 'set':
        tmpl = '%s %s - %s - %s.%s = %s'
        fargs += (brief_repr(args[0]),)
    elif event == 'del':
        tmpl = '%s %s - %s - %s.%s'
    else:  # call/return/raise
        tmpl = '%s %s - %s - %s.%s(%s)'
        fargs += (', '.join([brief_repr(a) for a in args]),)
        if kwargs:
            tmpl = '%s %s - %s - %s.%s(%s, %s)'
            fargs += (', '.join([f'{k}={brief_repr(v)}'
                                 for k, v in kwargs.items()]),)
        if result is not _UNSET:
            tmpl += ' -> %s'
            fargs += (brief_repr(result),)
    print(tmpl / fargs)
    return

x_trace_print_hook__mutmut_mutants : ClassVar[MutantDict] = {
'x_trace_print_hook__mutmut_1': x_trace_print_hook__mutmut_1, 
    'x_trace_print_hook__mutmut_2': x_trace_print_hook__mutmut_2, 
    'x_trace_print_hook__mutmut_3': x_trace_print_hook__mutmut_3, 
    'x_trace_print_hook__mutmut_4': x_trace_print_hook__mutmut_4, 
    'x_trace_print_hook__mutmut_5': x_trace_print_hook__mutmut_5, 
    'x_trace_print_hook__mutmut_6': x_trace_print_hook__mutmut_6, 
    'x_trace_print_hook__mutmut_7': x_trace_print_hook__mutmut_7, 
    'x_trace_print_hook__mutmut_8': x_trace_print_hook__mutmut_8, 
    'x_trace_print_hook__mutmut_9': x_trace_print_hook__mutmut_9, 
    'x_trace_print_hook__mutmut_10': x_trace_print_hook__mutmut_10, 
    'x_trace_print_hook__mutmut_11': x_trace_print_hook__mutmut_11, 
    'x_trace_print_hook__mutmut_12': x_trace_print_hook__mutmut_12, 
    'x_trace_print_hook__mutmut_13': x_trace_print_hook__mutmut_13, 
    'x_trace_print_hook__mutmut_14': x_trace_print_hook__mutmut_14, 
    'x_trace_print_hook__mutmut_15': x_trace_print_hook__mutmut_15, 
    'x_trace_print_hook__mutmut_16': x_trace_print_hook__mutmut_16, 
    'x_trace_print_hook__mutmut_17': x_trace_print_hook__mutmut_17, 
    'x_trace_print_hook__mutmut_18': x_trace_print_hook__mutmut_18, 
    'x_trace_print_hook__mutmut_19': x_trace_print_hook__mutmut_19, 
    'x_trace_print_hook__mutmut_20': x_trace_print_hook__mutmut_20, 
    'x_trace_print_hook__mutmut_21': x_trace_print_hook__mutmut_21, 
    'x_trace_print_hook__mutmut_22': x_trace_print_hook__mutmut_22, 
    'x_trace_print_hook__mutmut_23': x_trace_print_hook__mutmut_23, 
    'x_trace_print_hook__mutmut_24': x_trace_print_hook__mutmut_24, 
    'x_trace_print_hook__mutmut_25': x_trace_print_hook__mutmut_25, 
    'x_trace_print_hook__mutmut_26': x_trace_print_hook__mutmut_26, 
    'x_trace_print_hook__mutmut_27': x_trace_print_hook__mutmut_27, 
    'x_trace_print_hook__mutmut_28': x_trace_print_hook__mutmut_28, 
    'x_trace_print_hook__mutmut_29': x_trace_print_hook__mutmut_29, 
    'x_trace_print_hook__mutmut_30': x_trace_print_hook__mutmut_30, 
    'x_trace_print_hook__mutmut_31': x_trace_print_hook__mutmut_31, 
    'x_trace_print_hook__mutmut_32': x_trace_print_hook__mutmut_32, 
    'x_trace_print_hook__mutmut_33': x_trace_print_hook__mutmut_33, 
    'x_trace_print_hook__mutmut_34': x_trace_print_hook__mutmut_34, 
    'x_trace_print_hook__mutmut_35': x_trace_print_hook__mutmut_35, 
    'x_trace_print_hook__mutmut_36': x_trace_print_hook__mutmut_36, 
    'x_trace_print_hook__mutmut_37': x_trace_print_hook__mutmut_37, 
    'x_trace_print_hook__mutmut_38': x_trace_print_hook__mutmut_38, 
    'x_trace_print_hook__mutmut_39': x_trace_print_hook__mutmut_39, 
    'x_trace_print_hook__mutmut_40': x_trace_print_hook__mutmut_40, 
    'x_trace_print_hook__mutmut_41': x_trace_print_hook__mutmut_41, 
    'x_trace_print_hook__mutmut_42': x_trace_print_hook__mutmut_42, 
    'x_trace_print_hook__mutmut_43': x_trace_print_hook__mutmut_43, 
    'x_trace_print_hook__mutmut_44': x_trace_print_hook__mutmut_44, 
    'x_trace_print_hook__mutmut_45': x_trace_print_hook__mutmut_45, 
    'x_trace_print_hook__mutmut_46': x_trace_print_hook__mutmut_46, 
    'x_trace_print_hook__mutmut_47': x_trace_print_hook__mutmut_47, 
    'x_trace_print_hook__mutmut_48': x_trace_print_hook__mutmut_48, 
    'x_trace_print_hook__mutmut_49': x_trace_print_hook__mutmut_49, 
    'x_trace_print_hook__mutmut_50': x_trace_print_hook__mutmut_50, 
    'x_trace_print_hook__mutmut_51': x_trace_print_hook__mutmut_51, 
    'x_trace_print_hook__mutmut_52': x_trace_print_hook__mutmut_52, 
    'x_trace_print_hook__mutmut_53': x_trace_print_hook__mutmut_53, 
    'x_trace_print_hook__mutmut_54': x_trace_print_hook__mutmut_54, 
    'x_trace_print_hook__mutmut_55': x_trace_print_hook__mutmut_55, 
    'x_trace_print_hook__mutmut_56': x_trace_print_hook__mutmut_56, 
    'x_trace_print_hook__mutmut_57': x_trace_print_hook__mutmut_57, 
    'x_trace_print_hook__mutmut_58': x_trace_print_hook__mutmut_58
}

def trace_print_hook(*args, **kwargs):
    result = _mutmut_trampoline(x_trace_print_hook__mutmut_orig, x_trace_print_hook__mutmut_mutants, args, kwargs)
    return result 

trace_print_hook.__signature__ = _mutmut_signature(x_trace_print_hook__mutmut_orig)
x_trace_print_hook__mutmut_orig.__name__ = 'x_trace_print_hook'


def x_wrap_trace__mutmut_orig(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_1(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = None
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_2(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: None
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_3(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name != which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_4(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(None):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_5(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(None, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_6(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, None, None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_7(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr('__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_8(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_9(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', )):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_10(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, 'XX__contains__XX', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_11(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__CONTAINS__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_12(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = None
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_13(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: None
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_14(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name not in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_15(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None and callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_16(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is not None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_17(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(None):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_18(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = None
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_19(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError(None)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_20(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' / which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_21(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('XXexpected attr name(s) or callable, not: %rXX' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_22(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('EXPECTED ATTR NAME(S) OR CALLABLE, NOT: %R' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_23(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = None

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_24(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label and hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_25(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(None)

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_26(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(None))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_27(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = None
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_28(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = None
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_29(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events and 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_30(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_31(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'XXgetXX' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_32(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'GET' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_33(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' not in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_34(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = None
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_35(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events and 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_36(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_37(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'XXsetXX' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_38(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'SET' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_39(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' not in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_40(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = None
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_41(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events and 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_42(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_43(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'XXdelXX' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_44(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'DEL' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_45(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' not in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_46(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = None
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_47(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events and 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_48(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_49(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'XXcallXX' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_50(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'CALL' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_51(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' not in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_52(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = None
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_53(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events and 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_54(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_55(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'XXraiseXX' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_56(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'RAISE' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_57(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' not in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_58(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = None

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_59(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events and 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_60(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_61(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'XXreturnXX' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_62(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'RETURN' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_63(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' not in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_64(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = None
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_65(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[2:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_66(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event=None, label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_67(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=None, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_68(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=None,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_69(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=None, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_70(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=None, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_71(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=None)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_72(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_73(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_74(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_75(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_76(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_77(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, )
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_78(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='XXcallXX', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_79(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='CALL', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_80(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = None
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_81(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(**kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_82(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, )
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_83(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_84(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event=None, label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_85(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=None, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_86(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=None,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_87(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=None, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_88(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=None, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_89(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=None,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_90(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=None):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_91(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_92(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_93(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_94(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_95(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_96(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_97(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                ):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_98(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='XXraiseXX', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_99(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='RAISE', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_100(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = None
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_101(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(**kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_102(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, )
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_103(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event=None, label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_104(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=None, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_105(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=None,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_106(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=None, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_107(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=None, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_108(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=None, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_109(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=None)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_110(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_111(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_112(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_113(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_114(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_115(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_116(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, )
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_117(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='XXreturnXX', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_118(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='RETURN', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_119(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = None
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_120(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = None
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_121(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = None
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_122(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(None)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_123(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(None, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_124(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, None)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_125(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_126(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, )
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_127(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(None).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_128(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook(None, label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_129(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', None, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_130(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, None, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_131(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, None, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_132(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, None, {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_133(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), None)
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_134(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook(label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_135(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_136(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_137(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_138(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_139(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), )
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_140(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('XXdelXX', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_141(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('DEL', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_142(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = None
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_143(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(None):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_144(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = None
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_145(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(None, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_146(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, None)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_147(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_148(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, )
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_149(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            break

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_150(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) and attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_151(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_152(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(None) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_153(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name not in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_154(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('XX__new__XX',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_155(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__NEW__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_156(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            break
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_157(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func or not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_158(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_159(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(None, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_160(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, None):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_161(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_162(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, ):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_163(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            break

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_164(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name != '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_165(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == 'XX__getattribute__XX':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_166(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__GETATTRIBUTE__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_167(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = None
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_168(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name != '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_169(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == 'XX__setattr__XX':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_170(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__SETATTR__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_171(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = None
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_172(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name != '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_173(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == 'XX__delattr__XX':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_174(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__DELATTR__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_175(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = None
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_176(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = None
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_177(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(None, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_178(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, None)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_179(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_180(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, )
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_181(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = None

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_182(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = None
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_183(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name != cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_184(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.upper():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_185(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = None
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_186(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' - cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_187(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'XXtraced_XX' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_188(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'TRACED_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_189(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = None

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_190(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' - cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_191(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'XXTracedXX' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_192(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_193(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'TRACED' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_194(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(None, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_195(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, None):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_196(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr('__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_197(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, ):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_198(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, 'XX__mro__XX'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_199(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__MRO__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_200(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = None
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_201(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = None

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_202(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = None
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_203(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(None, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_204(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, None, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_205(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, None)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_206(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_207(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_208(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, )
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_209(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(None)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_210(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError(None)


def x_wrap_trace__mutmut_211(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('unable to wrap_trace %r instance %r' / (obj.__class__, obj))


def x_wrap_trace__mutmut_212(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('XXunable to wrap_trace %r instance %rXX'
                    % (obj.__class__, obj))


def x_wrap_trace__mutmut_213(obj, hook=trace_print_hook,
               which=None, events=None, label=None):
    """Monitor an object for interactions. Whenever code calls a method,
    gets an attribute, or sets an attribute, an event is called. By
    default the trace output is printed, but a custom tracing *hook*
    can be passed.

    Args:
       obj (object): New- or old-style object to be traced. Built-in
           objects like lists and dicts also supported.
       hook (callable): A function called once for every event. See
           below for details.
       which (str): One or more attribute names to trace, or a
           function accepting attribute name and value, and returning
           True/False.
       events (str): One or more kinds of events to call *hook*
           on. Expected values are ``['get', 'set', 'del', 'call',
           'raise', 'return']``. Defaults to all events.
       label (str): A name to associate with the traced object
           Defaults to hexadecimal memory address, similar to repr.

    The object returned is not the same object as the one passed
    in. It will not pass identity checks. However, it will pass
    :func:`isinstance` checks, as it is a new instance of a new
    subtype of the object passed.

    """
    # other actions: pdb.set_trace, print, aggregate, aggregate_return
    # (like aggregate but with the return value)

    # TODO: test classmethod/staticmethod/property
    # TODO: wrap __dict__ for old-style classes?

    if isinstance(which, str):
        which_func = lambda attr_name, attr_val: attr_name == which
    elif callable(getattr(which, '__contains__', None)):
        which_func = lambda attr_name, attr_val: attr_name in which
    elif which is None or callable(which):
        which_func = which
    else:
        raise TypeError('expected attr name(s) or callable, not: %r' % which)

    label = label or hex(id(obj))

    if isinstance(events, str):
        events = [events]
    do_get = not events or 'get' in events
    do_set = not events or 'set' in events
    do_del = not events or 'del' in events
    do_call = not events or 'call' in events
    do_raise = not events or 'raise' in events
    do_return = not events or 'return' in events

    def wrap_method(attr_name, func, _hook=hook, _label=label):
        def wrapped(*a, **kw):
            a = a[1:]
            if do_call:
                hook(event='call', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw)
            if do_raise:
                try:
                    ret = func(*a, **kw)
                except Exception:
                    if not hook(event='raise', label=_label, obj=obj,
                                attr_name=attr_name, args=a, kwargs=kw,
                                result=sys.exc_info()):
                        raise
            else:
                ret = func(*a, **kw)
            if do_return:
                hook(event='return', label=_label, obj=obj,
                     attr_name=attr_name, args=a, kwargs=kw, result=ret)
            return ret

        wrapped.__name__ = func.__name__
        wrapped.__doc__ = func.__doc__
        try:
            wrapped.__module__ = func.__module__
        except Exception:
            pass
        try:
            if func.__dict__:
                wrapped.__dict__.update(func.__dict__)
        except Exception:
            pass
        return wrapped

    def __getattribute__(self, attr_name):
        ret = type(obj).__getattribute__(obj, attr_name)
        if callable(ret):  # wrap any bound methods
            ret = type(obj).__getattribute__(self, attr_name)
        if do_get:
            hook('get', label, obj, attr_name, (), {}, result=ret)
        return ret

    def __setattr__(self, attr_name, value):
        type(obj).__setattr__(obj, attr_name, value)
        if do_set:
            hook('set', label, obj, attr_name, (value,), {})
        return

    def __delattr__(self, attr_name):
        type(obj).__delattr__(obj, attr_name)
        if do_del:
            hook('del', label, obj, attr_name, (), {})
        return

    attrs = {}
    for attr_name in dir(obj):
        try:
            attr_val = getattr(obj, attr_name)
        except Exception:
            continue

        if not callable(attr_val) or attr_name in ('__new__',):
            continue
        elif which_func and not which_func(attr_name, attr_val):
            continue

        if attr_name == '__getattribute__':
            wrapped_method = __getattribute__
        elif attr_name == '__setattr__':
            wrapped_method = __setattr__
        elif attr_name == '__delattr__':
            wrapped_method = __delattr__
        else:
            wrapped_method = wrap_method(attr_name, attr_val)
        attrs[attr_name] = wrapped_method

    cls_name = obj.__class__.__name__
    if cls_name == cls_name.lower():
        type_name = 'traced_' + cls_name
    else:
        type_name = 'Traced' + cls_name

    if hasattr(obj, '__mro__'):
        bases = (obj.__class__,)
    else:
        # need new-style class for even basic wrapping of callables to
        # work. getattribute won't work for old-style classes of course.
        bases = (obj.__class__, object)

    trace_type = type(type_name, bases, attrs)
    for cls in trace_type.__mro__:
        try:
            return cls.__new__(trace_type)
        except Exception:
            pass
    raise TypeError('UNABLE TO WRAP_TRACE %R INSTANCE %R'
                    % (obj.__class__, obj))

x_wrap_trace__mutmut_mutants : ClassVar[MutantDict] = {
'x_wrap_trace__mutmut_1': x_wrap_trace__mutmut_1, 
    'x_wrap_trace__mutmut_2': x_wrap_trace__mutmut_2, 
    'x_wrap_trace__mutmut_3': x_wrap_trace__mutmut_3, 
    'x_wrap_trace__mutmut_4': x_wrap_trace__mutmut_4, 
    'x_wrap_trace__mutmut_5': x_wrap_trace__mutmut_5, 
    'x_wrap_trace__mutmut_6': x_wrap_trace__mutmut_6, 
    'x_wrap_trace__mutmut_7': x_wrap_trace__mutmut_7, 
    'x_wrap_trace__mutmut_8': x_wrap_trace__mutmut_8, 
    'x_wrap_trace__mutmut_9': x_wrap_trace__mutmut_9, 
    'x_wrap_trace__mutmut_10': x_wrap_trace__mutmut_10, 
    'x_wrap_trace__mutmut_11': x_wrap_trace__mutmut_11, 
    'x_wrap_trace__mutmut_12': x_wrap_trace__mutmut_12, 
    'x_wrap_trace__mutmut_13': x_wrap_trace__mutmut_13, 
    'x_wrap_trace__mutmut_14': x_wrap_trace__mutmut_14, 
    'x_wrap_trace__mutmut_15': x_wrap_trace__mutmut_15, 
    'x_wrap_trace__mutmut_16': x_wrap_trace__mutmut_16, 
    'x_wrap_trace__mutmut_17': x_wrap_trace__mutmut_17, 
    'x_wrap_trace__mutmut_18': x_wrap_trace__mutmut_18, 
    'x_wrap_trace__mutmut_19': x_wrap_trace__mutmut_19, 
    'x_wrap_trace__mutmut_20': x_wrap_trace__mutmut_20, 
    'x_wrap_trace__mutmut_21': x_wrap_trace__mutmut_21, 
    'x_wrap_trace__mutmut_22': x_wrap_trace__mutmut_22, 
    'x_wrap_trace__mutmut_23': x_wrap_trace__mutmut_23, 
    'x_wrap_trace__mutmut_24': x_wrap_trace__mutmut_24, 
    'x_wrap_trace__mutmut_25': x_wrap_trace__mutmut_25, 
    'x_wrap_trace__mutmut_26': x_wrap_trace__mutmut_26, 
    'x_wrap_trace__mutmut_27': x_wrap_trace__mutmut_27, 
    'x_wrap_trace__mutmut_28': x_wrap_trace__mutmut_28, 
    'x_wrap_trace__mutmut_29': x_wrap_trace__mutmut_29, 
    'x_wrap_trace__mutmut_30': x_wrap_trace__mutmut_30, 
    'x_wrap_trace__mutmut_31': x_wrap_trace__mutmut_31, 
    'x_wrap_trace__mutmut_32': x_wrap_trace__mutmut_32, 
    'x_wrap_trace__mutmut_33': x_wrap_trace__mutmut_33, 
    'x_wrap_trace__mutmut_34': x_wrap_trace__mutmut_34, 
    'x_wrap_trace__mutmut_35': x_wrap_trace__mutmut_35, 
    'x_wrap_trace__mutmut_36': x_wrap_trace__mutmut_36, 
    'x_wrap_trace__mutmut_37': x_wrap_trace__mutmut_37, 
    'x_wrap_trace__mutmut_38': x_wrap_trace__mutmut_38, 
    'x_wrap_trace__mutmut_39': x_wrap_trace__mutmut_39, 
    'x_wrap_trace__mutmut_40': x_wrap_trace__mutmut_40, 
    'x_wrap_trace__mutmut_41': x_wrap_trace__mutmut_41, 
    'x_wrap_trace__mutmut_42': x_wrap_trace__mutmut_42, 
    'x_wrap_trace__mutmut_43': x_wrap_trace__mutmut_43, 
    'x_wrap_trace__mutmut_44': x_wrap_trace__mutmut_44, 
    'x_wrap_trace__mutmut_45': x_wrap_trace__mutmut_45, 
    'x_wrap_trace__mutmut_46': x_wrap_trace__mutmut_46, 
    'x_wrap_trace__mutmut_47': x_wrap_trace__mutmut_47, 
    'x_wrap_trace__mutmut_48': x_wrap_trace__mutmut_48, 
    'x_wrap_trace__mutmut_49': x_wrap_trace__mutmut_49, 
    'x_wrap_trace__mutmut_50': x_wrap_trace__mutmut_50, 
    'x_wrap_trace__mutmut_51': x_wrap_trace__mutmut_51, 
    'x_wrap_trace__mutmut_52': x_wrap_trace__mutmut_52, 
    'x_wrap_trace__mutmut_53': x_wrap_trace__mutmut_53, 
    'x_wrap_trace__mutmut_54': x_wrap_trace__mutmut_54, 
    'x_wrap_trace__mutmut_55': x_wrap_trace__mutmut_55, 
    'x_wrap_trace__mutmut_56': x_wrap_trace__mutmut_56, 
    'x_wrap_trace__mutmut_57': x_wrap_trace__mutmut_57, 
    'x_wrap_trace__mutmut_58': x_wrap_trace__mutmut_58, 
    'x_wrap_trace__mutmut_59': x_wrap_trace__mutmut_59, 
    'x_wrap_trace__mutmut_60': x_wrap_trace__mutmut_60, 
    'x_wrap_trace__mutmut_61': x_wrap_trace__mutmut_61, 
    'x_wrap_trace__mutmut_62': x_wrap_trace__mutmut_62, 
    'x_wrap_trace__mutmut_63': x_wrap_trace__mutmut_63, 
    'x_wrap_trace__mutmut_64': x_wrap_trace__mutmut_64, 
    'x_wrap_trace__mutmut_65': x_wrap_trace__mutmut_65, 
    'x_wrap_trace__mutmut_66': x_wrap_trace__mutmut_66, 
    'x_wrap_trace__mutmut_67': x_wrap_trace__mutmut_67, 
    'x_wrap_trace__mutmut_68': x_wrap_trace__mutmut_68, 
    'x_wrap_trace__mutmut_69': x_wrap_trace__mutmut_69, 
    'x_wrap_trace__mutmut_70': x_wrap_trace__mutmut_70, 
    'x_wrap_trace__mutmut_71': x_wrap_trace__mutmut_71, 
    'x_wrap_trace__mutmut_72': x_wrap_trace__mutmut_72, 
    'x_wrap_trace__mutmut_73': x_wrap_trace__mutmut_73, 
    'x_wrap_trace__mutmut_74': x_wrap_trace__mutmut_74, 
    'x_wrap_trace__mutmut_75': x_wrap_trace__mutmut_75, 
    'x_wrap_trace__mutmut_76': x_wrap_trace__mutmut_76, 
    'x_wrap_trace__mutmut_77': x_wrap_trace__mutmut_77, 
    'x_wrap_trace__mutmut_78': x_wrap_trace__mutmut_78, 
    'x_wrap_trace__mutmut_79': x_wrap_trace__mutmut_79, 
    'x_wrap_trace__mutmut_80': x_wrap_trace__mutmut_80, 
    'x_wrap_trace__mutmut_81': x_wrap_trace__mutmut_81, 
    'x_wrap_trace__mutmut_82': x_wrap_trace__mutmut_82, 
    'x_wrap_trace__mutmut_83': x_wrap_trace__mutmut_83, 
    'x_wrap_trace__mutmut_84': x_wrap_trace__mutmut_84, 
    'x_wrap_trace__mutmut_85': x_wrap_trace__mutmut_85, 
    'x_wrap_trace__mutmut_86': x_wrap_trace__mutmut_86, 
    'x_wrap_trace__mutmut_87': x_wrap_trace__mutmut_87, 
    'x_wrap_trace__mutmut_88': x_wrap_trace__mutmut_88, 
    'x_wrap_trace__mutmut_89': x_wrap_trace__mutmut_89, 
    'x_wrap_trace__mutmut_90': x_wrap_trace__mutmut_90, 
    'x_wrap_trace__mutmut_91': x_wrap_trace__mutmut_91, 
    'x_wrap_trace__mutmut_92': x_wrap_trace__mutmut_92, 
    'x_wrap_trace__mutmut_93': x_wrap_trace__mutmut_93, 
    'x_wrap_trace__mutmut_94': x_wrap_trace__mutmut_94, 
    'x_wrap_trace__mutmut_95': x_wrap_trace__mutmut_95, 
    'x_wrap_trace__mutmut_96': x_wrap_trace__mutmut_96, 
    'x_wrap_trace__mutmut_97': x_wrap_trace__mutmut_97, 
    'x_wrap_trace__mutmut_98': x_wrap_trace__mutmut_98, 
    'x_wrap_trace__mutmut_99': x_wrap_trace__mutmut_99, 
    'x_wrap_trace__mutmut_100': x_wrap_trace__mutmut_100, 
    'x_wrap_trace__mutmut_101': x_wrap_trace__mutmut_101, 
    'x_wrap_trace__mutmut_102': x_wrap_trace__mutmut_102, 
    'x_wrap_trace__mutmut_103': x_wrap_trace__mutmut_103, 
    'x_wrap_trace__mutmut_104': x_wrap_trace__mutmut_104, 
    'x_wrap_trace__mutmut_105': x_wrap_trace__mutmut_105, 
    'x_wrap_trace__mutmut_106': x_wrap_trace__mutmut_106, 
    'x_wrap_trace__mutmut_107': x_wrap_trace__mutmut_107, 
    'x_wrap_trace__mutmut_108': x_wrap_trace__mutmut_108, 
    'x_wrap_trace__mutmut_109': x_wrap_trace__mutmut_109, 
    'x_wrap_trace__mutmut_110': x_wrap_trace__mutmut_110, 
    'x_wrap_trace__mutmut_111': x_wrap_trace__mutmut_111, 
    'x_wrap_trace__mutmut_112': x_wrap_trace__mutmut_112, 
    'x_wrap_trace__mutmut_113': x_wrap_trace__mutmut_113, 
    'x_wrap_trace__mutmut_114': x_wrap_trace__mutmut_114, 
    'x_wrap_trace__mutmut_115': x_wrap_trace__mutmut_115, 
    'x_wrap_trace__mutmut_116': x_wrap_trace__mutmut_116, 
    'x_wrap_trace__mutmut_117': x_wrap_trace__mutmut_117, 
    'x_wrap_trace__mutmut_118': x_wrap_trace__mutmut_118, 
    'x_wrap_trace__mutmut_119': x_wrap_trace__mutmut_119, 
    'x_wrap_trace__mutmut_120': x_wrap_trace__mutmut_120, 
    'x_wrap_trace__mutmut_121': x_wrap_trace__mutmut_121, 
    'x_wrap_trace__mutmut_122': x_wrap_trace__mutmut_122, 
    'x_wrap_trace__mutmut_123': x_wrap_trace__mutmut_123, 
    'x_wrap_trace__mutmut_124': x_wrap_trace__mutmut_124, 
    'x_wrap_trace__mutmut_125': x_wrap_trace__mutmut_125, 
    'x_wrap_trace__mutmut_126': x_wrap_trace__mutmut_126, 
    'x_wrap_trace__mutmut_127': x_wrap_trace__mutmut_127, 
    'x_wrap_trace__mutmut_128': x_wrap_trace__mutmut_128, 
    'x_wrap_trace__mutmut_129': x_wrap_trace__mutmut_129, 
    'x_wrap_trace__mutmut_130': x_wrap_trace__mutmut_130, 
    'x_wrap_trace__mutmut_131': x_wrap_trace__mutmut_131, 
    'x_wrap_trace__mutmut_132': x_wrap_trace__mutmut_132, 
    'x_wrap_trace__mutmut_133': x_wrap_trace__mutmut_133, 
    'x_wrap_trace__mutmut_134': x_wrap_trace__mutmut_134, 
    'x_wrap_trace__mutmut_135': x_wrap_trace__mutmut_135, 
    'x_wrap_trace__mutmut_136': x_wrap_trace__mutmut_136, 
    'x_wrap_trace__mutmut_137': x_wrap_trace__mutmut_137, 
    'x_wrap_trace__mutmut_138': x_wrap_trace__mutmut_138, 
    'x_wrap_trace__mutmut_139': x_wrap_trace__mutmut_139, 
    'x_wrap_trace__mutmut_140': x_wrap_trace__mutmut_140, 
    'x_wrap_trace__mutmut_141': x_wrap_trace__mutmut_141, 
    'x_wrap_trace__mutmut_142': x_wrap_trace__mutmut_142, 
    'x_wrap_trace__mutmut_143': x_wrap_trace__mutmut_143, 
    'x_wrap_trace__mutmut_144': x_wrap_trace__mutmut_144, 
    'x_wrap_trace__mutmut_145': x_wrap_trace__mutmut_145, 
    'x_wrap_trace__mutmut_146': x_wrap_trace__mutmut_146, 
    'x_wrap_trace__mutmut_147': x_wrap_trace__mutmut_147, 
    'x_wrap_trace__mutmut_148': x_wrap_trace__mutmut_148, 
    'x_wrap_trace__mutmut_149': x_wrap_trace__mutmut_149, 
    'x_wrap_trace__mutmut_150': x_wrap_trace__mutmut_150, 
    'x_wrap_trace__mutmut_151': x_wrap_trace__mutmut_151, 
    'x_wrap_trace__mutmut_152': x_wrap_trace__mutmut_152, 
    'x_wrap_trace__mutmut_153': x_wrap_trace__mutmut_153, 
    'x_wrap_trace__mutmut_154': x_wrap_trace__mutmut_154, 
    'x_wrap_trace__mutmut_155': x_wrap_trace__mutmut_155, 
    'x_wrap_trace__mutmut_156': x_wrap_trace__mutmut_156, 
    'x_wrap_trace__mutmut_157': x_wrap_trace__mutmut_157, 
    'x_wrap_trace__mutmut_158': x_wrap_trace__mutmut_158, 
    'x_wrap_trace__mutmut_159': x_wrap_trace__mutmut_159, 
    'x_wrap_trace__mutmut_160': x_wrap_trace__mutmut_160, 
    'x_wrap_trace__mutmut_161': x_wrap_trace__mutmut_161, 
    'x_wrap_trace__mutmut_162': x_wrap_trace__mutmut_162, 
    'x_wrap_trace__mutmut_163': x_wrap_trace__mutmut_163, 
    'x_wrap_trace__mutmut_164': x_wrap_trace__mutmut_164, 
    'x_wrap_trace__mutmut_165': x_wrap_trace__mutmut_165, 
    'x_wrap_trace__mutmut_166': x_wrap_trace__mutmut_166, 
    'x_wrap_trace__mutmut_167': x_wrap_trace__mutmut_167, 
    'x_wrap_trace__mutmut_168': x_wrap_trace__mutmut_168, 
    'x_wrap_trace__mutmut_169': x_wrap_trace__mutmut_169, 
    'x_wrap_trace__mutmut_170': x_wrap_trace__mutmut_170, 
    'x_wrap_trace__mutmut_171': x_wrap_trace__mutmut_171, 
    'x_wrap_trace__mutmut_172': x_wrap_trace__mutmut_172, 
    'x_wrap_trace__mutmut_173': x_wrap_trace__mutmut_173, 
    'x_wrap_trace__mutmut_174': x_wrap_trace__mutmut_174, 
    'x_wrap_trace__mutmut_175': x_wrap_trace__mutmut_175, 
    'x_wrap_trace__mutmut_176': x_wrap_trace__mutmut_176, 
    'x_wrap_trace__mutmut_177': x_wrap_trace__mutmut_177, 
    'x_wrap_trace__mutmut_178': x_wrap_trace__mutmut_178, 
    'x_wrap_trace__mutmut_179': x_wrap_trace__mutmut_179, 
    'x_wrap_trace__mutmut_180': x_wrap_trace__mutmut_180, 
    'x_wrap_trace__mutmut_181': x_wrap_trace__mutmut_181, 
    'x_wrap_trace__mutmut_182': x_wrap_trace__mutmut_182, 
    'x_wrap_trace__mutmut_183': x_wrap_trace__mutmut_183, 
    'x_wrap_trace__mutmut_184': x_wrap_trace__mutmut_184, 
    'x_wrap_trace__mutmut_185': x_wrap_trace__mutmut_185, 
    'x_wrap_trace__mutmut_186': x_wrap_trace__mutmut_186, 
    'x_wrap_trace__mutmut_187': x_wrap_trace__mutmut_187, 
    'x_wrap_trace__mutmut_188': x_wrap_trace__mutmut_188, 
    'x_wrap_trace__mutmut_189': x_wrap_trace__mutmut_189, 
    'x_wrap_trace__mutmut_190': x_wrap_trace__mutmut_190, 
    'x_wrap_trace__mutmut_191': x_wrap_trace__mutmut_191, 
    'x_wrap_trace__mutmut_192': x_wrap_trace__mutmut_192, 
    'x_wrap_trace__mutmut_193': x_wrap_trace__mutmut_193, 
    'x_wrap_trace__mutmut_194': x_wrap_trace__mutmut_194, 
    'x_wrap_trace__mutmut_195': x_wrap_trace__mutmut_195, 
    'x_wrap_trace__mutmut_196': x_wrap_trace__mutmut_196, 
    'x_wrap_trace__mutmut_197': x_wrap_trace__mutmut_197, 
    'x_wrap_trace__mutmut_198': x_wrap_trace__mutmut_198, 
    'x_wrap_trace__mutmut_199': x_wrap_trace__mutmut_199, 
    'x_wrap_trace__mutmut_200': x_wrap_trace__mutmut_200, 
    'x_wrap_trace__mutmut_201': x_wrap_trace__mutmut_201, 
    'x_wrap_trace__mutmut_202': x_wrap_trace__mutmut_202, 
    'x_wrap_trace__mutmut_203': x_wrap_trace__mutmut_203, 
    'x_wrap_trace__mutmut_204': x_wrap_trace__mutmut_204, 
    'x_wrap_trace__mutmut_205': x_wrap_trace__mutmut_205, 
    'x_wrap_trace__mutmut_206': x_wrap_trace__mutmut_206, 
    'x_wrap_trace__mutmut_207': x_wrap_trace__mutmut_207, 
    'x_wrap_trace__mutmut_208': x_wrap_trace__mutmut_208, 
    'x_wrap_trace__mutmut_209': x_wrap_trace__mutmut_209, 
    'x_wrap_trace__mutmut_210': x_wrap_trace__mutmut_210, 
    'x_wrap_trace__mutmut_211': x_wrap_trace__mutmut_211, 
    'x_wrap_trace__mutmut_212': x_wrap_trace__mutmut_212, 
    'x_wrap_trace__mutmut_213': x_wrap_trace__mutmut_213
}

def wrap_trace(*args, **kwargs):
    result = _mutmut_trampoline(x_wrap_trace__mutmut_orig, x_wrap_trace__mutmut_mutants, args, kwargs)
    return result 

wrap_trace.__signature__ = _mutmut_signature(x_wrap_trace__mutmut_orig)
x_wrap_trace__mutmut_orig.__name__ = 'x_wrap_trace'


