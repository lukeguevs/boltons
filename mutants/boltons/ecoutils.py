# Copyright (c) 2013, Mahmoud Hashemi
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#    * Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials provided
#      with the distribution.
#
#    * The names of the contributors may not be used to endorse or
#      promote products derived from this software without specific
#      prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""As a programming ecosystem grows, so do the chances of runtime
variability.

Python boasts one of the widest deployments for a high-level
programming environment, making it a viable target for all manner of
application. But with breadth comes variance, so it's important to
know what you're working with.

Some basic variations that are common among development machines:

* **Executable runtime**: CPython, PyPy, Jython, etc., plus build date and compiler
* **Language version**: 2.7 through 3.12
* **Host operating system**: Windows, OS X, Ubuntu, Debian, CentOS, RHEL, etc.
* **Features**: 64-bit, IPv6, Unicode character support (UCS-2/UCS-4)
* **Built-in library support**: OpenSSL, threading, SQLite, zlib
* **User environment**: umask, ulimit, working directory path
* **Machine info**: CPU count, hostname, filesystem encoding

See the full example profile below for more.

ecoutils was created to quantify that variability. ecoutils quickly
produces an information-dense description of critical runtime factors,
with minimal side effects. In short, ecoutils is like browser and user
agent analytics, but for Python environments.

Transmission and collection
---------------------------

The data is all JSON serializable, and is suitable for sending to a
central analytics server. An HTTP-backed service for this can be found
at: https://github.com/mahmoud/espymetrics/

Notable omissions
-----------------

Due to space constraints (and possibly latency constraints), the
following information is deemed not dense enough, and thus omitted:

* :data:`sys.path`
* full :mod:`sysconfig`
* environment variables (:data:`os.environ`)

Compatibility
-------------

So far ecoutils has has been tested on Python 3.7+ and PyPy3. 
Various versions have been tested on Ubuntu, Debian,
RHEL, OS X, FreeBSD, and Windows 7.

.. note:: 

   ``boltons.ecoutils`` historically supported back to Python 2.4, but in 2024, 
    due to increasing testing burden, ecoutils support tracks the same 
    versions of Python as the rest of the boltons package. 
    For older Pythons, see `this version`_ from boltons 23.0.0.

.. _this version: https://github.com/mahmoud/boltons/blob/4b1d728f31a8378b193be9c966c853be0a57527d/boltons/ecoutils.py

Profile generation
------------------

Profiles are generated by :func:`ecoutils.get_profile`.

When run as a module, ecoutils will call :func:`~ecoutils.get_profile`
and print a profile in JSON format::

    $ python -m boltons.ecoutils
    {
      "_eco_version": "1.0.0",
      "cpu_count": 4,
      "cwd": "/home/mahmoud/projects/boltons",
      "fs_encoding": "UTF-8",
      "guid": "6b139e7bbf5ad4ed8d4063bf6235b4d2",
      "hostfqdn": "mahmoud-host",
      "hostname": "mahmoud-host",
      "linux_dist_name": "Ubuntu",
      "linux_dist_version": "14.04",
      "python": {
        "argv": "boltons/ecoutils.py",
        "bin": "/usr/bin/python",
        "build_date": "Jun 22 2015 17:58:13",
        "compiler": "GCC 4.8.2",
        "features": {
          "64bit": true,
          "expat": "expat_2.1.0",
          "ipv6": true,
          "openssl": "OpenSSL 1.0.1f 6 Jan 2014",
          "readline": true,
          "sqlite": "3.8.2",
          "threading": true,
          "tkinter": "8.6",
          "unicode_wide": true,
          "zlib": "1.2.8"
        },
        "version": "2.7.6 (default, Jun 22 2015, 17:58:13) [GCC 4.8.2]",
        "version_info": [
          2,
          7,
          6,
          "final",
          0
        ]
      },
      "time_utc": "2016-05-24 07:59:40.473140",
      "time_utc_offset": -8.0,
      "ulimit_hard": 4096,
      "ulimit_soft": 1024,
      "umask": "002",
      "uname": {
        "machine": "x86_64",
        "node": "mahmoud-host",
        "processor": "x86_64",
        "release": "3.13.0-85-generic",
        "system": "Linux",
        "version": "#129-Ubuntu SMP Thu Mar 17 20:50:15 UTC 2016"
      },
      "username": "mahmoud"
    }

``pip install boltons`` and try it yourself!

"""

import re
import os
import sys
import json
import time
import random
import socket
import struct
import getpass
import datetime
import platform

ECO_VERSION = '1.1.0'  # see version history below


try:
    getrandbits = random.SystemRandom().getrandbits
    HAVE_URANDOM = True
except Exception:
    HAVE_URANDOM = False
    getrandbits = random.getrandbits


# 128-bit GUID just like a UUID, but backwards compatible to 2.4
INSTANCE_ID = hex(getrandbits(128))[2:-1].lower()

IS_64BIT = struct.calcsize("P") > 4
HAVE_UCS4 = getattr(sys, 'maxunicode', 0) > 65536
HAVE_READLINE = True

try:
    import readline
except Exception:
    HAVE_READLINE = False

try:
    import sqlite3
    SQLITE_VERSION = sqlite3.sqlite_version
except Exception:
    # note: 2.5 and older have sqlite, but not sqlite3
    SQLITE_VERSION = ''


try:

    import ssl
    try:
        OPENSSL_VERSION = ssl.OPENSSL_VERSION
    except AttributeError:
        # This is a conservative estimate for Python <2.6
        # SSL module added in 2006, when 0.9.7 was standard
        OPENSSL_VERSION = 'OpenSSL >0.8.0'
except Exception:
    OPENSSL_VERSION = ''


try:
    import tkinter
    TKINTER_VERSION = str(tkinter.TkVersion)
except Exception:
    TKINTER_VERSION = ''


try:
    import zlib
    ZLIB_VERSION = zlib.ZLIB_VERSION
except Exception:
    ZLIB_VERSION = ''


try:
    from xml.parsers import expat
    EXPAT_VERSION = expat.EXPAT_VERSION
except Exception:
    EXPAT_VERSION = ''


try:
    from multiprocessing import cpu_count
    CPU_COUNT = cpu_count()
except Exception:
    CPU_COUNT = 0

try:
    import threading
    HAVE_THREADING = True
except Exception:
    HAVE_THREADING = False


try:
    HAVE_IPV6 = socket.has_ipv6
except Exception:
    HAVE_IPV6 = False


try:
    from resource import getrlimit, RLIMIT_NOFILE
    RLIMIT_FDS_SOFT, RLIMIT_FDS_HARD = getrlimit(RLIMIT_NOFILE)
except Exception:
    RLIMIT_FDS_SOFT, RLIMIT_FDS_HARD = 0, 0


START_TIME_INFO = {'time_utc': str(datetime.datetime.now(datetime.timezone.utc)),
                   'time_utc_offset': -time.timezone / 3600.0}
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result


def x_get_python_info__mutmut_orig():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_1():
    ret = None
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_2():
    ret = {}
    ret['argv'] = None
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_3():
    ret = {}
    ret['XXargvXX'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_4():
    ret = {}
    ret['ARGV'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_5():
    ret = {}
    ret['argv'] = _escape_shell_args(None)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_6():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = None

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_7():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['XXbinXX'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_8():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['BIN'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_9():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = None

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_10():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['XXversionXX'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_11():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['VERSION'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_12():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(None)

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_13():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = 'XX XX'.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_14():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = None
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_15():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['XXcompilerXX'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_16():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['COMPILER'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_17():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = None
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_18():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['XXbuild_dateXX'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_19():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['BUILD_DATE'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_20():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[2]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_21():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = None

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_22():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['XXversion_infoXX'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_23():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['VERSION_INFO'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_24():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(None)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_25():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = None

    return ret


def x_get_python_info__mutmut_26():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['XXfeaturesXX'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_27():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['FEATURES'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_28():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'XXopensslXX': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_29():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'OPENSSL': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_30():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'XXexpatXX': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_31():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'EXPAT': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_32():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'XXsqliteXX': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_33():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'SQLITE': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_34():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'XXtkinterXX': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_35():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'TKINTER': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_36():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'XXzlibXX': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_37():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'ZLIB': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_38():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'XXunicode_wideXX': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_39():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'UNICODE_WIDE': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_40():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'XXreadlineXX': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_41():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'READLINE': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_42():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       'XX64bitXX': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_43():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64BIT': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_44():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'XXipv6XX': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_45():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'IPV6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_46():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'XXthreadingXX': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_47():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'THREADING': HAVE_THREADING,
                       'urandom': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_48():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'XXurandomXX': HAVE_URANDOM}

    return ret


def x_get_python_info__mutmut_49():
    ret = {}
    ret['argv'] = _escape_shell_args(sys.argv)
    ret['bin'] = sys.executable

    # Even though compiler/build_date are already here, they're
    # actually parsed from the version string. So, in the rare case of
    # the unparsable version string, we're still transmitting it.
    ret['version'] = ' '.join(sys.version.split())

    ret['compiler'] = platform.python_compiler()
    ret['build_date'] = platform.python_build()[1]
    ret['version_info'] = list(sys.version_info)

    ret['features'] = {'openssl': OPENSSL_VERSION,
                       'expat': EXPAT_VERSION,
                       'sqlite': SQLITE_VERSION,
                       'tkinter': TKINTER_VERSION,
                       'zlib': ZLIB_VERSION,
                       'unicode_wide': HAVE_UCS4,
                       'readline': HAVE_READLINE,
                       '64bit': IS_64BIT,
                       'ipv6': HAVE_IPV6,
                       'threading': HAVE_THREADING,
                       'URANDOM': HAVE_URANDOM}

    return ret

x_get_python_info__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_python_info__mutmut_1': x_get_python_info__mutmut_1, 
    'x_get_python_info__mutmut_2': x_get_python_info__mutmut_2, 
    'x_get_python_info__mutmut_3': x_get_python_info__mutmut_3, 
    'x_get_python_info__mutmut_4': x_get_python_info__mutmut_4, 
    'x_get_python_info__mutmut_5': x_get_python_info__mutmut_5, 
    'x_get_python_info__mutmut_6': x_get_python_info__mutmut_6, 
    'x_get_python_info__mutmut_7': x_get_python_info__mutmut_7, 
    'x_get_python_info__mutmut_8': x_get_python_info__mutmut_8, 
    'x_get_python_info__mutmut_9': x_get_python_info__mutmut_9, 
    'x_get_python_info__mutmut_10': x_get_python_info__mutmut_10, 
    'x_get_python_info__mutmut_11': x_get_python_info__mutmut_11, 
    'x_get_python_info__mutmut_12': x_get_python_info__mutmut_12, 
    'x_get_python_info__mutmut_13': x_get_python_info__mutmut_13, 
    'x_get_python_info__mutmut_14': x_get_python_info__mutmut_14, 
    'x_get_python_info__mutmut_15': x_get_python_info__mutmut_15, 
    'x_get_python_info__mutmut_16': x_get_python_info__mutmut_16, 
    'x_get_python_info__mutmut_17': x_get_python_info__mutmut_17, 
    'x_get_python_info__mutmut_18': x_get_python_info__mutmut_18, 
    'x_get_python_info__mutmut_19': x_get_python_info__mutmut_19, 
    'x_get_python_info__mutmut_20': x_get_python_info__mutmut_20, 
    'x_get_python_info__mutmut_21': x_get_python_info__mutmut_21, 
    'x_get_python_info__mutmut_22': x_get_python_info__mutmut_22, 
    'x_get_python_info__mutmut_23': x_get_python_info__mutmut_23, 
    'x_get_python_info__mutmut_24': x_get_python_info__mutmut_24, 
    'x_get_python_info__mutmut_25': x_get_python_info__mutmut_25, 
    'x_get_python_info__mutmut_26': x_get_python_info__mutmut_26, 
    'x_get_python_info__mutmut_27': x_get_python_info__mutmut_27, 
    'x_get_python_info__mutmut_28': x_get_python_info__mutmut_28, 
    'x_get_python_info__mutmut_29': x_get_python_info__mutmut_29, 
    'x_get_python_info__mutmut_30': x_get_python_info__mutmut_30, 
    'x_get_python_info__mutmut_31': x_get_python_info__mutmut_31, 
    'x_get_python_info__mutmut_32': x_get_python_info__mutmut_32, 
    'x_get_python_info__mutmut_33': x_get_python_info__mutmut_33, 
    'x_get_python_info__mutmut_34': x_get_python_info__mutmut_34, 
    'x_get_python_info__mutmut_35': x_get_python_info__mutmut_35, 
    'x_get_python_info__mutmut_36': x_get_python_info__mutmut_36, 
    'x_get_python_info__mutmut_37': x_get_python_info__mutmut_37, 
    'x_get_python_info__mutmut_38': x_get_python_info__mutmut_38, 
    'x_get_python_info__mutmut_39': x_get_python_info__mutmut_39, 
    'x_get_python_info__mutmut_40': x_get_python_info__mutmut_40, 
    'x_get_python_info__mutmut_41': x_get_python_info__mutmut_41, 
    'x_get_python_info__mutmut_42': x_get_python_info__mutmut_42, 
    'x_get_python_info__mutmut_43': x_get_python_info__mutmut_43, 
    'x_get_python_info__mutmut_44': x_get_python_info__mutmut_44, 
    'x_get_python_info__mutmut_45': x_get_python_info__mutmut_45, 
    'x_get_python_info__mutmut_46': x_get_python_info__mutmut_46, 
    'x_get_python_info__mutmut_47': x_get_python_info__mutmut_47, 
    'x_get_python_info__mutmut_48': x_get_python_info__mutmut_48, 
    'x_get_python_info__mutmut_49': x_get_python_info__mutmut_49
}

def get_python_info(*args, **kwargs):
    result = _mutmut_trampoline(x_get_python_info__mutmut_orig, x_get_python_info__mutmut_mutants, args, kwargs)
    return result 

get_python_info.__signature__ = _mutmut_signature(x_get_python_info__mutmut_orig)
x_get_python_info__mutmut_orig.__name__ = 'x_get_python_info'


def x_get_profile__mutmut_orig(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_1(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = None
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_2(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop(None, False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_3(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', None)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_4(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop(False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_5(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', )
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_6(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('XXscrubXX', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_7(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('SCRUB', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_8(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', True)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_9(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(None)
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_10(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = None
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_11(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = None
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_12(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['XXusernameXX'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_13(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['USERNAME'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_14(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = None
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_15(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['XXusernameXX'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_16(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['USERNAME'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_17(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = 'XXXX'
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_18(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = None
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_19(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['XXguidXX'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_20(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['GUID'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_21(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(None)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_22(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = None
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_23(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['XXhostnameXX'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_24(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['HOSTNAME'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_25(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = None
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_26(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['XXhostfqdnXX'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_27(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['HOSTFQDN'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_28(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = None
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_29(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = None
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_30(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['XXunameXX'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_31(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['UNAME'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_32(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'XXsystemXX': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_33(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'SYSTEM': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_34(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[1],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_35(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'XXnodeXX': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_36(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'NODE': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_37(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[2],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_38(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'XXreleaseXX': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_39(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'RELEASE': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_40(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[3],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_41(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'XXversionXX': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_42(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'VERSION': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_43(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[4],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_44(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'XXmachineXX': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_45(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'MACHINE': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_46(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[5],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_47(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'XXprocessorXX': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_48(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'PROCESSOR': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_49(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[6]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_50(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = None  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_51(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = None
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_52(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('XXXX', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_53(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', 'XXXX', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_54(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', 'XXXX')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_55(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = None
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_56(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['XXlinux_dist_nameXX'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_57(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['LINUX_DIST_NAME'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_58(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[1]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_59(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = None
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_60(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['XXlinux_dist_versionXX'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_61(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['LINUX_DIST_VERSION'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_62(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[2]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_63(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = None

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_64(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['XXcpu_countXX'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_65(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['CPU_COUNT'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_66(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = None
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_67(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['XXfs_encodingXX'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_68(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['FS_ENCODING'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_69(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = None
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_70(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['XXulimit_softXX'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_71(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ULIMIT_SOFT'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_72(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = None
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_73(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['XXulimit_hardXX'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_74(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ULIMIT_HARD'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_75(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = None
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_76(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['XXcwdXX'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_77(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['CWD'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_78(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = None

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_79(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['XXumaskXX'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_80(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['UMASK'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_81(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(None, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_82(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, None)

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_83(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust('0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_84(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, )

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_85(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).ljust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_86(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(None).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_87(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(None)).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_88(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(None))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_89(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(3))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_90(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(4, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_91(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, 'XX0XX')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_92(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = None
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_93(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['XXpythonXX'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_94(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['PYTHON'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_95(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(None)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_96(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = None

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_97(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['XX_eco_versionXX'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_98(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_ECO_VERSION'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_99(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = None
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_100(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['XXcwdXX'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_101(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['CWD'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_102(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = 'XX-XX'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_103(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = None
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_104(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['XXhostnameXX'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_105(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['HOSTNAME'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_106(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = 'XX-XX'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_107(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = None
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_108(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['XXhostfqdnXX'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_109(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['HOSTFQDN'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_110(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = 'XX-XX'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_111(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = None
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_112(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['XXpythonXX']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_113(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['PYTHON']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_114(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['XXbinXX'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_115(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['BIN'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_116(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = 'XX-XX'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_117(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = None
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_118(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['XXpythonXX']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_119(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['PYTHON']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_120(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['XXargvXX'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_121(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['ARGV'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_122(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = 'XX-XX'
        ret['uname']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_123(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = None
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_124(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['XXunameXX']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_125(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['UNAME']['node'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_126(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['XXnodeXX'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_127(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['NODE'] = '-'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_128(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = 'XX-XX'
        ret['username'] = '-'

    return ret


def x_get_profile__mutmut_129(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = None

    return ret


def x_get_profile__mutmut_130(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['XXusernameXX'] = '-'

    return ret


def x_get_profile__mutmut_131(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['USERNAME'] = '-'

    return ret


def x_get_profile__mutmut_132(**kwargs):
    """The main entrypoint to ecoutils. Calling this will return a
    JSON-serializable dictionary of information about the current
    process.

    It is very unlikely that the information returned will change
    during the lifetime of the process, and in most cases the majority
    of the information stays the same between runs as well.

    :func:`get_profile` takes one optional keyword argument, *scrub*,
    a :class:`bool` that, if True, blanks out identifiable
    information. This includes current working directory, hostname,
    Python executable path, command-line arguments, and
    username. Values are replaced with '-', but for compatibility keys
    remain in place.

    """
    scrub = kwargs.pop('scrub', False)
    if kwargs:
        raise TypeError(f'unexpected keyword arguments: {kwargs.keys()!r}')
    ret = {}
    try:
        ret['username'] = getpass.getuser()
    except Exception:
        ret['username'] = ''
    ret['guid'] = str(INSTANCE_ID)
    ret['hostname'] = socket.gethostname()
    ret['hostfqdn'] = socket.getfqdn()
    uname = platform.uname()
    ret['uname'] = {'system': uname[0],
                    'node': uname[1],
                    'release': uname[2],  # linux: distro name
                    'version': uname[3],  # linux: kernel version
                    'machine': uname[4],
                    'processor': uname[5]}
    try:
        # TODO: removed in 3.7, replaced with freedesktop_os_release in 3.10
        linux_dist = platform.linux_distribution()  
    except Exception:
        linux_dist = ('', '', '')
    ret['linux_dist_name'] = linux_dist[0]
    ret['linux_dist_version'] = linux_dist[1]
    ret['cpu_count'] = CPU_COUNT

    ret['fs_encoding'] = sys.getfilesystemencoding()
    ret['ulimit_soft'] = RLIMIT_FDS_SOFT
    ret['ulimit_hard'] = RLIMIT_FDS_HARD
    ret['cwd'] = os.getcwd()
    ret['umask'] = oct(os.umask(os.umask(2))).rjust(3, '0')

    ret['python'] = get_python_info()
    ret.update(START_TIME_INFO)
    ret['_eco_version'] = ECO_VERSION

    if scrub:
        # mask identifiable information
        ret['cwd'] = '-'
        ret['hostname'] = '-'
        ret['hostfqdn'] = '-'
        ret['python']['bin'] = '-'
        ret['python']['argv'] = '-'
        ret['uname']['node'] = '-'
        ret['username'] = 'XX-XX'

    return ret

x_get_profile__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_profile__mutmut_1': x_get_profile__mutmut_1, 
    'x_get_profile__mutmut_2': x_get_profile__mutmut_2, 
    'x_get_profile__mutmut_3': x_get_profile__mutmut_3, 
    'x_get_profile__mutmut_4': x_get_profile__mutmut_4, 
    'x_get_profile__mutmut_5': x_get_profile__mutmut_5, 
    'x_get_profile__mutmut_6': x_get_profile__mutmut_6, 
    'x_get_profile__mutmut_7': x_get_profile__mutmut_7, 
    'x_get_profile__mutmut_8': x_get_profile__mutmut_8, 
    'x_get_profile__mutmut_9': x_get_profile__mutmut_9, 
    'x_get_profile__mutmut_10': x_get_profile__mutmut_10, 
    'x_get_profile__mutmut_11': x_get_profile__mutmut_11, 
    'x_get_profile__mutmut_12': x_get_profile__mutmut_12, 
    'x_get_profile__mutmut_13': x_get_profile__mutmut_13, 
    'x_get_profile__mutmut_14': x_get_profile__mutmut_14, 
    'x_get_profile__mutmut_15': x_get_profile__mutmut_15, 
    'x_get_profile__mutmut_16': x_get_profile__mutmut_16, 
    'x_get_profile__mutmut_17': x_get_profile__mutmut_17, 
    'x_get_profile__mutmut_18': x_get_profile__mutmut_18, 
    'x_get_profile__mutmut_19': x_get_profile__mutmut_19, 
    'x_get_profile__mutmut_20': x_get_profile__mutmut_20, 
    'x_get_profile__mutmut_21': x_get_profile__mutmut_21, 
    'x_get_profile__mutmut_22': x_get_profile__mutmut_22, 
    'x_get_profile__mutmut_23': x_get_profile__mutmut_23, 
    'x_get_profile__mutmut_24': x_get_profile__mutmut_24, 
    'x_get_profile__mutmut_25': x_get_profile__mutmut_25, 
    'x_get_profile__mutmut_26': x_get_profile__mutmut_26, 
    'x_get_profile__mutmut_27': x_get_profile__mutmut_27, 
    'x_get_profile__mutmut_28': x_get_profile__mutmut_28, 
    'x_get_profile__mutmut_29': x_get_profile__mutmut_29, 
    'x_get_profile__mutmut_30': x_get_profile__mutmut_30, 
    'x_get_profile__mutmut_31': x_get_profile__mutmut_31, 
    'x_get_profile__mutmut_32': x_get_profile__mutmut_32, 
    'x_get_profile__mutmut_33': x_get_profile__mutmut_33, 
    'x_get_profile__mutmut_34': x_get_profile__mutmut_34, 
    'x_get_profile__mutmut_35': x_get_profile__mutmut_35, 
    'x_get_profile__mutmut_36': x_get_profile__mutmut_36, 
    'x_get_profile__mutmut_37': x_get_profile__mutmut_37, 
    'x_get_profile__mutmut_38': x_get_profile__mutmut_38, 
    'x_get_profile__mutmut_39': x_get_profile__mutmut_39, 
    'x_get_profile__mutmut_40': x_get_profile__mutmut_40, 
    'x_get_profile__mutmut_41': x_get_profile__mutmut_41, 
    'x_get_profile__mutmut_42': x_get_profile__mutmut_42, 
    'x_get_profile__mutmut_43': x_get_profile__mutmut_43, 
    'x_get_profile__mutmut_44': x_get_profile__mutmut_44, 
    'x_get_profile__mutmut_45': x_get_profile__mutmut_45, 
    'x_get_profile__mutmut_46': x_get_profile__mutmut_46, 
    'x_get_profile__mutmut_47': x_get_profile__mutmut_47, 
    'x_get_profile__mutmut_48': x_get_profile__mutmut_48, 
    'x_get_profile__mutmut_49': x_get_profile__mutmut_49, 
    'x_get_profile__mutmut_50': x_get_profile__mutmut_50, 
    'x_get_profile__mutmut_51': x_get_profile__mutmut_51, 
    'x_get_profile__mutmut_52': x_get_profile__mutmut_52, 
    'x_get_profile__mutmut_53': x_get_profile__mutmut_53, 
    'x_get_profile__mutmut_54': x_get_profile__mutmut_54, 
    'x_get_profile__mutmut_55': x_get_profile__mutmut_55, 
    'x_get_profile__mutmut_56': x_get_profile__mutmut_56, 
    'x_get_profile__mutmut_57': x_get_profile__mutmut_57, 
    'x_get_profile__mutmut_58': x_get_profile__mutmut_58, 
    'x_get_profile__mutmut_59': x_get_profile__mutmut_59, 
    'x_get_profile__mutmut_60': x_get_profile__mutmut_60, 
    'x_get_profile__mutmut_61': x_get_profile__mutmut_61, 
    'x_get_profile__mutmut_62': x_get_profile__mutmut_62, 
    'x_get_profile__mutmut_63': x_get_profile__mutmut_63, 
    'x_get_profile__mutmut_64': x_get_profile__mutmut_64, 
    'x_get_profile__mutmut_65': x_get_profile__mutmut_65, 
    'x_get_profile__mutmut_66': x_get_profile__mutmut_66, 
    'x_get_profile__mutmut_67': x_get_profile__mutmut_67, 
    'x_get_profile__mutmut_68': x_get_profile__mutmut_68, 
    'x_get_profile__mutmut_69': x_get_profile__mutmut_69, 
    'x_get_profile__mutmut_70': x_get_profile__mutmut_70, 
    'x_get_profile__mutmut_71': x_get_profile__mutmut_71, 
    'x_get_profile__mutmut_72': x_get_profile__mutmut_72, 
    'x_get_profile__mutmut_73': x_get_profile__mutmut_73, 
    'x_get_profile__mutmut_74': x_get_profile__mutmut_74, 
    'x_get_profile__mutmut_75': x_get_profile__mutmut_75, 
    'x_get_profile__mutmut_76': x_get_profile__mutmut_76, 
    'x_get_profile__mutmut_77': x_get_profile__mutmut_77, 
    'x_get_profile__mutmut_78': x_get_profile__mutmut_78, 
    'x_get_profile__mutmut_79': x_get_profile__mutmut_79, 
    'x_get_profile__mutmut_80': x_get_profile__mutmut_80, 
    'x_get_profile__mutmut_81': x_get_profile__mutmut_81, 
    'x_get_profile__mutmut_82': x_get_profile__mutmut_82, 
    'x_get_profile__mutmut_83': x_get_profile__mutmut_83, 
    'x_get_profile__mutmut_84': x_get_profile__mutmut_84, 
    'x_get_profile__mutmut_85': x_get_profile__mutmut_85, 
    'x_get_profile__mutmut_86': x_get_profile__mutmut_86, 
    'x_get_profile__mutmut_87': x_get_profile__mutmut_87, 
    'x_get_profile__mutmut_88': x_get_profile__mutmut_88, 
    'x_get_profile__mutmut_89': x_get_profile__mutmut_89, 
    'x_get_profile__mutmut_90': x_get_profile__mutmut_90, 
    'x_get_profile__mutmut_91': x_get_profile__mutmut_91, 
    'x_get_profile__mutmut_92': x_get_profile__mutmut_92, 
    'x_get_profile__mutmut_93': x_get_profile__mutmut_93, 
    'x_get_profile__mutmut_94': x_get_profile__mutmut_94, 
    'x_get_profile__mutmut_95': x_get_profile__mutmut_95, 
    'x_get_profile__mutmut_96': x_get_profile__mutmut_96, 
    'x_get_profile__mutmut_97': x_get_profile__mutmut_97, 
    'x_get_profile__mutmut_98': x_get_profile__mutmut_98, 
    'x_get_profile__mutmut_99': x_get_profile__mutmut_99, 
    'x_get_profile__mutmut_100': x_get_profile__mutmut_100, 
    'x_get_profile__mutmut_101': x_get_profile__mutmut_101, 
    'x_get_profile__mutmut_102': x_get_profile__mutmut_102, 
    'x_get_profile__mutmut_103': x_get_profile__mutmut_103, 
    'x_get_profile__mutmut_104': x_get_profile__mutmut_104, 
    'x_get_profile__mutmut_105': x_get_profile__mutmut_105, 
    'x_get_profile__mutmut_106': x_get_profile__mutmut_106, 
    'x_get_profile__mutmut_107': x_get_profile__mutmut_107, 
    'x_get_profile__mutmut_108': x_get_profile__mutmut_108, 
    'x_get_profile__mutmut_109': x_get_profile__mutmut_109, 
    'x_get_profile__mutmut_110': x_get_profile__mutmut_110, 
    'x_get_profile__mutmut_111': x_get_profile__mutmut_111, 
    'x_get_profile__mutmut_112': x_get_profile__mutmut_112, 
    'x_get_profile__mutmut_113': x_get_profile__mutmut_113, 
    'x_get_profile__mutmut_114': x_get_profile__mutmut_114, 
    'x_get_profile__mutmut_115': x_get_profile__mutmut_115, 
    'x_get_profile__mutmut_116': x_get_profile__mutmut_116, 
    'x_get_profile__mutmut_117': x_get_profile__mutmut_117, 
    'x_get_profile__mutmut_118': x_get_profile__mutmut_118, 
    'x_get_profile__mutmut_119': x_get_profile__mutmut_119, 
    'x_get_profile__mutmut_120': x_get_profile__mutmut_120, 
    'x_get_profile__mutmut_121': x_get_profile__mutmut_121, 
    'x_get_profile__mutmut_122': x_get_profile__mutmut_122, 
    'x_get_profile__mutmut_123': x_get_profile__mutmut_123, 
    'x_get_profile__mutmut_124': x_get_profile__mutmut_124, 
    'x_get_profile__mutmut_125': x_get_profile__mutmut_125, 
    'x_get_profile__mutmut_126': x_get_profile__mutmut_126, 
    'x_get_profile__mutmut_127': x_get_profile__mutmut_127, 
    'x_get_profile__mutmut_128': x_get_profile__mutmut_128, 
    'x_get_profile__mutmut_129': x_get_profile__mutmut_129, 
    'x_get_profile__mutmut_130': x_get_profile__mutmut_130, 
    'x_get_profile__mutmut_131': x_get_profile__mutmut_131, 
    'x_get_profile__mutmut_132': x_get_profile__mutmut_132
}

def get_profile(*args, **kwargs):
    result = _mutmut_trampoline(x_get_profile__mutmut_orig, x_get_profile__mutmut_mutants, args, kwargs)
    return result 

get_profile.__signature__ = _mutmut_signature(x_get_profile__mutmut_orig)
x_get_profile__mutmut_orig.__name__ = 'x_get_profile'


def x_dumps__mutmut_orig(val, indent):
    if indent:
        return json.dumps(val, sort_keys=True, indent=indent)
    return json.dumps(val, sort_keys=True)


def x_dumps__mutmut_1(val, indent):
    if indent:
        return json.dumps(None, sort_keys=True, indent=indent)
    return json.dumps(val, sort_keys=True)


def x_dumps__mutmut_2(val, indent):
    if indent:
        return json.dumps(val, sort_keys=None, indent=indent)
    return json.dumps(val, sort_keys=True)


def x_dumps__mutmut_3(val, indent):
    if indent:
        return json.dumps(val, sort_keys=True, indent=None)
    return json.dumps(val, sort_keys=True)


def x_dumps__mutmut_4(val, indent):
    if indent:
        return json.dumps(sort_keys=True, indent=indent)
    return json.dumps(val, sort_keys=True)


def x_dumps__mutmut_5(val, indent):
    if indent:
        return json.dumps(val, indent=indent)
    return json.dumps(val, sort_keys=True)


def x_dumps__mutmut_6(val, indent):
    if indent:
        return json.dumps(val, sort_keys=True, )
    return json.dumps(val, sort_keys=True)


def x_dumps__mutmut_7(val, indent):
    if indent:
        return json.dumps(val, sort_keys=False, indent=indent)
    return json.dumps(val, sort_keys=True)


def x_dumps__mutmut_8(val, indent):
    if indent:
        return json.dumps(val, sort_keys=True, indent=indent)
    return json.dumps(None, sort_keys=True)


def x_dumps__mutmut_9(val, indent):
    if indent:
        return json.dumps(val, sort_keys=True, indent=indent)
    return json.dumps(val, sort_keys=None)


def x_dumps__mutmut_10(val, indent):
    if indent:
        return json.dumps(val, sort_keys=True, indent=indent)
    return json.dumps(sort_keys=True)


def x_dumps__mutmut_11(val, indent):
    if indent:
        return json.dumps(val, sort_keys=True, indent=indent)
    return json.dumps(val, )


def x_dumps__mutmut_12(val, indent):
    if indent:
        return json.dumps(val, sort_keys=True, indent=indent)
    return json.dumps(val, sort_keys=False)

x_dumps__mutmut_mutants : ClassVar[MutantDict] = {
'x_dumps__mutmut_1': x_dumps__mutmut_1, 
    'x_dumps__mutmut_2': x_dumps__mutmut_2, 
    'x_dumps__mutmut_3': x_dumps__mutmut_3, 
    'x_dumps__mutmut_4': x_dumps__mutmut_4, 
    'x_dumps__mutmut_5': x_dumps__mutmut_5, 
    'x_dumps__mutmut_6': x_dumps__mutmut_6, 
    'x_dumps__mutmut_7': x_dumps__mutmut_7, 
    'x_dumps__mutmut_8': x_dumps__mutmut_8, 
    'x_dumps__mutmut_9': x_dumps__mutmut_9, 
    'x_dumps__mutmut_10': x_dumps__mutmut_10, 
    'x_dumps__mutmut_11': x_dumps__mutmut_11, 
    'x_dumps__mutmut_12': x_dumps__mutmut_12
}

def dumps(*args, **kwargs):
    result = _mutmut_trampoline(x_dumps__mutmut_orig, x_dumps__mutmut_mutants, args, kwargs)
    return result 

dumps.__signature__ = _mutmut_signature(x_dumps__mutmut_orig)
x_dumps__mutmut_orig.__name__ = 'x_dumps'


def x_get_profile_json__mutmut_orig(indent=False):
    if indent:
        indent = 2
    else:
        indent = 0

    data_dict = get_profile()
    return dumps(data_dict, indent)


def x_get_profile_json__mutmut_1(indent=True):
    if indent:
        indent = 2
    else:
        indent = 0

    data_dict = get_profile()
    return dumps(data_dict, indent)


def x_get_profile_json__mutmut_2(indent=False):
    if indent:
        indent = None
    else:
        indent = 0

    data_dict = get_profile()
    return dumps(data_dict, indent)


def x_get_profile_json__mutmut_3(indent=False):
    if indent:
        indent = 3
    else:
        indent = 0

    data_dict = get_profile()
    return dumps(data_dict, indent)


def x_get_profile_json__mutmut_4(indent=False):
    if indent:
        indent = 2
    else:
        indent = None

    data_dict = get_profile()
    return dumps(data_dict, indent)


def x_get_profile_json__mutmut_5(indent=False):
    if indent:
        indent = 2
    else:
        indent = 1

    data_dict = get_profile()
    return dumps(data_dict, indent)


def x_get_profile_json__mutmut_6(indent=False):
    if indent:
        indent = 2
    else:
        indent = 0

    data_dict = None
    return dumps(data_dict, indent)


def x_get_profile_json__mutmut_7(indent=False):
    if indent:
        indent = 2
    else:
        indent = 0

    data_dict = get_profile()
    return dumps(None, indent)


def x_get_profile_json__mutmut_8(indent=False):
    if indent:
        indent = 2
    else:
        indent = 0

    data_dict = get_profile()
    return dumps(data_dict, None)


def x_get_profile_json__mutmut_9(indent=False):
    if indent:
        indent = 2
    else:
        indent = 0

    data_dict = get_profile()
    return dumps(indent)


def x_get_profile_json__mutmut_10(indent=False):
    if indent:
        indent = 2
    else:
        indent = 0

    data_dict = get_profile()
    return dumps(data_dict, )

x_get_profile_json__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_profile_json__mutmut_1': x_get_profile_json__mutmut_1, 
    'x_get_profile_json__mutmut_2': x_get_profile_json__mutmut_2, 
    'x_get_profile_json__mutmut_3': x_get_profile_json__mutmut_3, 
    'x_get_profile_json__mutmut_4': x_get_profile_json__mutmut_4, 
    'x_get_profile_json__mutmut_5': x_get_profile_json__mutmut_5, 
    'x_get_profile_json__mutmut_6': x_get_profile_json__mutmut_6, 
    'x_get_profile_json__mutmut_7': x_get_profile_json__mutmut_7, 
    'x_get_profile_json__mutmut_8': x_get_profile_json__mutmut_8, 
    'x_get_profile_json__mutmut_9': x_get_profile_json__mutmut_9, 
    'x_get_profile_json__mutmut_10': x_get_profile_json__mutmut_10
}

def get_profile_json(*args, **kwargs):
    result = _mutmut_trampoline(x_get_profile_json__mutmut_orig, x_get_profile_json__mutmut_mutants, args, kwargs)
    return result 

get_profile_json.__signature__ = _mutmut_signature(x_get_profile_json__mutmut_orig)
x_get_profile_json__mutmut_orig.__name__ = 'x_get_profile_json'


def x_main__mutmut_orig():
    print(get_profile_json(indent=True))


def x_main__mutmut_1():
    print(None)


def x_main__mutmut_2():
    print(get_profile_json(indent=None))


def x_main__mutmut_3():
    print(get_profile_json(indent=False))

x_main__mutmut_mutants : ClassVar[MutantDict] = {
'x_main__mutmut_1': x_main__mutmut_1, 
    'x_main__mutmut_2': x_main__mutmut_2, 
    'x_main__mutmut_3': x_main__mutmut_3
}

def main(*args, **kwargs):
    result = _mutmut_trampoline(x_main__mutmut_orig, x_main__mutmut_mutants, args, kwargs)
    return result 

main.__signature__ = _mutmut_signature(x_main__mutmut_orig)
x_main__mutmut_orig.__name__ = 'x_main'

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_orig(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_1(args, sep='XX XX', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_2(args, sep=' ', style=None):
    if style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_3(args, sep=' ', style=None):
    if not style:
        if sys.platform != 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_4(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'XXwin32XX':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_5(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'WIN32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_6(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = None
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_7(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'XXcmdXX'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_8(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'CMD'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_9(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = None

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_10(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'XXshXX'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_11(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'SH'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_12(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style != 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_13(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'XXshXX':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_14(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'SH':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_15(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(None, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_16(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=None)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_17(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_18(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, )
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_19(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style != 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_20(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'XXcmdXX':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_21(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'CMD':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_22(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(None, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_23(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=None)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_24(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_25(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, )

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_26(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError(None)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_27(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("style expected one of 'cmd' or 'sh', not %r" / style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_28(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("XXstyle expected one of 'cmd' or 'sh', not %rXX" % style)

#############################################
#  The shell escaping copied in from strutils
#############################################


def x__escape_shell_args__mutmut_29(args, sep=' ', style=None):
    if not style:
        if sys.platform == 'win32':
            style = 'cmd'
        else:
            style = 'sh'

    if style == 'sh':
        return _args2sh(args, sep=sep)
    elif style == 'cmd':
        return _args2cmd(args, sep=sep)

    raise ValueError("STYLE EXPECTED ONE OF 'CMD' OR 'SH', NOT %R" % style)

x__escape_shell_args__mutmut_mutants : ClassVar[MutantDict] = {
'x__escape_shell_args__mutmut_1': x__escape_shell_args__mutmut_1, 
    'x__escape_shell_args__mutmut_2': x__escape_shell_args__mutmut_2, 
    'x__escape_shell_args__mutmut_3': x__escape_shell_args__mutmut_3, 
    'x__escape_shell_args__mutmut_4': x__escape_shell_args__mutmut_4, 
    'x__escape_shell_args__mutmut_5': x__escape_shell_args__mutmut_5, 
    'x__escape_shell_args__mutmut_6': x__escape_shell_args__mutmut_6, 
    'x__escape_shell_args__mutmut_7': x__escape_shell_args__mutmut_7, 
    'x__escape_shell_args__mutmut_8': x__escape_shell_args__mutmut_8, 
    'x__escape_shell_args__mutmut_9': x__escape_shell_args__mutmut_9, 
    'x__escape_shell_args__mutmut_10': x__escape_shell_args__mutmut_10, 
    'x__escape_shell_args__mutmut_11': x__escape_shell_args__mutmut_11, 
    'x__escape_shell_args__mutmut_12': x__escape_shell_args__mutmut_12, 
    'x__escape_shell_args__mutmut_13': x__escape_shell_args__mutmut_13, 
    'x__escape_shell_args__mutmut_14': x__escape_shell_args__mutmut_14, 
    'x__escape_shell_args__mutmut_15': x__escape_shell_args__mutmut_15, 
    'x__escape_shell_args__mutmut_16': x__escape_shell_args__mutmut_16, 
    'x__escape_shell_args__mutmut_17': x__escape_shell_args__mutmut_17, 
    'x__escape_shell_args__mutmut_18': x__escape_shell_args__mutmut_18, 
    'x__escape_shell_args__mutmut_19': x__escape_shell_args__mutmut_19, 
    'x__escape_shell_args__mutmut_20': x__escape_shell_args__mutmut_20, 
    'x__escape_shell_args__mutmut_21': x__escape_shell_args__mutmut_21, 
    'x__escape_shell_args__mutmut_22': x__escape_shell_args__mutmut_22, 
    'x__escape_shell_args__mutmut_23': x__escape_shell_args__mutmut_23, 
    'x__escape_shell_args__mutmut_24': x__escape_shell_args__mutmut_24, 
    'x__escape_shell_args__mutmut_25': x__escape_shell_args__mutmut_25, 
    'x__escape_shell_args__mutmut_26': x__escape_shell_args__mutmut_26, 
    'x__escape_shell_args__mutmut_27': x__escape_shell_args__mutmut_27, 
    'x__escape_shell_args__mutmut_28': x__escape_shell_args__mutmut_28, 
    'x__escape_shell_args__mutmut_29': x__escape_shell_args__mutmut_29
}

def _escape_shell_args(*args, **kwargs):
    result = _mutmut_trampoline(x__escape_shell_args__mutmut_orig, x__escape_shell_args__mutmut_mutants, args, kwargs)
    return result 

_escape_shell_args.__signature__ = _mutmut_signature(x__escape_shell_args__mutmut_orig)
x__escape_shell_args__mutmut_orig.__name__ = 'x__escape_shell_args'


_find_sh_unsafe = re.compile(r'[^a-zA-Z0-9_@%+=:,./-]').search


def x__args2sh__mutmut_orig(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_1(args, sep='XX XX'):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_2(args, sep=' '):
    # see strutils
    ret_list = None

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_3(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_4(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append(None)
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_5(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("XX''XX")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_6(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            break
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_7(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(None) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_8(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is not None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_9(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(None)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_10(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            break
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_11(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append(None)

    return ' '.join(ret_list)


def x__args2sh__mutmut_12(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") - "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_13(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" - arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_14(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("XX'XX" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_15(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace(None, "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_16(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", None) + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_17(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_18(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", ) + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_19(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("XX'XX", "'\"'\"'") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_20(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "XX'\"'\"'XX") + "'")

    return ' '.join(ret_list)


def x__args2sh__mutmut_21(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "XX'XX")

    return ' '.join(ret_list)


def x__args2sh__mutmut_22(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return ' '.join(None)


def x__args2sh__mutmut_23(args, sep=' '):
    # see strutils
    ret_list = []

    for arg in args:
        if not arg:
            ret_list.append("''")
            continue
        if _find_sh_unsafe(arg) is None:
            ret_list.append(arg)
            continue
        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        ret_list.append("'" + arg.replace("'", "'\"'\"'") + "'")

    return 'XX XX'.join(ret_list)

x__args2sh__mutmut_mutants : ClassVar[MutantDict] = {
'x__args2sh__mutmut_1': x__args2sh__mutmut_1, 
    'x__args2sh__mutmut_2': x__args2sh__mutmut_2, 
    'x__args2sh__mutmut_3': x__args2sh__mutmut_3, 
    'x__args2sh__mutmut_4': x__args2sh__mutmut_4, 
    'x__args2sh__mutmut_5': x__args2sh__mutmut_5, 
    'x__args2sh__mutmut_6': x__args2sh__mutmut_6, 
    'x__args2sh__mutmut_7': x__args2sh__mutmut_7, 
    'x__args2sh__mutmut_8': x__args2sh__mutmut_8, 
    'x__args2sh__mutmut_9': x__args2sh__mutmut_9, 
    'x__args2sh__mutmut_10': x__args2sh__mutmut_10, 
    'x__args2sh__mutmut_11': x__args2sh__mutmut_11, 
    'x__args2sh__mutmut_12': x__args2sh__mutmut_12, 
    'x__args2sh__mutmut_13': x__args2sh__mutmut_13, 
    'x__args2sh__mutmut_14': x__args2sh__mutmut_14, 
    'x__args2sh__mutmut_15': x__args2sh__mutmut_15, 
    'x__args2sh__mutmut_16': x__args2sh__mutmut_16, 
    'x__args2sh__mutmut_17': x__args2sh__mutmut_17, 
    'x__args2sh__mutmut_18': x__args2sh__mutmut_18, 
    'x__args2sh__mutmut_19': x__args2sh__mutmut_19, 
    'x__args2sh__mutmut_20': x__args2sh__mutmut_20, 
    'x__args2sh__mutmut_21': x__args2sh__mutmut_21, 
    'x__args2sh__mutmut_22': x__args2sh__mutmut_22, 
    'x__args2sh__mutmut_23': x__args2sh__mutmut_23
}

def _args2sh(*args, **kwargs):
    result = _mutmut_trampoline(x__args2sh__mutmut_orig, x__args2sh__mutmut_mutants, args, kwargs)
    return result 

_args2sh.__signature__ = _mutmut_signature(x__args2sh__mutmut_orig)
x__args2sh__mutmut_orig.__name__ = 'x__args2sh'


def x__args2cmd__mutmut_orig(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_1(args, sep='XX XX'):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_2(args, sep=' '):
    # see strutils
    result = None
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_3(args, sep=' '):
    # see strutils
    result = []
    needquote = None
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_4(args, sep=' '):
    # see strutils
    result = []
    needquote = True
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_5(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = None

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_6(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(None)

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_7(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append('XX XX')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_8(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = None
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_9(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) and not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_10(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) and ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_11(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = ("XX XX" in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_12(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " not in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_13(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("XX\tXX" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_14(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" not in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_15(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_16(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append(None)

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_17(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('XX"XX')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_18(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c != '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_19(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == 'XX\\XX':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_20(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(None)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_21(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c != '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_22(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == 'XX"XX':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_23(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append(None)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_24(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf) / 2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_25(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' / len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_26(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('XX\\XX' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_27(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*3)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_28(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = None
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_29(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append(None)
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_30(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('XX\\"XX')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_31(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(None)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_32(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = None
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_33(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(None)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_34(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(None)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_35(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(None)
            result.append('"')

    return ''.join(result)


def x__args2cmd__mutmut_36(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append(None)

    return ''.join(result)


def x__args2cmd__mutmut_37(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('XX"XX')

    return ''.join(result)


def x__args2cmd__mutmut_38(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(None)


def x__args2cmd__mutmut_39(args, sep=' '):
    # see strutils
    result = []
    needquote = False
    for arg in args:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return 'XXXX'.join(result)

x__args2cmd__mutmut_mutants : ClassVar[MutantDict] = {
'x__args2cmd__mutmut_1': x__args2cmd__mutmut_1, 
    'x__args2cmd__mutmut_2': x__args2cmd__mutmut_2, 
    'x__args2cmd__mutmut_3': x__args2cmd__mutmut_3, 
    'x__args2cmd__mutmut_4': x__args2cmd__mutmut_4, 
    'x__args2cmd__mutmut_5': x__args2cmd__mutmut_5, 
    'x__args2cmd__mutmut_6': x__args2cmd__mutmut_6, 
    'x__args2cmd__mutmut_7': x__args2cmd__mutmut_7, 
    'x__args2cmd__mutmut_8': x__args2cmd__mutmut_8, 
    'x__args2cmd__mutmut_9': x__args2cmd__mutmut_9, 
    'x__args2cmd__mutmut_10': x__args2cmd__mutmut_10, 
    'x__args2cmd__mutmut_11': x__args2cmd__mutmut_11, 
    'x__args2cmd__mutmut_12': x__args2cmd__mutmut_12, 
    'x__args2cmd__mutmut_13': x__args2cmd__mutmut_13, 
    'x__args2cmd__mutmut_14': x__args2cmd__mutmut_14, 
    'x__args2cmd__mutmut_15': x__args2cmd__mutmut_15, 
    'x__args2cmd__mutmut_16': x__args2cmd__mutmut_16, 
    'x__args2cmd__mutmut_17': x__args2cmd__mutmut_17, 
    'x__args2cmd__mutmut_18': x__args2cmd__mutmut_18, 
    'x__args2cmd__mutmut_19': x__args2cmd__mutmut_19, 
    'x__args2cmd__mutmut_20': x__args2cmd__mutmut_20, 
    'x__args2cmd__mutmut_21': x__args2cmd__mutmut_21, 
    'x__args2cmd__mutmut_22': x__args2cmd__mutmut_22, 
    'x__args2cmd__mutmut_23': x__args2cmd__mutmut_23, 
    'x__args2cmd__mutmut_24': x__args2cmd__mutmut_24, 
    'x__args2cmd__mutmut_25': x__args2cmd__mutmut_25, 
    'x__args2cmd__mutmut_26': x__args2cmd__mutmut_26, 
    'x__args2cmd__mutmut_27': x__args2cmd__mutmut_27, 
    'x__args2cmd__mutmut_28': x__args2cmd__mutmut_28, 
    'x__args2cmd__mutmut_29': x__args2cmd__mutmut_29, 
    'x__args2cmd__mutmut_30': x__args2cmd__mutmut_30, 
    'x__args2cmd__mutmut_31': x__args2cmd__mutmut_31, 
    'x__args2cmd__mutmut_32': x__args2cmd__mutmut_32, 
    'x__args2cmd__mutmut_33': x__args2cmd__mutmut_33, 
    'x__args2cmd__mutmut_34': x__args2cmd__mutmut_34, 
    'x__args2cmd__mutmut_35': x__args2cmd__mutmut_35, 
    'x__args2cmd__mutmut_36': x__args2cmd__mutmut_36, 
    'x__args2cmd__mutmut_37': x__args2cmd__mutmut_37, 
    'x__args2cmd__mutmut_38': x__args2cmd__mutmut_38, 
    'x__args2cmd__mutmut_39': x__args2cmd__mutmut_39
}

def _args2cmd(*args, **kwargs):
    result = _mutmut_trampoline(x__args2cmd__mutmut_orig, x__args2cmd__mutmut_mutants, args, kwargs)
    return result 

_args2cmd.__signature__ = _mutmut_signature(x__args2cmd__mutmut_orig)
x__args2cmd__mutmut_orig.__name__ = 'x__args2cmd'


############################
#  End shell escaping code
############################

if __name__ == '__main__':
    main()


"""

ecoutils protocol version history
---------------------------------

The version is ECO_VERSION module-level constant, and _eco_version key
in the dictionary returned from ecoutils.get_profile().

1.1.0 - (boltons version 24.0.0+) Drop Python <=3.6 compat
1.0.1 - (boltons version 16.3.2+) Remove uuid dependency and add HAVE_URANDOM
1.0.0 - (boltons version 16.3.0-16.3.1) Initial release

"""
