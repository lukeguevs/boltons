# Copyright (c) 2013, Mahmoud Hashemi
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#    * Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials provided
#      with the distribution.
#
#    * The names of the contributors may not be used to endorse or
#      promote products derived from this software without specific
#      prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

""":mod:`urlutils` is a module dedicated to one of software's most
versatile, well-aged, and beloved data structures: the URL, also known
as the `Uniform Resource Locator`_.

Among other things, this module is a full reimplementation of URLs,
without any reliance on the :mod:`urlparse` or :mod:`urllib` standard
library modules. The centerpiece and top-level interface of urlutils
is the :class:`URL` type. Also featured is the :func:`find_all_links`
convenience function. Some low-level functions and constants are also
below.

The implementations in this module are based heavily on `RFC 3986`_ and
`RFC 3987`_, and incorporates details from several other RFCs and `W3C
documents`_.

.. _Uniform Resource Locator: https://en.wikipedia.org/wiki/Uniform_Resource_Locator
.. _RFC 3986: https://tools.ietf.org/html/rfc3986
.. _RFC 3987: https://tools.ietf.org/html/rfc3987
.. _W3C documents: https://www.w3.org/TR/uri-clarification/

"""

import re
import socket
import string
from unicodedata import normalize

# The unreserved URI characters (per RFC 3986 Section 2.3)
_UNRESERVED_CHARS = frozenset('~-._0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                              'abcdefghijklmnopqrstuvwxyz')

# URL parsing regex (based on RFC 3986 Appendix B, with modifications)
_URL_RE = re.compile(r'^((?P<scheme>[^:/?#]+):)?'
                     r'((?P<_netloc_sep>//)(?P<authority>[^/?#]*))?'
                     r'(?P<path>[^?#]*)'
                     r'(\?(?P<query>[^#]*))?'
                     r'(#(?P<fragment>.*))?')


_HEX_CHAR_MAP = {(a + b).encode('ascii'):
                 chr(int(a + b, 16)).encode('charmap')
                 for a in string.hexdigits for b in string.hexdigits}
_ASCII_RE = re.compile('([\x00-\x7f]+)')


# This port list painstakingly curated by hand searching through
# https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
# and
# https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml
SCHEME_PORT_MAP = {'acap': 674, 'afp': 548, 'dict': 2628, 'dns': 53,
                   'file': None, 'ftp': 21, 'git': 9418, 'gopher': 70,
                   'http': 80, 'https': 443, 'imap': 143, 'ipp': 631,
                   'ipps': 631, 'irc': 194, 'ircs': 6697, 'ldap': 389,
                   'ldaps': 636, 'mms': 1755, 'msrp': 2855, 'msrps': None,
                   'mtqp': 1038, 'nfs': 111, 'nntp': 119, 'nntps': 563,
                   'pop': 110, 'prospero': 1525, 'redis': 6379, 'rsync': 873,
                   'rtsp': 554, 'rtsps': 322, 'rtspu': 5005, 'sftp': 22,
                   'smb': 445, 'snmp': 161, 'ssh': 22, 'steam': None,
                   'svn': 3690, 'telnet': 23, 'ventrilo': 3784, 'vnc': 5900,
                   'wais': 210, 'ws': 80, 'wss': 443, 'xmpp': None}

# This list of schemes that don't use authorities is also from the link above.
NO_NETLOC_SCHEMES = {'urn', 'about', 'bitcoin', 'blob', 'data', 'geo',
                         'magnet', 'mailto', 'news', 'pkcs11',
                         'sip', 'sips', 'tel'}
# As of Mar 11, 2017, there were 44 netloc schemes, and 13 non-netloc

# RFC 3986 section 2.2, Reserved Characters
_GEN_DELIMS = frozenset(':/?#[]@')
_SUB_DELIMS = frozenset("!$&'()*+,;=")
_ALL_DELIMS = _GEN_DELIMS | _SUB_DELIMS

_USERINFO_SAFE = _UNRESERVED_CHARS | _SUB_DELIMS
_USERINFO_DELIMS = _ALL_DELIMS - _USERINFO_SAFE
_PATH_SAFE = _UNRESERVED_CHARS | _SUB_DELIMS | set(':@')
_PATH_DELIMS = _ALL_DELIMS - _PATH_SAFE
_FRAGMENT_SAFE = _UNRESERVED_CHARS | _PATH_SAFE | set('/?')
_FRAGMENT_DELIMS = _ALL_DELIMS - _FRAGMENT_SAFE
_QUERY_SAFE = _UNRESERVED_CHARS | _FRAGMENT_SAFE - set('&=+')
_QUERY_DELIMS = _ALL_DELIMS - _QUERY_SAFE
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result


class URLParseError(ValueError):
    """Exception inheriting from :exc:`ValueError`, raised when failing to
    parse a URL. Mostly raised on invalid ports and IPv6 addresses.
    """
    pass


DEFAULT_ENCODING = 'utf8'


def x_to_unicode__mutmut_orig(obj):
    try:
        return str(obj)
    except UnicodeDecodeError:
        return str(obj, encoding=DEFAULT_ENCODING)


def x_to_unicode__mutmut_1(obj):
    try:
        return str(None)
    except UnicodeDecodeError:
        return str(obj, encoding=DEFAULT_ENCODING)


def x_to_unicode__mutmut_2(obj):
    try:
        return str(obj)
    except UnicodeDecodeError:
        return str(None, encoding=DEFAULT_ENCODING)


def x_to_unicode__mutmut_3(obj):
    try:
        return str(obj)
    except UnicodeDecodeError:
        return str(obj, encoding=None)


def x_to_unicode__mutmut_4(obj):
    try:
        return str(obj)
    except UnicodeDecodeError:
        return str(encoding=DEFAULT_ENCODING)


def x_to_unicode__mutmut_5(obj):
    try:
        return str(obj)
    except UnicodeDecodeError:
        return str(obj, )

x_to_unicode__mutmut_mutants : ClassVar[MutantDict] = {
'x_to_unicode__mutmut_1': x_to_unicode__mutmut_1, 
    'x_to_unicode__mutmut_2': x_to_unicode__mutmut_2, 
    'x_to_unicode__mutmut_3': x_to_unicode__mutmut_3, 
    'x_to_unicode__mutmut_4': x_to_unicode__mutmut_4, 
    'x_to_unicode__mutmut_5': x_to_unicode__mutmut_5
}

def to_unicode(*args, **kwargs):
    result = _mutmut_trampoline(x_to_unicode__mutmut_orig, x_to_unicode__mutmut_mutants, args, kwargs)
    return result 

to_unicode.__signature__ = _mutmut_signature(x_to_unicode__mutmut_orig)
x_to_unicode__mutmut_orig.__name__ = 'x_to_unicode'


# regex from gruber via tornado
# doesn't support ipv6
# doesn't support mailto (netloc-less schemes)
_FIND_ALL_URL_RE = re.compile(r"""\b((?:([\w-]+):(/{1,3})|www[.])(?:(?:(?:[^\s&()<>]|&amp;|&quot;)*(?:[^!"#$%'()*+,.:;<=>?@\[\]^`{|}~\s]))|(?:\((?:[^\s&()]|&amp;|&quot;)*\)))+)""")


def x_find_all_links__mutmut_orig(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_1(text, with_text=True, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_2(text, with_text=False, default_scheme='XXhttpsXX', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_3(text, with_text=False, default_scheme='HTTPS', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_4(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = None
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_5(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(None)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_6(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_7(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 1, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_8(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = None
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_9(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = None

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_10(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret or isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_11(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] = t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_12(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] -= t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_13(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[+1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_14(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-2] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_15(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(None)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_16(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(None):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_17(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = None
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_18(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(None), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_19(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(2), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_20(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(None)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_21(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(2)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_22(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start or with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_23(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end <= start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_24(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(None)
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_25(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = None
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_26(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = None
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_27(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(None)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_28(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(1)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_29(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = None
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_30(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(None)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_31(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_32(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = None
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_33(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(None)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_34(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' - cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_35(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme - '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_36(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + 'XX://XX' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_37(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(None)
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_38(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    break
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_39(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes or cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_40(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_41(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(None)
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_42(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(None)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_43(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(None)

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_44(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = None
        if tail:
            _add_text(tail)

    return ret


def x_find_all_links__mutmut_45(text, with_text=False, default_scheme='https', schemes=()):
    """This function uses heuristics to searches plain text for strings
    that look like URLs, returning a :class:`list` of :class:`URL`
    objects. It supports limiting the accepted schemes, and returning
    interleaved text as well.

    >>> find_all_links('Visit https://boltons.rtfd.org!')
    [URL(u'https://boltons.rtfd.org')]
    >>> find_all_links('Visit https://boltons.rtfd.org!', with_text=True)
    [u'Visit ', URL(u'https://boltons.rtfd.org'), u'!']

    Args:
       text (str): The text to search.

       with_text (bool): Whether or not to interleave plaintext blocks
          with the returned URL objects. Having all tokens can be
          useful for transforming the text, e.g., replacing links with
          HTML equivalents. Defaults to ``False``.

       default_scheme (str): Many URLs are written without the scheme
          component. This function can match a reasonable subset of
          those, provided *default_scheme* is set to a string. Set to
          ``False`` to disable matching scheme-less URLs. Defaults to
          ``'https'``.

       schemes (list): A list of strings that a URL's scheme must
          match in order to be included in the results. Defaults to
          empty, which matches all schemes.

    .. note:: Currently this function does not support finding IPv6
      addresses or URLs with netloc-less schemes, like mailto.

    """
    text = to_unicode(text)
    prev_end, start, end = 0, None, None
    ret = []
    _add = ret.append

    def _add_text(t):
        if ret and isinstance(ret[-1], str):
            ret[-1] += t
        else:
            _add(t)

    for match in _FIND_ALL_URL_RE.finditer(text):
        start, end = match.start(1), match.end(1)
        if prev_end < start and with_text:
            _add(text[prev_end:start])
        prev_end = end
        try:
            cur_url_text = match.group(0)
            cur_url = URL(cur_url_text)
            if not cur_url.scheme:
                if default_scheme:
                    cur_url = URL(default_scheme + '://' + cur_url_text)
                else:
                    _add_text(text[start:end])
                    continue
            if schemes and cur_url.scheme not in schemes:
                _add_text(text[start:end])
            else:
                _add(cur_url)
        except URLParseError:
            # currently this should only be hit with broken port
            # strings. the regex above doesn't support ipv6 addresses
            if with_text:
                _add_text(text[start:end])

    if with_text:
        tail = text[prev_end:]
        if tail:
            _add_text(None)

    return ret

x_find_all_links__mutmut_mutants : ClassVar[MutantDict] = {
'x_find_all_links__mutmut_1': x_find_all_links__mutmut_1, 
    'x_find_all_links__mutmut_2': x_find_all_links__mutmut_2, 
    'x_find_all_links__mutmut_3': x_find_all_links__mutmut_3, 
    'x_find_all_links__mutmut_4': x_find_all_links__mutmut_4, 
    'x_find_all_links__mutmut_5': x_find_all_links__mutmut_5, 
    'x_find_all_links__mutmut_6': x_find_all_links__mutmut_6, 
    'x_find_all_links__mutmut_7': x_find_all_links__mutmut_7, 
    'x_find_all_links__mutmut_8': x_find_all_links__mutmut_8, 
    'x_find_all_links__mutmut_9': x_find_all_links__mutmut_9, 
    'x_find_all_links__mutmut_10': x_find_all_links__mutmut_10, 
    'x_find_all_links__mutmut_11': x_find_all_links__mutmut_11, 
    'x_find_all_links__mutmut_12': x_find_all_links__mutmut_12, 
    'x_find_all_links__mutmut_13': x_find_all_links__mutmut_13, 
    'x_find_all_links__mutmut_14': x_find_all_links__mutmut_14, 
    'x_find_all_links__mutmut_15': x_find_all_links__mutmut_15, 
    'x_find_all_links__mutmut_16': x_find_all_links__mutmut_16, 
    'x_find_all_links__mutmut_17': x_find_all_links__mutmut_17, 
    'x_find_all_links__mutmut_18': x_find_all_links__mutmut_18, 
    'x_find_all_links__mutmut_19': x_find_all_links__mutmut_19, 
    'x_find_all_links__mutmut_20': x_find_all_links__mutmut_20, 
    'x_find_all_links__mutmut_21': x_find_all_links__mutmut_21, 
    'x_find_all_links__mutmut_22': x_find_all_links__mutmut_22, 
    'x_find_all_links__mutmut_23': x_find_all_links__mutmut_23, 
    'x_find_all_links__mutmut_24': x_find_all_links__mutmut_24, 
    'x_find_all_links__mutmut_25': x_find_all_links__mutmut_25, 
    'x_find_all_links__mutmut_26': x_find_all_links__mutmut_26, 
    'x_find_all_links__mutmut_27': x_find_all_links__mutmut_27, 
    'x_find_all_links__mutmut_28': x_find_all_links__mutmut_28, 
    'x_find_all_links__mutmut_29': x_find_all_links__mutmut_29, 
    'x_find_all_links__mutmut_30': x_find_all_links__mutmut_30, 
    'x_find_all_links__mutmut_31': x_find_all_links__mutmut_31, 
    'x_find_all_links__mutmut_32': x_find_all_links__mutmut_32, 
    'x_find_all_links__mutmut_33': x_find_all_links__mutmut_33, 
    'x_find_all_links__mutmut_34': x_find_all_links__mutmut_34, 
    'x_find_all_links__mutmut_35': x_find_all_links__mutmut_35, 
    'x_find_all_links__mutmut_36': x_find_all_links__mutmut_36, 
    'x_find_all_links__mutmut_37': x_find_all_links__mutmut_37, 
    'x_find_all_links__mutmut_38': x_find_all_links__mutmut_38, 
    'x_find_all_links__mutmut_39': x_find_all_links__mutmut_39, 
    'x_find_all_links__mutmut_40': x_find_all_links__mutmut_40, 
    'x_find_all_links__mutmut_41': x_find_all_links__mutmut_41, 
    'x_find_all_links__mutmut_42': x_find_all_links__mutmut_42, 
    'x_find_all_links__mutmut_43': x_find_all_links__mutmut_43, 
    'x_find_all_links__mutmut_44': x_find_all_links__mutmut_44, 
    'x_find_all_links__mutmut_45': x_find_all_links__mutmut_45
}

def find_all_links(*args, **kwargs):
    result = _mutmut_trampoline(x_find_all_links__mutmut_orig, x_find_all_links__mutmut_mutants, args, kwargs)
    return result 

find_all_links.__signature__ = _mutmut_signature(x_find_all_links__mutmut_orig)
x_find_all_links__mutmut_orig.__name__ = 'x_find_all_links'


def x__make_quote_map__mutmut_orig(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), range(256)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_1(safe_chars):
    ret = None
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), range(256)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_2(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(None, range(256)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_3(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), None):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_4(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_5(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), ):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_6(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(None), range(256)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_7(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(257), range(256)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_8(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), range(None)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_9(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), range(257)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_10(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), range(256)):
        c = None
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_11(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), range(256)):
        c = chr(None)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_12(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), range(256)):
        c = chr(v)
        if c not in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_13(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), range(256)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = None
        else:
            ret[c] = ret[v] = f'%{i:02X}'
    return ret


def x__make_quote_map__mutmut_14(safe_chars):
    ret = {}
    # v is included in the dict for py3 mostly, because bytestrings
    # are iterables of ints, of course!
    for i, v in zip(range(256), range(256)):
        c = chr(v)
        if c in safe_chars:
            ret[c] = ret[v] = c
        else:
            ret[c] = ret[v] = None
    return ret

x__make_quote_map__mutmut_mutants : ClassVar[MutantDict] = {
'x__make_quote_map__mutmut_1': x__make_quote_map__mutmut_1, 
    'x__make_quote_map__mutmut_2': x__make_quote_map__mutmut_2, 
    'x__make_quote_map__mutmut_3': x__make_quote_map__mutmut_3, 
    'x__make_quote_map__mutmut_4': x__make_quote_map__mutmut_4, 
    'x__make_quote_map__mutmut_5': x__make_quote_map__mutmut_5, 
    'x__make_quote_map__mutmut_6': x__make_quote_map__mutmut_6, 
    'x__make_quote_map__mutmut_7': x__make_quote_map__mutmut_7, 
    'x__make_quote_map__mutmut_8': x__make_quote_map__mutmut_8, 
    'x__make_quote_map__mutmut_9': x__make_quote_map__mutmut_9, 
    'x__make_quote_map__mutmut_10': x__make_quote_map__mutmut_10, 
    'x__make_quote_map__mutmut_11': x__make_quote_map__mutmut_11, 
    'x__make_quote_map__mutmut_12': x__make_quote_map__mutmut_12, 
    'x__make_quote_map__mutmut_13': x__make_quote_map__mutmut_13, 
    'x__make_quote_map__mutmut_14': x__make_quote_map__mutmut_14
}

def _make_quote_map(*args, **kwargs):
    result = _mutmut_trampoline(x__make_quote_map__mutmut_orig, x__make_quote_map__mutmut_mutants, args, kwargs)
    return result 

_make_quote_map.__signature__ = _mutmut_signature(x__make_quote_map__mutmut_orig)
x__make_quote_map__mutmut_orig.__name__ = 'x__make_quote_map'


_USERINFO_PART_QUOTE_MAP = _make_quote_map(_USERINFO_SAFE)
_PATH_PART_QUOTE_MAP = _make_quote_map(_PATH_SAFE)
_QUERY_PART_QUOTE_MAP = _make_quote_map(_QUERY_SAFE)
_FRAGMENT_QUOTE_MAP = _make_quote_map(_FRAGMENT_SAFE)


def x_quote_path_part__mutmut_orig(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_1(text, full_quote=False):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_2(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = None
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_3(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode(None)
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_4(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize(None, to_unicode(text)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_5(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', None).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_6(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize(to_unicode(text)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_7(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', ).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_8(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('XXNFCXX', to_unicode(text)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_9(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('nfc', to_unicode(text)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_10(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(None)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_11(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('XXutf8XX')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_12(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('UTF8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_13(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join(None)
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_14(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return 'XXXX'.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_15(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join(None)


def x_quote_path_part__mutmut_16(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return 'XXXX'.join([_PATH_PART_QUOTE_MAP[t] if t in _PATH_DELIMS else t
                     for t in text])


def x_quote_path_part__mutmut_17(text, full_quote=True):
    """
    Percent-encode a single segment of a URL path.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_PATH_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_PATH_PART_QUOTE_MAP[t] if t not in _PATH_DELIMS else t
                     for t in text])

x_quote_path_part__mutmut_mutants : ClassVar[MutantDict] = {
'x_quote_path_part__mutmut_1': x_quote_path_part__mutmut_1, 
    'x_quote_path_part__mutmut_2': x_quote_path_part__mutmut_2, 
    'x_quote_path_part__mutmut_3': x_quote_path_part__mutmut_3, 
    'x_quote_path_part__mutmut_4': x_quote_path_part__mutmut_4, 
    'x_quote_path_part__mutmut_5': x_quote_path_part__mutmut_5, 
    'x_quote_path_part__mutmut_6': x_quote_path_part__mutmut_6, 
    'x_quote_path_part__mutmut_7': x_quote_path_part__mutmut_7, 
    'x_quote_path_part__mutmut_8': x_quote_path_part__mutmut_8, 
    'x_quote_path_part__mutmut_9': x_quote_path_part__mutmut_9, 
    'x_quote_path_part__mutmut_10': x_quote_path_part__mutmut_10, 
    'x_quote_path_part__mutmut_11': x_quote_path_part__mutmut_11, 
    'x_quote_path_part__mutmut_12': x_quote_path_part__mutmut_12, 
    'x_quote_path_part__mutmut_13': x_quote_path_part__mutmut_13, 
    'x_quote_path_part__mutmut_14': x_quote_path_part__mutmut_14, 
    'x_quote_path_part__mutmut_15': x_quote_path_part__mutmut_15, 
    'x_quote_path_part__mutmut_16': x_quote_path_part__mutmut_16, 
    'x_quote_path_part__mutmut_17': x_quote_path_part__mutmut_17
}

def quote_path_part(*args, **kwargs):
    result = _mutmut_trampoline(x_quote_path_part__mutmut_orig, x_quote_path_part__mutmut_mutants, args, kwargs)
    return result 

quote_path_part.__signature__ = _mutmut_signature(x_quote_path_part__mutmut_orig)
x_quote_path_part__mutmut_orig.__name__ = 'x_quote_path_part'


def x_quote_query_part__mutmut_orig(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_1(text, full_quote=False):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_2(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = None
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_3(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode(None)
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_4(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize(None, to_unicode(text)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_5(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', None).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_6(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize(to_unicode(text)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_7(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', ).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_8(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('XXNFCXX', to_unicode(text)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_9(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('nfc', to_unicode(text)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_10(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(None)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_11(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('XXutf8XX')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_12(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('UTF8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_13(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join(None)
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_14(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return 'XXXX'.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_15(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join(None)


def x_quote_query_part__mutmut_16(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return 'XXXX'.join([_QUERY_PART_QUOTE_MAP[t] if t in _QUERY_DELIMS else t
                     for t in text])


def x_quote_query_part__mutmut_17(text, full_quote=True):
    """
    Percent-encode a single query string key or value.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_QUERY_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_QUERY_PART_QUOTE_MAP[t] if t not in _QUERY_DELIMS else t
                     for t in text])

x_quote_query_part__mutmut_mutants : ClassVar[MutantDict] = {
'x_quote_query_part__mutmut_1': x_quote_query_part__mutmut_1, 
    'x_quote_query_part__mutmut_2': x_quote_query_part__mutmut_2, 
    'x_quote_query_part__mutmut_3': x_quote_query_part__mutmut_3, 
    'x_quote_query_part__mutmut_4': x_quote_query_part__mutmut_4, 
    'x_quote_query_part__mutmut_5': x_quote_query_part__mutmut_5, 
    'x_quote_query_part__mutmut_6': x_quote_query_part__mutmut_6, 
    'x_quote_query_part__mutmut_7': x_quote_query_part__mutmut_7, 
    'x_quote_query_part__mutmut_8': x_quote_query_part__mutmut_8, 
    'x_quote_query_part__mutmut_9': x_quote_query_part__mutmut_9, 
    'x_quote_query_part__mutmut_10': x_quote_query_part__mutmut_10, 
    'x_quote_query_part__mutmut_11': x_quote_query_part__mutmut_11, 
    'x_quote_query_part__mutmut_12': x_quote_query_part__mutmut_12, 
    'x_quote_query_part__mutmut_13': x_quote_query_part__mutmut_13, 
    'x_quote_query_part__mutmut_14': x_quote_query_part__mutmut_14, 
    'x_quote_query_part__mutmut_15': x_quote_query_part__mutmut_15, 
    'x_quote_query_part__mutmut_16': x_quote_query_part__mutmut_16, 
    'x_quote_query_part__mutmut_17': x_quote_query_part__mutmut_17
}

def quote_query_part(*args, **kwargs):
    result = _mutmut_trampoline(x_quote_query_part__mutmut_orig, x_quote_query_part__mutmut_mutants, args, kwargs)
    return result 

quote_query_part.__signature__ = _mutmut_signature(x_quote_query_part__mutmut_orig)
x_quote_query_part__mutmut_orig.__name__ = 'x_quote_query_part'


def x_quote_fragment_part__mutmut_orig(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_1(text, full_quote=False):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_2(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = None
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_3(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode(None)
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_4(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize(None, to_unicode(text)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_5(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', None).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_6(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize(to_unicode(text)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_7(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', ).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_8(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('XXNFCXX', to_unicode(text)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_9(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('nfc', to_unicode(text)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_10(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(None)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_11(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('XXutf8XX')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_12(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('UTF8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_13(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join(None)
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_14(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return 'XXXX'.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_15(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join(None)


def x_quote_fragment_part__mutmut_16(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return 'XXXX'.join([_FRAGMENT_QUOTE_MAP[t] if t in _FRAGMENT_DELIMS else t
                     for t in text])


def x_quote_fragment_part__mutmut_17(text, full_quote=True):
    """Quote the fragment part of the URL. Fragments don't have
    subdelimiters, so the whole URL fragment can be passed.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_FRAGMENT_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_FRAGMENT_QUOTE_MAP[t] if t not in _FRAGMENT_DELIMS else t
                     for t in text])

x_quote_fragment_part__mutmut_mutants : ClassVar[MutantDict] = {
'x_quote_fragment_part__mutmut_1': x_quote_fragment_part__mutmut_1, 
    'x_quote_fragment_part__mutmut_2': x_quote_fragment_part__mutmut_2, 
    'x_quote_fragment_part__mutmut_3': x_quote_fragment_part__mutmut_3, 
    'x_quote_fragment_part__mutmut_4': x_quote_fragment_part__mutmut_4, 
    'x_quote_fragment_part__mutmut_5': x_quote_fragment_part__mutmut_5, 
    'x_quote_fragment_part__mutmut_6': x_quote_fragment_part__mutmut_6, 
    'x_quote_fragment_part__mutmut_7': x_quote_fragment_part__mutmut_7, 
    'x_quote_fragment_part__mutmut_8': x_quote_fragment_part__mutmut_8, 
    'x_quote_fragment_part__mutmut_9': x_quote_fragment_part__mutmut_9, 
    'x_quote_fragment_part__mutmut_10': x_quote_fragment_part__mutmut_10, 
    'x_quote_fragment_part__mutmut_11': x_quote_fragment_part__mutmut_11, 
    'x_quote_fragment_part__mutmut_12': x_quote_fragment_part__mutmut_12, 
    'x_quote_fragment_part__mutmut_13': x_quote_fragment_part__mutmut_13, 
    'x_quote_fragment_part__mutmut_14': x_quote_fragment_part__mutmut_14, 
    'x_quote_fragment_part__mutmut_15': x_quote_fragment_part__mutmut_15, 
    'x_quote_fragment_part__mutmut_16': x_quote_fragment_part__mutmut_16, 
    'x_quote_fragment_part__mutmut_17': x_quote_fragment_part__mutmut_17
}

def quote_fragment_part(*args, **kwargs):
    result = _mutmut_trampoline(x_quote_fragment_part__mutmut_orig, x_quote_fragment_part__mutmut_mutants, args, kwargs)
    return result 

quote_fragment_part.__signature__ = _mutmut_signature(x_quote_fragment_part__mutmut_orig)
x_quote_fragment_part__mutmut_orig.__name__ = 'x_quote_fragment_part'


def x_quote_userinfo_part__mutmut_orig(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_1(text, full_quote=False):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_2(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = None
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_3(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode(None)
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_4(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize(None, to_unicode(text)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_5(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', None).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_6(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize(to_unicode(text)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_7(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', ).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_8(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('XXNFCXX', to_unicode(text)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_9(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('nfc', to_unicode(text)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_10(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(None)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_11(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('XXutf8XX')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_12(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('UTF8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_13(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join(None)
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_14(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return 'XXXX'.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_15(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join(None)


def x_quote_userinfo_part__mutmut_16(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return 'XXXX'.join([_USERINFO_PART_QUOTE_MAP[t] if t in _USERINFO_DELIMS
                     else t for t in text])


def x_quote_userinfo_part__mutmut_17(text, full_quote=True):
    """Quote special characters in either the username or password
    section of the URL. Note that userinfo in URLs is considered
    deprecated in many circles (especially browsers), and support for
    percent-encoded userinfo can be spotty.
    """
    if full_quote:
        bytestr = normalize('NFC', to_unicode(text)).encode('utf8')
        return ''.join([_USERINFO_PART_QUOTE_MAP[b] for b in bytestr])
    return ''.join([_USERINFO_PART_QUOTE_MAP[t] if t not in _USERINFO_DELIMS
                     else t for t in text])

x_quote_userinfo_part__mutmut_mutants : ClassVar[MutantDict] = {
'x_quote_userinfo_part__mutmut_1': x_quote_userinfo_part__mutmut_1, 
    'x_quote_userinfo_part__mutmut_2': x_quote_userinfo_part__mutmut_2, 
    'x_quote_userinfo_part__mutmut_3': x_quote_userinfo_part__mutmut_3, 
    'x_quote_userinfo_part__mutmut_4': x_quote_userinfo_part__mutmut_4, 
    'x_quote_userinfo_part__mutmut_5': x_quote_userinfo_part__mutmut_5, 
    'x_quote_userinfo_part__mutmut_6': x_quote_userinfo_part__mutmut_6, 
    'x_quote_userinfo_part__mutmut_7': x_quote_userinfo_part__mutmut_7, 
    'x_quote_userinfo_part__mutmut_8': x_quote_userinfo_part__mutmut_8, 
    'x_quote_userinfo_part__mutmut_9': x_quote_userinfo_part__mutmut_9, 
    'x_quote_userinfo_part__mutmut_10': x_quote_userinfo_part__mutmut_10, 
    'x_quote_userinfo_part__mutmut_11': x_quote_userinfo_part__mutmut_11, 
    'x_quote_userinfo_part__mutmut_12': x_quote_userinfo_part__mutmut_12, 
    'x_quote_userinfo_part__mutmut_13': x_quote_userinfo_part__mutmut_13, 
    'x_quote_userinfo_part__mutmut_14': x_quote_userinfo_part__mutmut_14, 
    'x_quote_userinfo_part__mutmut_15': x_quote_userinfo_part__mutmut_15, 
    'x_quote_userinfo_part__mutmut_16': x_quote_userinfo_part__mutmut_16, 
    'x_quote_userinfo_part__mutmut_17': x_quote_userinfo_part__mutmut_17
}

def quote_userinfo_part(*args, **kwargs):
    result = _mutmut_trampoline(x_quote_userinfo_part__mutmut_orig, x_quote_userinfo_part__mutmut_mutants, args, kwargs)
    return result 

quote_userinfo_part.__signature__ = _mutmut_signature(x_quote_userinfo_part__mutmut_orig)
x_quote_userinfo_part__mutmut_orig.__name__ = 'x_quote_userinfo_part'


def x_unquote__mutmut_orig(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_1(string, encoding='XXutf-8XX', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_2(string, encoding='UTF-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_3(string, encoding='utf-8', errors='XXreplaceXX'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_4(string, encoding='utf-8', errors='REPLACE'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_5(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if 'XX%XX' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_6(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_7(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is not None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_8(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = None
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_9(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'XXutf-8XX'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_10(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'UTF-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_11(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is not None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_12(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = None
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_13(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'XXreplaceXX'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_14(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'REPLACE'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_15(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = None
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_16(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(None)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_17(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = None
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_18(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[1]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_19(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = None
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_20(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(None, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_21(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, None, 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_22(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), None):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_23(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_24(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_25(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), ):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_26(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(2, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_27(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 3):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_28(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(None)
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_29(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(None, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_30(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, None))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_31(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_32(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, ))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_33(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(None).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(res)


def x_unquote__mutmut_34(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(None)
    return ''.join(res)


def x_unquote__mutmut_35(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i - 1])
    return ''.join(res)


def x_unquote__mutmut_36(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 2])
    return ''.join(res)


def x_unquote__mutmut_37(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return ''.join(None)


def x_unquote__mutmut_38(string, encoding='utf-8', errors='replace'):
    """Percent-decode a string, by replacing %xx escapes with their
    single-character equivalent. The optional *encoding* and *errors*
    parameters specify how to decode percent-encoded sequences into
    Unicode characters, as accepted by the :meth:`bytes.decode()` method.  By
    default, percent-encoded sequences are decoded with UTF-8, and
    invalid sequences are replaced by a placeholder character.

    >>> unquote(u'abc%20def')
    u'abc def'
    """
    if '%' not in string:
        string.split
        return string
    if encoding is None:
        encoding = 'utf-8'
    if errors is None:
        errors = 'replace'
    bits = _ASCII_RE.split(string)
    res = [bits[0]]
    append = res.append
    for i in range(1, len(bits), 2):
        append(unquote_to_bytes(bits[i]).decode(encoding, errors))
        append(bits[i + 1])
    return 'XXXX'.join(res)

x_unquote__mutmut_mutants : ClassVar[MutantDict] = {
'x_unquote__mutmut_1': x_unquote__mutmut_1, 
    'x_unquote__mutmut_2': x_unquote__mutmut_2, 
    'x_unquote__mutmut_3': x_unquote__mutmut_3, 
    'x_unquote__mutmut_4': x_unquote__mutmut_4, 
    'x_unquote__mutmut_5': x_unquote__mutmut_5, 
    'x_unquote__mutmut_6': x_unquote__mutmut_6, 
    'x_unquote__mutmut_7': x_unquote__mutmut_7, 
    'x_unquote__mutmut_8': x_unquote__mutmut_8, 
    'x_unquote__mutmut_9': x_unquote__mutmut_9, 
    'x_unquote__mutmut_10': x_unquote__mutmut_10, 
    'x_unquote__mutmut_11': x_unquote__mutmut_11, 
    'x_unquote__mutmut_12': x_unquote__mutmut_12, 
    'x_unquote__mutmut_13': x_unquote__mutmut_13, 
    'x_unquote__mutmut_14': x_unquote__mutmut_14, 
    'x_unquote__mutmut_15': x_unquote__mutmut_15, 
    'x_unquote__mutmut_16': x_unquote__mutmut_16, 
    'x_unquote__mutmut_17': x_unquote__mutmut_17, 
    'x_unquote__mutmut_18': x_unquote__mutmut_18, 
    'x_unquote__mutmut_19': x_unquote__mutmut_19, 
    'x_unquote__mutmut_20': x_unquote__mutmut_20, 
    'x_unquote__mutmut_21': x_unquote__mutmut_21, 
    'x_unquote__mutmut_22': x_unquote__mutmut_22, 
    'x_unquote__mutmut_23': x_unquote__mutmut_23, 
    'x_unquote__mutmut_24': x_unquote__mutmut_24, 
    'x_unquote__mutmut_25': x_unquote__mutmut_25, 
    'x_unquote__mutmut_26': x_unquote__mutmut_26, 
    'x_unquote__mutmut_27': x_unquote__mutmut_27, 
    'x_unquote__mutmut_28': x_unquote__mutmut_28, 
    'x_unquote__mutmut_29': x_unquote__mutmut_29, 
    'x_unquote__mutmut_30': x_unquote__mutmut_30, 
    'x_unquote__mutmut_31': x_unquote__mutmut_31, 
    'x_unquote__mutmut_32': x_unquote__mutmut_32, 
    'x_unquote__mutmut_33': x_unquote__mutmut_33, 
    'x_unquote__mutmut_34': x_unquote__mutmut_34, 
    'x_unquote__mutmut_35': x_unquote__mutmut_35, 
    'x_unquote__mutmut_36': x_unquote__mutmut_36, 
    'x_unquote__mutmut_37': x_unquote__mutmut_37, 
    'x_unquote__mutmut_38': x_unquote__mutmut_38
}

def unquote(*args, **kwargs):
    result = _mutmut_trampoline(x_unquote__mutmut_orig, x_unquote__mutmut_mutants, args, kwargs)
    return result 

unquote.__signature__ = _mutmut_signature(x_unquote__mutmut_orig)
x_unquote__mutmut_orig.__name__ = 'x_unquote'


def x_unquote_to_bytes__mutmut_orig(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_1(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_2(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b'XXXX'
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_3(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_4(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_5(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = None
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_6(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode(None)
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_7(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('XXutf-8XX')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_8(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('UTF-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_9(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = None
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_10(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(None)
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_11(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'XX%XX')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_12(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_13(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_14(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) != 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_15(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 2:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_16(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = None
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_17(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[1]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_18(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = None

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_19(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[2:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_20(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(None)
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_21(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:3]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_22(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(None)
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_23(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[3:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_24(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(None)
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_25(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'XX%XX')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_26(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_27(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_28(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(None)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_29(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(None)


def x_unquote_to_bytes__mutmut_30(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b'XXXX'.join(res)


def x_unquote_to_bytes__mutmut_31(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)


def x_unquote_to_bytes__mutmut_32(string):
    """unquote_to_bytes('abc%20def') -> b'abc def'."""
    # Note: strings are encoded as UTF-8. This is only an issue if it contains
    # unescaped non-ASCII characters, which URIs should not.
    if not string:
        # Is it a string-like object?
        string.split
        return b''
    if isinstance(string, str):
        string = string.encode('utf-8')
    bits = string.split(b'%')
    if len(bits) == 1:
        return string
    # import pdb;pdb.set_trace()
    res = [bits[0]]
    append = res.append

    for item in bits[1:]:
        try:
            append(_HEX_CHAR_MAP[item[:2]])
            append(item[2:])
        except KeyError:
            append(b'%')
            append(item)
    return b''.join(res)

x_unquote_to_bytes__mutmut_mutants : ClassVar[MutantDict] = {
'x_unquote_to_bytes__mutmut_1': x_unquote_to_bytes__mutmut_1, 
    'x_unquote_to_bytes__mutmut_2': x_unquote_to_bytes__mutmut_2, 
    'x_unquote_to_bytes__mutmut_3': x_unquote_to_bytes__mutmut_3, 
    'x_unquote_to_bytes__mutmut_4': x_unquote_to_bytes__mutmut_4, 
    'x_unquote_to_bytes__mutmut_5': x_unquote_to_bytes__mutmut_5, 
    'x_unquote_to_bytes__mutmut_6': x_unquote_to_bytes__mutmut_6, 
    'x_unquote_to_bytes__mutmut_7': x_unquote_to_bytes__mutmut_7, 
    'x_unquote_to_bytes__mutmut_8': x_unquote_to_bytes__mutmut_8, 
    'x_unquote_to_bytes__mutmut_9': x_unquote_to_bytes__mutmut_9, 
    'x_unquote_to_bytes__mutmut_10': x_unquote_to_bytes__mutmut_10, 
    'x_unquote_to_bytes__mutmut_11': x_unquote_to_bytes__mutmut_11, 
    'x_unquote_to_bytes__mutmut_12': x_unquote_to_bytes__mutmut_12, 
    'x_unquote_to_bytes__mutmut_13': x_unquote_to_bytes__mutmut_13, 
    'x_unquote_to_bytes__mutmut_14': x_unquote_to_bytes__mutmut_14, 
    'x_unquote_to_bytes__mutmut_15': x_unquote_to_bytes__mutmut_15, 
    'x_unquote_to_bytes__mutmut_16': x_unquote_to_bytes__mutmut_16, 
    'x_unquote_to_bytes__mutmut_17': x_unquote_to_bytes__mutmut_17, 
    'x_unquote_to_bytes__mutmut_18': x_unquote_to_bytes__mutmut_18, 
    'x_unquote_to_bytes__mutmut_19': x_unquote_to_bytes__mutmut_19, 
    'x_unquote_to_bytes__mutmut_20': x_unquote_to_bytes__mutmut_20, 
    'x_unquote_to_bytes__mutmut_21': x_unquote_to_bytes__mutmut_21, 
    'x_unquote_to_bytes__mutmut_22': x_unquote_to_bytes__mutmut_22, 
    'x_unquote_to_bytes__mutmut_23': x_unquote_to_bytes__mutmut_23, 
    'x_unquote_to_bytes__mutmut_24': x_unquote_to_bytes__mutmut_24, 
    'x_unquote_to_bytes__mutmut_25': x_unquote_to_bytes__mutmut_25, 
    'x_unquote_to_bytes__mutmut_26': x_unquote_to_bytes__mutmut_26, 
    'x_unquote_to_bytes__mutmut_27': x_unquote_to_bytes__mutmut_27, 
    'x_unquote_to_bytes__mutmut_28': x_unquote_to_bytes__mutmut_28, 
    'x_unquote_to_bytes__mutmut_29': x_unquote_to_bytes__mutmut_29, 
    'x_unquote_to_bytes__mutmut_30': x_unquote_to_bytes__mutmut_30, 
    'x_unquote_to_bytes__mutmut_31': x_unquote_to_bytes__mutmut_31, 
    'x_unquote_to_bytes__mutmut_32': x_unquote_to_bytes__mutmut_32
}

def unquote_to_bytes(*args, **kwargs):
    result = _mutmut_trampoline(x_unquote_to_bytes__mutmut_orig, x_unquote_to_bytes__mutmut_mutants, args, kwargs)
    return result 

unquote_to_bytes.__signature__ = _mutmut_signature(x_unquote_to_bytes__mutmut_orig)
x_unquote_to_bytes__mutmut_orig.__name__ = 'x_unquote_to_bytes'


def x_register_scheme__mutmut_orig(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_1(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = None
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_2(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.upper()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_3(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_4(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = None
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_5(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(None)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_6(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError(None)

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_7(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r' / (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_8(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('XXdefault_port expected integer or None, not %rXX'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_9(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or none, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_10(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('DEFAULT_PORT EXPECTED INTEGER OR NONE, NOT %R'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_11(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is not True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_12(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is False:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_13(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = None
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_14(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is not False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_15(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is True:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_16(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_17(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError(None)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_18(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' / default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_19(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('XXunexpected default port while specifyingXX'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_20(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('UNEXPECTED DEFAULT PORT WHILE SPECIFYING'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_21(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             'XX non-netloc scheme: %rXX' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_22(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' NON-NETLOC SCHEME: %R' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_23(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(None)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_24(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is None:
        raise ValueError('uses_netloc expected True, False, or None')

    return


def x_register_scheme__mutmut_25(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError(None)

    return


def x_register_scheme__mutmut_26(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('XXuses_netloc expected True, False, or NoneXX')

    return


def x_register_scheme__mutmut_27(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('uses_netloc expected true, false, or none')

    return


def x_register_scheme__mutmut_28(text, uses_netloc=None, default_port=None):
    """Registers new scheme information, resulting in correct port and
    slash behavior from the URL object. There are dozens of standard
    schemes preregistered, so this function is mostly meant for
    proprietary internal customizations or stopgaps on missing
    standards information. If a scheme seems to be missing, please
    `file an issue`_!

    Args:
        text (str): Text representing the scheme.
           (the 'http' in 'http://hatnote.com')
        uses_netloc (bool): Does the scheme support specifying a
           network host? For instance, "http" does, "mailto" does not.
        default_port (int): The default port, if any, for netloc-using
           schemes.

    .. _file an issue: https://github.com/mahmoud/boltons/issues
    """
    text = text.lower()
    if default_port is not None:
        try:
            default_port = int(default_port)
        except ValueError:
            raise ValueError('default_port expected integer or None, not %r'
                             % (default_port,))

    if uses_netloc is True:
        SCHEME_PORT_MAP[text] = default_port
    elif uses_netloc is False:
        if default_port is not None:
            raise ValueError('unexpected default port while specifying'
                             ' non-netloc scheme: %r' % default_port)
        NO_NETLOC_SCHEMES.add(text)
    elif uses_netloc is not None:
        raise ValueError('USES_NETLOC EXPECTED TRUE, FALSE, OR NONE')

    return

x_register_scheme__mutmut_mutants : ClassVar[MutantDict] = {
'x_register_scheme__mutmut_1': x_register_scheme__mutmut_1, 
    'x_register_scheme__mutmut_2': x_register_scheme__mutmut_2, 
    'x_register_scheme__mutmut_3': x_register_scheme__mutmut_3, 
    'x_register_scheme__mutmut_4': x_register_scheme__mutmut_4, 
    'x_register_scheme__mutmut_5': x_register_scheme__mutmut_5, 
    'x_register_scheme__mutmut_6': x_register_scheme__mutmut_6, 
    'x_register_scheme__mutmut_7': x_register_scheme__mutmut_7, 
    'x_register_scheme__mutmut_8': x_register_scheme__mutmut_8, 
    'x_register_scheme__mutmut_9': x_register_scheme__mutmut_9, 
    'x_register_scheme__mutmut_10': x_register_scheme__mutmut_10, 
    'x_register_scheme__mutmut_11': x_register_scheme__mutmut_11, 
    'x_register_scheme__mutmut_12': x_register_scheme__mutmut_12, 
    'x_register_scheme__mutmut_13': x_register_scheme__mutmut_13, 
    'x_register_scheme__mutmut_14': x_register_scheme__mutmut_14, 
    'x_register_scheme__mutmut_15': x_register_scheme__mutmut_15, 
    'x_register_scheme__mutmut_16': x_register_scheme__mutmut_16, 
    'x_register_scheme__mutmut_17': x_register_scheme__mutmut_17, 
    'x_register_scheme__mutmut_18': x_register_scheme__mutmut_18, 
    'x_register_scheme__mutmut_19': x_register_scheme__mutmut_19, 
    'x_register_scheme__mutmut_20': x_register_scheme__mutmut_20, 
    'x_register_scheme__mutmut_21': x_register_scheme__mutmut_21, 
    'x_register_scheme__mutmut_22': x_register_scheme__mutmut_22, 
    'x_register_scheme__mutmut_23': x_register_scheme__mutmut_23, 
    'x_register_scheme__mutmut_24': x_register_scheme__mutmut_24, 
    'x_register_scheme__mutmut_25': x_register_scheme__mutmut_25, 
    'x_register_scheme__mutmut_26': x_register_scheme__mutmut_26, 
    'x_register_scheme__mutmut_27': x_register_scheme__mutmut_27, 
    'x_register_scheme__mutmut_28': x_register_scheme__mutmut_28
}

def register_scheme(*args, **kwargs):
    result = _mutmut_trampoline(x_register_scheme__mutmut_orig, x_register_scheme__mutmut_mutants, args, kwargs)
    return result 

register_scheme.__signature__ = _mutmut_signature(x_register_scheme__mutmut_orig)
x_register_scheme__mutmut_orig.__name__ = 'x_register_scheme'


def x_resolve_path_parts__mutmut_orig(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_1(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = None

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_2(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part != '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_3(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == 'XX.XX':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_4(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part != '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_5(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == 'XX..XX':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_6(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret or (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_7(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 and ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_8(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) >= 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_9(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 2 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_10(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[1]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_11(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(None)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_12(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(None) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_13(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[+1:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_14(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-2:]) in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_15(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) not in (['.'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_16(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['XX.XX'], ['..']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_17(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['XX..XX']):
        ret.append('')

    return ret


def x_resolve_path_parts__mutmut_18(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append(None)

    return ret


def x_resolve_path_parts__mutmut_19(path_parts):
    """Normalize the URL path by resolving segments of '.' and '..',
    resulting in a dot-free path.  See RFC 3986 section 5.2.4, Remove
    Dot Segments.
    """
    # TODO: what to do with multiple slashes
    ret = []

    for part in path_parts:
        if part == '.':
            pass
        elif part == '..':
            if ret and (len(ret) > 1 or ret[0]):  # prevent unrooting
                ret.pop()
        else:
            ret.append(part)

    if list(path_parts[-1:]) in (['.'], ['..']):
        ret.append('XXXX')

    return ret

x_resolve_path_parts__mutmut_mutants : ClassVar[MutantDict] = {
'x_resolve_path_parts__mutmut_1': x_resolve_path_parts__mutmut_1, 
    'x_resolve_path_parts__mutmut_2': x_resolve_path_parts__mutmut_2, 
    'x_resolve_path_parts__mutmut_3': x_resolve_path_parts__mutmut_3, 
    'x_resolve_path_parts__mutmut_4': x_resolve_path_parts__mutmut_4, 
    'x_resolve_path_parts__mutmut_5': x_resolve_path_parts__mutmut_5, 
    'x_resolve_path_parts__mutmut_6': x_resolve_path_parts__mutmut_6, 
    'x_resolve_path_parts__mutmut_7': x_resolve_path_parts__mutmut_7, 
    'x_resolve_path_parts__mutmut_8': x_resolve_path_parts__mutmut_8, 
    'x_resolve_path_parts__mutmut_9': x_resolve_path_parts__mutmut_9, 
    'x_resolve_path_parts__mutmut_10': x_resolve_path_parts__mutmut_10, 
    'x_resolve_path_parts__mutmut_11': x_resolve_path_parts__mutmut_11, 
    'x_resolve_path_parts__mutmut_12': x_resolve_path_parts__mutmut_12, 
    'x_resolve_path_parts__mutmut_13': x_resolve_path_parts__mutmut_13, 
    'x_resolve_path_parts__mutmut_14': x_resolve_path_parts__mutmut_14, 
    'x_resolve_path_parts__mutmut_15': x_resolve_path_parts__mutmut_15, 
    'x_resolve_path_parts__mutmut_16': x_resolve_path_parts__mutmut_16, 
    'x_resolve_path_parts__mutmut_17': x_resolve_path_parts__mutmut_17, 
    'x_resolve_path_parts__mutmut_18': x_resolve_path_parts__mutmut_18, 
    'x_resolve_path_parts__mutmut_19': x_resolve_path_parts__mutmut_19
}

def resolve_path_parts(*args, **kwargs):
    result = _mutmut_trampoline(x_resolve_path_parts__mutmut_orig, x_resolve_path_parts__mutmut_mutants, args, kwargs)
    return result 

resolve_path_parts.__signature__ = _mutmut_signature(x_resolve_path_parts__mutmut_orig)
x_resolve_path_parts__mutmut_orig.__name__ = 'x_resolve_path_parts'


class cachedproperty:
    """The ``cachedproperty`` is used similar to :class:`property`, except
    that the wrapped method is only called once. This is commonly used
    to implement lazy attributes.

    After the property has been accessed, the value is stored on the
    instance itself, using the same name as the cachedproperty. This
    allows the cache to be cleared with :func:`delattr`, or through
    manipulating the object's ``__dict__``.
    """
    def xǁcachedpropertyǁ__init____mutmut_orig(self, func):
        self.__doc__ = getattr(func, '__doc__')
        self.func = func
    def xǁcachedpropertyǁ__init____mutmut_1(self, func):
        self.__doc__ = None
        self.func = func
    def xǁcachedpropertyǁ__init____mutmut_2(self, func):
        self.__doc__ = getattr(None, '__doc__')
        self.func = func
    def xǁcachedpropertyǁ__init____mutmut_3(self, func):
        self.__doc__ = getattr(func, None)
        self.func = func
    def xǁcachedpropertyǁ__init____mutmut_4(self, func):
        self.__doc__ = getattr('__doc__')
        self.func = func
    def xǁcachedpropertyǁ__init____mutmut_5(self, func):
        self.__doc__ = getattr(func, )
        self.func = func
    def xǁcachedpropertyǁ__init____mutmut_6(self, func):
        self.__doc__ = getattr(func, 'XX__doc__XX')
        self.func = func
    def xǁcachedpropertyǁ__init____mutmut_7(self, func):
        self.__doc__ = getattr(func, '__DOC__')
        self.func = func
    def xǁcachedpropertyǁ__init____mutmut_8(self, func):
        self.__doc__ = getattr(func, '__doc__')
        self.func = None
    
    xǁcachedpropertyǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁcachedpropertyǁ__init____mutmut_1': xǁcachedpropertyǁ__init____mutmut_1, 
        'xǁcachedpropertyǁ__init____mutmut_2': xǁcachedpropertyǁ__init____mutmut_2, 
        'xǁcachedpropertyǁ__init____mutmut_3': xǁcachedpropertyǁ__init____mutmut_3, 
        'xǁcachedpropertyǁ__init____mutmut_4': xǁcachedpropertyǁ__init____mutmut_4, 
        'xǁcachedpropertyǁ__init____mutmut_5': xǁcachedpropertyǁ__init____mutmut_5, 
        'xǁcachedpropertyǁ__init____mutmut_6': xǁcachedpropertyǁ__init____mutmut_6, 
        'xǁcachedpropertyǁ__init____mutmut_7': xǁcachedpropertyǁ__init____mutmut_7, 
        'xǁcachedpropertyǁ__init____mutmut_8': xǁcachedpropertyǁ__init____mutmut_8
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁcachedpropertyǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁcachedpropertyǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁcachedpropertyǁ__init____mutmut_orig)
    xǁcachedpropertyǁ__init____mutmut_orig.__name__ = 'xǁcachedpropertyǁ__init__'

    def xǁcachedpropertyǁ__get____mutmut_orig(self, obj, objtype=None):
        if obj is None:
            return self
        value = obj.__dict__[self.func.__name__] = self.func(obj)
        return value

    def xǁcachedpropertyǁ__get____mutmut_1(self, obj, objtype=None):
        if obj is not None:
            return self
        value = obj.__dict__[self.func.__name__] = self.func(obj)
        return value

    def xǁcachedpropertyǁ__get____mutmut_2(self, obj, objtype=None):
        if obj is None:
            return self
        value = obj.__dict__[self.func.__name__] = None
        return value

    def xǁcachedpropertyǁ__get____mutmut_3(self, obj, objtype=None):
        if obj is None:
            return self
        value = obj.__dict__[self.func.__name__] = self.func(None)
        return value
    
    xǁcachedpropertyǁ__get____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁcachedpropertyǁ__get____mutmut_1': xǁcachedpropertyǁ__get____mutmut_1, 
        'xǁcachedpropertyǁ__get____mutmut_2': xǁcachedpropertyǁ__get____mutmut_2, 
        'xǁcachedpropertyǁ__get____mutmut_3': xǁcachedpropertyǁ__get____mutmut_3
    }
    
    def __get__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁcachedpropertyǁ__get____mutmut_orig"), object.__getattribute__(self, "xǁcachedpropertyǁ__get____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __get__.__signature__ = _mutmut_signature(xǁcachedpropertyǁ__get____mutmut_orig)
    xǁcachedpropertyǁ__get____mutmut_orig.__name__ = 'xǁcachedpropertyǁ__get__'

    def xǁcachedpropertyǁ__repr____mutmut_orig(self):
        cn = self.__class__.__name__
        return f'<{cn} func={self.func}>'

    def xǁcachedpropertyǁ__repr____mutmut_1(self):
        cn = None
        return f'<{cn} func={self.func}>'
    
    xǁcachedpropertyǁ__repr____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁcachedpropertyǁ__repr____mutmut_1': xǁcachedpropertyǁ__repr____mutmut_1
    }
    
    def __repr__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁcachedpropertyǁ__repr____mutmut_orig"), object.__getattribute__(self, "xǁcachedpropertyǁ__repr____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __repr__.__signature__ = _mutmut_signature(xǁcachedpropertyǁ__repr____mutmut_orig)
    xǁcachedpropertyǁ__repr____mutmut_orig.__name__ = 'xǁcachedpropertyǁ__repr__'


class URL:
    r"""The URL is one of the most ubiquitous data structures in the
    virtual and physical landscape. From blogs to billboards, URLs are
    so common, that it's easy to overlook their complexity and
    power.

    There are 8 parts of a URL, each with its own semantics and
    special characters:

      * :attr:`~URL.scheme`
      * :attr:`~URL.username`
      * :attr:`~URL.password`
      * :attr:`~URL.host`
      * :attr:`~URL.port`
      * :attr:`~URL.path`
      * :attr:`~URL.query_params` (query string parameters)
      * :attr:`~URL.fragment`

    Each is exposed as an attribute on the URL object. RFC 3986 offers
    this brief structural summary of the main URL components::

        foo://user:pass@example.com:8042/over/there?name=ferret#nose
        \_/   \_______/ \_________/ \__/\_________/ \_________/ \__/
         |        |          |        |      |           |        |
       scheme  userinfo     host     port   path       query   fragment

    And here's how that example can be manipulated with the URL type:

    >>> url = URL('foo://example.com:8042/over/there?name=ferret#nose')
    >>> print(url.host)
    example.com
    >>> print(url.get_authority())
    example.com:8042
    >>> print(url.qp['name'])  # qp is a synonym for query_params
    ferret

    URL's approach to encoding is that inputs are decoded as much as
    possible, and data remains in this decoded state until re-encoded
    using the :meth:`~URL.to_text()` method. In this way, it's similar
    to Python's current approach of encouraging immediate decoding of
    bytes to text.

    Note that URL instances are mutable objects. If an immutable
    representation of the URL is desired, the string from
    :meth:`~URL.to_text()` may be used. For an immutable, but
    almost-as-featureful, URL object, check out the `hyperlink
    package`_.

    .. _hyperlink package: https://github.com/mahmoud/hyperlink

    """

    # public attributes (for comparison, see __eq__):
    _cmp_attrs = ('scheme', 'uses_netloc', 'username', 'password',
                  'family', 'host', 'port', 'path', 'query_params', 'fragment')

    def xǁURLǁ__init____mutmut_orig(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_1(self, url='XXXX'):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_2(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = None
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_3(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = None  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_4(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = None
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_5(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(None)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_6(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError(None)
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_7(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)' / (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_8(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('XXexpected text or %s-encoded bytes.XX'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_9(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('EXPECTED TEXT OR %S-ENCODED BYTES.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_10(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        'XX try decoding the url bytes andXX'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_11(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' TRY DECODING THE URL BYTES AND'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_12(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        'XX passing the result. (got: %s)XX'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_13(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' PASSING THE RESULT. (GOT: %S)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_14(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = None

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_15(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(None)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_16(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = None
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_17(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = 'XXXX'
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_18(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = None
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_19(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] and _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_20(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['XXschemeXX'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_21(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['SCHEME'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_22(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = None
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_23(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] and _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_24(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['XX_netloc_sepXX'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_25(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_NETLOC_SEP'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_26(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = None
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_27(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(None)
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_28(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['XXusernameXX'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_29(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['USERNAME'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_30(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if 'XX%XX' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_31(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' not in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_32(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] and _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_33(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['XXusernameXX'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_34(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['USERNAME'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_35(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] and _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_36(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['XXusernameXX'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_37(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['USERNAME'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_38(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = None
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_39(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(None)
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_40(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['XXpasswordXX'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_41(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['PASSWORD'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_42(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if 'XX%XX' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_43(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' not in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_44(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] and _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_45(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['XXpasswordXX'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_46(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['PASSWORD'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_47(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] and _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_48(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['XXpasswordXX'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_49(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['PASSWORD'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_50(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = None

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_51(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['XXfamilyXX']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_52(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['FAMILY']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_53(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_54(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['XXhostXX']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_55(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['HOST']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_56(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = None
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_57(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = None
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_58(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode(None)
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_59(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['XXhostXX'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_60(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['HOST'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_61(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("XXasciiXX")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_62(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ASCII")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_63(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = None  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_64(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['XXhostXX']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_65(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['HOST']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_66(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = None

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_67(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode(None)

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_68(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("XXidnaXX")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_69(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("IDNA")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_70(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = None
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_71(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['XXportXX']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_72(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['PORT']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_73(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = None
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_74(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple(None)
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_75(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(None) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_76(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if 'XX%XX' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_77(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' not in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_78(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split(None)])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_79(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] and _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_80(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['XXpathXX'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_81(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['PATH'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_82(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('XX/XX')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_83(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = None
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_84(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] and _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_85(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['XXqueryXX'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_86(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['QUERY'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_87(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = None
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_88(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(None)
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_89(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['XXfragmentXX'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_90(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['FRAGMENT'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_91(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if 'XX%XX' in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_92(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' not in (ud['fragment'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_93(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] and _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_94(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['XXfragmentXX'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_95(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['FRAGMENT'] or _e) else ud['fragment'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_96(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['fragment'] and _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_97(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['XXfragmentXX'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return

    def xǁURLǁ__init____mutmut_98(self, url=''):
        # TODO: encoding param. The encoding that underlies the
        # percent-encoding is always utf8 for IRIs, but can be Latin-1
        # for other usage schemes.
        ud = DEFAULT_PARSED_URL
        if url:
            if isinstance(url, URL):
                url = url.to_text()  # better way to copy URLs?
            elif isinstance(url, bytes):
                try:
                    url = url.decode(DEFAULT_ENCODING)
                except UnicodeDecodeError as ude:
                    raise URLParseError('expected text or %s-encoded bytes.'
                                        ' try decoding the url bytes and'
                                        ' passing the result. (got: %s)'
                                        % (DEFAULT_ENCODING, ude))
            ud = parse_url(url)

        _e = ''
        self.scheme = ud['scheme'] or _e
        self._netloc_sep = ud['_netloc_sep'] or _e
        self.username = (unquote(ud['username'])
                         if '%' in (ud['username'] or _e) else ud['username'] or _e)
        self.password = (unquote(ud['password'])
                         if '%' in (ud['password'] or _e) else ud['password'] or _e)
        self.family = ud['family']

        if not ud['host']:
            self.host = _e
        else:
            try:
                self.host = ud['host'].encode("ascii")
            except UnicodeEncodeError:
                self.host = ud['host']  # already non-ascii text
            else:
                self.host = self.host.decode("idna")

        self.port = ud['port']
        self.path_parts = tuple([unquote(p) if '%' in p else p for p
                                 in (ud['path'] or _e).split('/')])
        self._query = ud['query'] or _e
        self.fragment = (unquote(ud['fragment'])
                         if '%' in (ud['fragment'] or _e) else ud['FRAGMENT'] or _e)
        # TODO: possibly use None as marker for empty vs missing
        return
    
    xǁURLǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁURLǁ__init____mutmut_1': xǁURLǁ__init____mutmut_1, 
        'xǁURLǁ__init____mutmut_2': xǁURLǁ__init____mutmut_2, 
        'xǁURLǁ__init____mutmut_3': xǁURLǁ__init____mutmut_3, 
        'xǁURLǁ__init____mutmut_4': xǁURLǁ__init____mutmut_4, 
        'xǁURLǁ__init____mutmut_5': xǁURLǁ__init____mutmut_5, 
        'xǁURLǁ__init____mutmut_6': xǁURLǁ__init____mutmut_6, 
        'xǁURLǁ__init____mutmut_7': xǁURLǁ__init____mutmut_7, 
        'xǁURLǁ__init____mutmut_8': xǁURLǁ__init____mutmut_8, 
        'xǁURLǁ__init____mutmut_9': xǁURLǁ__init____mutmut_9, 
        'xǁURLǁ__init____mutmut_10': xǁURLǁ__init____mutmut_10, 
        'xǁURLǁ__init____mutmut_11': xǁURLǁ__init____mutmut_11, 
        'xǁURLǁ__init____mutmut_12': xǁURLǁ__init____mutmut_12, 
        'xǁURLǁ__init____mutmut_13': xǁURLǁ__init____mutmut_13, 
        'xǁURLǁ__init____mutmut_14': xǁURLǁ__init____mutmut_14, 
        'xǁURLǁ__init____mutmut_15': xǁURLǁ__init____mutmut_15, 
        'xǁURLǁ__init____mutmut_16': xǁURLǁ__init____mutmut_16, 
        'xǁURLǁ__init____mutmut_17': xǁURLǁ__init____mutmut_17, 
        'xǁURLǁ__init____mutmut_18': xǁURLǁ__init____mutmut_18, 
        'xǁURLǁ__init____mutmut_19': xǁURLǁ__init____mutmut_19, 
        'xǁURLǁ__init____mutmut_20': xǁURLǁ__init____mutmut_20, 
        'xǁURLǁ__init____mutmut_21': xǁURLǁ__init____mutmut_21, 
        'xǁURLǁ__init____mutmut_22': xǁURLǁ__init____mutmut_22, 
        'xǁURLǁ__init____mutmut_23': xǁURLǁ__init____mutmut_23, 
        'xǁURLǁ__init____mutmut_24': xǁURLǁ__init____mutmut_24, 
        'xǁURLǁ__init____mutmut_25': xǁURLǁ__init____mutmut_25, 
        'xǁURLǁ__init____mutmut_26': xǁURLǁ__init____mutmut_26, 
        'xǁURLǁ__init____mutmut_27': xǁURLǁ__init____mutmut_27, 
        'xǁURLǁ__init____mutmut_28': xǁURLǁ__init____mutmut_28, 
        'xǁURLǁ__init____mutmut_29': xǁURLǁ__init____mutmut_29, 
        'xǁURLǁ__init____mutmut_30': xǁURLǁ__init____mutmut_30, 
        'xǁURLǁ__init____mutmut_31': xǁURLǁ__init____mutmut_31, 
        'xǁURLǁ__init____mutmut_32': xǁURLǁ__init____mutmut_32, 
        'xǁURLǁ__init____mutmut_33': xǁURLǁ__init____mutmut_33, 
        'xǁURLǁ__init____mutmut_34': xǁURLǁ__init____mutmut_34, 
        'xǁURLǁ__init____mutmut_35': xǁURLǁ__init____mutmut_35, 
        'xǁURLǁ__init____mutmut_36': xǁURLǁ__init____mutmut_36, 
        'xǁURLǁ__init____mutmut_37': xǁURLǁ__init____mutmut_37, 
        'xǁURLǁ__init____mutmut_38': xǁURLǁ__init____mutmut_38, 
        'xǁURLǁ__init____mutmut_39': xǁURLǁ__init____mutmut_39, 
        'xǁURLǁ__init____mutmut_40': xǁURLǁ__init____mutmut_40, 
        'xǁURLǁ__init____mutmut_41': xǁURLǁ__init____mutmut_41, 
        'xǁURLǁ__init____mutmut_42': xǁURLǁ__init____mutmut_42, 
        'xǁURLǁ__init____mutmut_43': xǁURLǁ__init____mutmut_43, 
        'xǁURLǁ__init____mutmut_44': xǁURLǁ__init____mutmut_44, 
        'xǁURLǁ__init____mutmut_45': xǁURLǁ__init____mutmut_45, 
        'xǁURLǁ__init____mutmut_46': xǁURLǁ__init____mutmut_46, 
        'xǁURLǁ__init____mutmut_47': xǁURLǁ__init____mutmut_47, 
        'xǁURLǁ__init____mutmut_48': xǁURLǁ__init____mutmut_48, 
        'xǁURLǁ__init____mutmut_49': xǁURLǁ__init____mutmut_49, 
        'xǁURLǁ__init____mutmut_50': xǁURLǁ__init____mutmut_50, 
        'xǁURLǁ__init____mutmut_51': xǁURLǁ__init____mutmut_51, 
        'xǁURLǁ__init____mutmut_52': xǁURLǁ__init____mutmut_52, 
        'xǁURLǁ__init____mutmut_53': xǁURLǁ__init____mutmut_53, 
        'xǁURLǁ__init____mutmut_54': xǁURLǁ__init____mutmut_54, 
        'xǁURLǁ__init____mutmut_55': xǁURLǁ__init____mutmut_55, 
        'xǁURLǁ__init____mutmut_56': xǁURLǁ__init____mutmut_56, 
        'xǁURLǁ__init____mutmut_57': xǁURLǁ__init____mutmut_57, 
        'xǁURLǁ__init____mutmut_58': xǁURLǁ__init____mutmut_58, 
        'xǁURLǁ__init____mutmut_59': xǁURLǁ__init____mutmut_59, 
        'xǁURLǁ__init____mutmut_60': xǁURLǁ__init____mutmut_60, 
        'xǁURLǁ__init____mutmut_61': xǁURLǁ__init____mutmut_61, 
        'xǁURLǁ__init____mutmut_62': xǁURLǁ__init____mutmut_62, 
        'xǁURLǁ__init____mutmut_63': xǁURLǁ__init____mutmut_63, 
        'xǁURLǁ__init____mutmut_64': xǁURLǁ__init____mutmut_64, 
        'xǁURLǁ__init____mutmut_65': xǁURLǁ__init____mutmut_65, 
        'xǁURLǁ__init____mutmut_66': xǁURLǁ__init____mutmut_66, 
        'xǁURLǁ__init____mutmut_67': xǁURLǁ__init____mutmut_67, 
        'xǁURLǁ__init____mutmut_68': xǁURLǁ__init____mutmut_68, 
        'xǁURLǁ__init____mutmut_69': xǁURLǁ__init____mutmut_69, 
        'xǁURLǁ__init____mutmut_70': xǁURLǁ__init____mutmut_70, 
        'xǁURLǁ__init____mutmut_71': xǁURLǁ__init____mutmut_71, 
        'xǁURLǁ__init____mutmut_72': xǁURLǁ__init____mutmut_72, 
        'xǁURLǁ__init____mutmut_73': xǁURLǁ__init____mutmut_73, 
        'xǁURLǁ__init____mutmut_74': xǁURLǁ__init____mutmut_74, 
        'xǁURLǁ__init____mutmut_75': xǁURLǁ__init____mutmut_75, 
        'xǁURLǁ__init____mutmut_76': xǁURLǁ__init____mutmut_76, 
        'xǁURLǁ__init____mutmut_77': xǁURLǁ__init____mutmut_77, 
        'xǁURLǁ__init____mutmut_78': xǁURLǁ__init____mutmut_78, 
        'xǁURLǁ__init____mutmut_79': xǁURLǁ__init____mutmut_79, 
        'xǁURLǁ__init____mutmut_80': xǁURLǁ__init____mutmut_80, 
        'xǁURLǁ__init____mutmut_81': xǁURLǁ__init____mutmut_81, 
        'xǁURLǁ__init____mutmut_82': xǁURLǁ__init____mutmut_82, 
        'xǁURLǁ__init____mutmut_83': xǁURLǁ__init____mutmut_83, 
        'xǁURLǁ__init____mutmut_84': xǁURLǁ__init____mutmut_84, 
        'xǁURLǁ__init____mutmut_85': xǁURLǁ__init____mutmut_85, 
        'xǁURLǁ__init____mutmut_86': xǁURLǁ__init____mutmut_86, 
        'xǁURLǁ__init____mutmut_87': xǁURLǁ__init____mutmut_87, 
        'xǁURLǁ__init____mutmut_88': xǁURLǁ__init____mutmut_88, 
        'xǁURLǁ__init____mutmut_89': xǁURLǁ__init____mutmut_89, 
        'xǁURLǁ__init____mutmut_90': xǁURLǁ__init____mutmut_90, 
        'xǁURLǁ__init____mutmut_91': xǁURLǁ__init____mutmut_91, 
        'xǁURLǁ__init____mutmut_92': xǁURLǁ__init____mutmut_92, 
        'xǁURLǁ__init____mutmut_93': xǁURLǁ__init____mutmut_93, 
        'xǁURLǁ__init____mutmut_94': xǁURLǁ__init____mutmut_94, 
        'xǁURLǁ__init____mutmut_95': xǁURLǁ__init____mutmut_95, 
        'xǁURLǁ__init____mutmut_96': xǁURLǁ__init____mutmut_96, 
        'xǁURLǁ__init____mutmut_97': xǁURLǁ__init____mutmut_97, 
        'xǁURLǁ__init____mutmut_98': xǁURLǁ__init____mutmut_98
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁURLǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁURLǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁURLǁ__init____mutmut_orig)
    xǁURLǁ__init____mutmut_orig.__name__ = 'xǁURLǁ__init__'

    @classmethod
    def from_parts(cls, scheme=None, host=None, path_parts=(), query_params=(),
                   fragment='', port=None, username=None, password=None):
        """Build a new URL from parts. Note that the respective arguments are
        not in the order they would appear in a URL:

        Args:
           scheme (str): The scheme of a URL, e.g., 'http'
           host (str): The host string, e.g., 'hatnote.com'
           path_parts (tuple): The individual text segments of the
             path, e.g., ('post', '123')
           query_params (dict): An OMD, dict, or list of (key, value)
             pairs representing the keys and values of the URL's query
             parameters.
           fragment (str): The fragment of the URL, e.g., 'anchor1'
           port (int): The integer port of URL, automatic defaults are
             available for registered schemes.
           username (str): The username for the userinfo part of the URL.
           password (str): The password for the userinfo part of the URL.

        Note that this method does relatively little
        validation. :meth:`URL.to_text()` should be used to check if
        any errors are produced while composing the final textual URL.
        """
        ret = cls()

        ret.scheme = scheme
        ret.host = host
        ret.path_parts = tuple(path_parts) or ('',)
        ret.query_params.update(query_params)
        ret.fragment = fragment
        ret.port = port
        ret.username = username
        ret.password = password

        return ret

    @cachedproperty
    def query_params(self):
        """The parsed form of the query string of the URL, represented as a
        :class:`~dictutils.OrderedMultiDict`. Also available as the
        handy alias ``qp``.

        >>> url = URL('http://boltons.readthedocs.io/?utm_source=doctest&python=great')
        >>> url.qp.keys()
        [u'utm_source', u'python']
        """
        return QueryParamDict.from_text(self._query)

    qp = query_params

    @property
    def path(self):
        "The URL's path, in text form."
        return '/'.join([quote_path_part(p, full_quote=False)
                          for p in self.path_parts])

    @path.setter
    def path(self, path_text):
        self.path_parts = tuple([unquote(p) if '%' in p else p
                                 for p in to_unicode(path_text).split('/')])
        return

    @property
    def uses_netloc(self):
        """Whether or not a URL uses :code:`:` or :code:`://` to separate the
        scheme from the rest of the URL depends on the scheme's own
        standard definition. There is no way to infer this behavior
        from other parts of the URL. A scheme either supports network
        locations or it does not.

        The URL type's approach to this is to check for explicitly
        registered schemes, with common schemes like HTTP
        preregistered. This is the same approach taken by
        :mod:`urlparse`.

        URL adds two additional heuristics if the scheme as a whole is
        not registered. First, it attempts to check the subpart of the
        scheme after the last ``+`` character. This adds intuitive
        behavior for schemes like ``git+ssh``. Second, if a URL with
        an unrecognized scheme is loaded, it will maintain the
        separator it sees.

        >>> print(URL('fakescheme://test.com').to_text())
        fakescheme://test.com
        >>> print(URL('mockscheme:hello:world').to_text())
        mockscheme:hello:world

        """
        default = self._netloc_sep
        if self.scheme in SCHEME_PORT_MAP:
            return True
        if self.scheme in NO_NETLOC_SCHEMES:
            return False
        if self.scheme.split('+')[-1] in SCHEME_PORT_MAP:
            return True
        return default

    @property
    def default_port(self):
        """Return the default port for the currently-set scheme. Returns
        ``None`` if the scheme is unrecognized. See
        :func:`register_scheme` above. If :attr:`~URL.port` matches
        this value, no port is emitted in the output of
        :meth:`~URL.to_text()`.

        Applies the same '+' heuristic detailed in :meth:`URL.uses_netloc`.
        """
        try:
            return SCHEME_PORT_MAP[self.scheme]
        except KeyError:
            return SCHEME_PORT_MAP.get(self.scheme.split('+')[-1])

    def xǁURLǁnormalize__mutmut_orig(self, with_case=True):
        """Resolve any "." and ".." references in the path, as well as
        normalize scheme and host casing. To turn off case
        normalization, pass ``with_case=False``.

        More information can be found in `Section 6.2.2 of RFC 3986`_.

        .. _Section 6.2.2 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-6.2.2
        """
        self.path_parts = resolve_path_parts(self.path_parts)

        if with_case:
            self.scheme = self.scheme.lower()
            self.host = self.host.lower()
        return

    def xǁURLǁnormalize__mutmut_1(self, with_case=False):
        """Resolve any "." and ".." references in the path, as well as
        normalize scheme and host casing. To turn off case
        normalization, pass ``with_case=False``.

        More information can be found in `Section 6.2.2 of RFC 3986`_.

        .. _Section 6.2.2 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-6.2.2
        """
        self.path_parts = resolve_path_parts(self.path_parts)

        if with_case:
            self.scheme = self.scheme.lower()
            self.host = self.host.lower()
        return

    def xǁURLǁnormalize__mutmut_2(self, with_case=True):
        """Resolve any "." and ".." references in the path, as well as
        normalize scheme and host casing. To turn off case
        normalization, pass ``with_case=False``.

        More information can be found in `Section 6.2.2 of RFC 3986`_.

        .. _Section 6.2.2 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-6.2.2
        """
        self.path_parts = None

        if with_case:
            self.scheme = self.scheme.lower()
            self.host = self.host.lower()
        return

    def xǁURLǁnormalize__mutmut_3(self, with_case=True):
        """Resolve any "." and ".." references in the path, as well as
        normalize scheme and host casing. To turn off case
        normalization, pass ``with_case=False``.

        More information can be found in `Section 6.2.2 of RFC 3986`_.

        .. _Section 6.2.2 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-6.2.2
        """
        self.path_parts = resolve_path_parts(None)

        if with_case:
            self.scheme = self.scheme.lower()
            self.host = self.host.lower()
        return

    def xǁURLǁnormalize__mutmut_4(self, with_case=True):
        """Resolve any "." and ".." references in the path, as well as
        normalize scheme and host casing. To turn off case
        normalization, pass ``with_case=False``.

        More information can be found in `Section 6.2.2 of RFC 3986`_.

        .. _Section 6.2.2 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-6.2.2
        """
        self.path_parts = resolve_path_parts(self.path_parts)

        if with_case:
            self.scheme = None
            self.host = self.host.lower()
        return

    def xǁURLǁnormalize__mutmut_5(self, with_case=True):
        """Resolve any "." and ".." references in the path, as well as
        normalize scheme and host casing. To turn off case
        normalization, pass ``with_case=False``.

        More information can be found in `Section 6.2.2 of RFC 3986`_.

        .. _Section 6.2.2 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-6.2.2
        """
        self.path_parts = resolve_path_parts(self.path_parts)

        if with_case:
            self.scheme = self.scheme.upper()
            self.host = self.host.lower()
        return

    def xǁURLǁnormalize__mutmut_6(self, with_case=True):
        """Resolve any "." and ".." references in the path, as well as
        normalize scheme and host casing. To turn off case
        normalization, pass ``with_case=False``.

        More information can be found in `Section 6.2.2 of RFC 3986`_.

        .. _Section 6.2.2 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-6.2.2
        """
        self.path_parts = resolve_path_parts(self.path_parts)

        if with_case:
            self.scheme = self.scheme.lower()
            self.host = None
        return

    def xǁURLǁnormalize__mutmut_7(self, with_case=True):
        """Resolve any "." and ".." references in the path, as well as
        normalize scheme and host casing. To turn off case
        normalization, pass ``with_case=False``.

        More information can be found in `Section 6.2.2 of RFC 3986`_.

        .. _Section 6.2.2 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-6.2.2
        """
        self.path_parts = resolve_path_parts(self.path_parts)

        if with_case:
            self.scheme = self.scheme.lower()
            self.host = self.host.upper()
        return
    
    xǁURLǁnormalize__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁURLǁnormalize__mutmut_1': xǁURLǁnormalize__mutmut_1, 
        'xǁURLǁnormalize__mutmut_2': xǁURLǁnormalize__mutmut_2, 
        'xǁURLǁnormalize__mutmut_3': xǁURLǁnormalize__mutmut_3, 
        'xǁURLǁnormalize__mutmut_4': xǁURLǁnormalize__mutmut_4, 
        'xǁURLǁnormalize__mutmut_5': xǁURLǁnormalize__mutmut_5, 
        'xǁURLǁnormalize__mutmut_6': xǁURLǁnormalize__mutmut_6, 
        'xǁURLǁnormalize__mutmut_7': xǁURLǁnormalize__mutmut_7
    }
    
    def normalize(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁURLǁnormalize__mutmut_orig"), object.__getattribute__(self, "xǁURLǁnormalize__mutmut_mutants"), args, kwargs, self)
        return result 
    
    normalize.__signature__ = _mutmut_signature(xǁURLǁnormalize__mutmut_orig)
    xǁURLǁnormalize__mutmut_orig.__name__ = 'xǁURLǁnormalize'

    def xǁURLǁnavigate__mutmut_orig(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_1(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = ""
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_2(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_3(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = None
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_4(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(None), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_5(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme or dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_6(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(None) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_7(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is not None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_8(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = None

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_9(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith(None):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_10(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('XX/XX'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_11(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = None
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_12(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(None)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_13(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = None
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_14(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) - list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_15(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(None) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_16(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:+1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_17(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-2]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_18(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(None)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_19(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = None
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_20(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(None)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_21(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_22(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = None

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_23(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = None
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_24(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=None,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_25(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=None,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_26(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=None,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_27(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=None,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_28(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=None,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_29(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=None,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_30(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=None,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_31(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=None)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_32(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_33(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_34(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_35(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_36(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_37(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_38(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_39(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              )
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_40(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme and self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_41(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host and self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_42(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port and self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_43(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username and self.username,
                              password=dest.password or self.password)
        ret.normalize()
        return ret

    def xǁURLǁnavigate__mutmut_44(self, dest):
        """Factory method that returns a _new_ :class:`URL` based on a given
        destination, *dest*. Useful for navigating those relative
        links with ease.

        The newly created :class:`URL` is normalized before being returned.

        >>> url = URL('http://boltons.readthedocs.io')
        >>> url.navigate('en/latest/')
        URL(u'http://boltons.readthedocs.io/en/latest/')

        Args:
           dest (str): A string or URL object representing the destination

        More information can be found in `Section 5 of RFC 3986`_.

        .. _Section 5 of RFC 3986: https://tools.ietf.org/html/rfc3986#section-5
        """
        orig_dest = None
        if not isinstance(dest, URL):
            dest, orig_dest = URL(dest), dest
        if dest.scheme and dest.host:
            # absolute URLs replace everything, but don't make an
            # extra copy if we don't have to
            return URL(dest) if orig_dest is None else dest
        query_params = dest.query_params

        if dest.path:
            if dest.path.startswith('/'):   # absolute path
                new_path_parts = list(dest.path_parts)
            else:  # relative path
                new_path_parts = list(self.path_parts[:-1]) \
                               + list(dest.path_parts)
        else:
            new_path_parts = list(self.path_parts)
            if not query_params:
                query_params = self.query_params

        ret = self.from_parts(scheme=dest.scheme or self.scheme,
                              host=dest.host or self.host,
                              port=dest.port or self.port,
                              path_parts=new_path_parts,
                              query_params=query_params,
                              fragment=dest.fragment,
                              username=dest.username or self.username,
                              password=dest.password and self.password)
        ret.normalize()
        return ret
    
    xǁURLǁnavigate__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁURLǁnavigate__mutmut_1': xǁURLǁnavigate__mutmut_1, 
        'xǁURLǁnavigate__mutmut_2': xǁURLǁnavigate__mutmut_2, 
        'xǁURLǁnavigate__mutmut_3': xǁURLǁnavigate__mutmut_3, 
        'xǁURLǁnavigate__mutmut_4': xǁURLǁnavigate__mutmut_4, 
        'xǁURLǁnavigate__mutmut_5': xǁURLǁnavigate__mutmut_5, 
        'xǁURLǁnavigate__mutmut_6': xǁURLǁnavigate__mutmut_6, 
        'xǁURLǁnavigate__mutmut_7': xǁURLǁnavigate__mutmut_7, 
        'xǁURLǁnavigate__mutmut_8': xǁURLǁnavigate__mutmut_8, 
        'xǁURLǁnavigate__mutmut_9': xǁURLǁnavigate__mutmut_9, 
        'xǁURLǁnavigate__mutmut_10': xǁURLǁnavigate__mutmut_10, 
        'xǁURLǁnavigate__mutmut_11': xǁURLǁnavigate__mutmut_11, 
        'xǁURLǁnavigate__mutmut_12': xǁURLǁnavigate__mutmut_12, 
        'xǁURLǁnavigate__mutmut_13': xǁURLǁnavigate__mutmut_13, 
        'xǁURLǁnavigate__mutmut_14': xǁURLǁnavigate__mutmut_14, 
        'xǁURLǁnavigate__mutmut_15': xǁURLǁnavigate__mutmut_15, 
        'xǁURLǁnavigate__mutmut_16': xǁURLǁnavigate__mutmut_16, 
        'xǁURLǁnavigate__mutmut_17': xǁURLǁnavigate__mutmut_17, 
        'xǁURLǁnavigate__mutmut_18': xǁURLǁnavigate__mutmut_18, 
        'xǁURLǁnavigate__mutmut_19': xǁURLǁnavigate__mutmut_19, 
        'xǁURLǁnavigate__mutmut_20': xǁURLǁnavigate__mutmut_20, 
        'xǁURLǁnavigate__mutmut_21': xǁURLǁnavigate__mutmut_21, 
        'xǁURLǁnavigate__mutmut_22': xǁURLǁnavigate__mutmut_22, 
        'xǁURLǁnavigate__mutmut_23': xǁURLǁnavigate__mutmut_23, 
        'xǁURLǁnavigate__mutmut_24': xǁURLǁnavigate__mutmut_24, 
        'xǁURLǁnavigate__mutmut_25': xǁURLǁnavigate__mutmut_25, 
        'xǁURLǁnavigate__mutmut_26': xǁURLǁnavigate__mutmut_26, 
        'xǁURLǁnavigate__mutmut_27': xǁURLǁnavigate__mutmut_27, 
        'xǁURLǁnavigate__mutmut_28': xǁURLǁnavigate__mutmut_28, 
        'xǁURLǁnavigate__mutmut_29': xǁURLǁnavigate__mutmut_29, 
        'xǁURLǁnavigate__mutmut_30': xǁURLǁnavigate__mutmut_30, 
        'xǁURLǁnavigate__mutmut_31': xǁURLǁnavigate__mutmut_31, 
        'xǁURLǁnavigate__mutmut_32': xǁURLǁnavigate__mutmut_32, 
        'xǁURLǁnavigate__mutmut_33': xǁURLǁnavigate__mutmut_33, 
        'xǁURLǁnavigate__mutmut_34': xǁURLǁnavigate__mutmut_34, 
        'xǁURLǁnavigate__mutmut_35': xǁURLǁnavigate__mutmut_35, 
        'xǁURLǁnavigate__mutmut_36': xǁURLǁnavigate__mutmut_36, 
        'xǁURLǁnavigate__mutmut_37': xǁURLǁnavigate__mutmut_37, 
        'xǁURLǁnavigate__mutmut_38': xǁURLǁnavigate__mutmut_38, 
        'xǁURLǁnavigate__mutmut_39': xǁURLǁnavigate__mutmut_39, 
        'xǁURLǁnavigate__mutmut_40': xǁURLǁnavigate__mutmut_40, 
        'xǁURLǁnavigate__mutmut_41': xǁURLǁnavigate__mutmut_41, 
        'xǁURLǁnavigate__mutmut_42': xǁURLǁnavigate__mutmut_42, 
        'xǁURLǁnavigate__mutmut_43': xǁURLǁnavigate__mutmut_43, 
        'xǁURLǁnavigate__mutmut_44': xǁURLǁnavigate__mutmut_44
    }
    
    def navigate(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁURLǁnavigate__mutmut_orig"), object.__getattribute__(self, "xǁURLǁnavigate__mutmut_mutants"), args, kwargs, self)
        return result 
    
    navigate.__signature__ = _mutmut_signature(xǁURLǁnavigate__mutmut_orig)
    xǁURLǁnavigate__mutmut_orig.__name__ = 'xǁURLǁnavigate'

    def xǁURLǁget_authority__mutmut_orig(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_1(self, full_quote=True, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_2(self, full_quote=False, with_userinfo=True):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_3(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = None
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_4(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = None
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_5(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username or with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_6(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(None)
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_7(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(None))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_8(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(None)
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_9(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add('XX:XX')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_10(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(None)
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_11(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(None))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_12(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add(None)
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_13(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('XX@XX')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_14(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family != socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_15(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add(None)
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_16(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('XX[XX')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_17(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(None)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_18(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(None)
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_19(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add('XX]XX')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_20(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(None)
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_21(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode(None))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_22(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode(None).decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_23(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('XXidnaXX').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_24(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('IDNA').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_25(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('XXasciiXX'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_26(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ASCII'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_27(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(None)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_28(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port or self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_29(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port == self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_30(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(None)
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_31(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add('XX:XX')
                _add(str(self.port))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_32(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(None)
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_33(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(None))
        return ''.join(parts)

    def xǁURLǁget_authority__mutmut_34(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return ''.join(None)

    def xǁURLǁget_authority__mutmut_35(self, full_quote=False, with_userinfo=False):
        """Used by URL schemes that have a network location,
        :meth:`~URL.get_authority` combines :attr:`username`,
        :attr:`password`, :attr:`host`, and :attr:`port` into one
        string, the *authority*, that is used for
        connecting to a network-accessible resource.

        Used internally by :meth:`~URL.to_text()` and can be useful
        for labeling connections.

        >>> url = URL('ftp://user@ftp.debian.org:2121/debian/README')
        >>> print(url.get_authority())
        ftp.debian.org:2121
        >>> print(url.get_authority(with_userinfo=True))
        user@ftp.debian.org:2121

        Args:
           full_quote (bool): Whether or not to apply IDNA encoding.
              Defaults to ``False``.
           with_userinfo (bool): Whether or not to include username
              and password, technically part of the
              authority. Defaults to ``False``.

        """
        parts = []
        _add = parts.append
        if self.username and with_userinfo:
            _add(quote_userinfo_part(self.username))
            if self.password:
                _add(':')
                _add(quote_userinfo_part(self.password))
            _add('@')
        if self.host:
            if self.family == socket.AF_INET6:
                _add('[')
                _add(self.host)
                _add(']')
            elif full_quote:
                _add(self.host.encode('idna').decode('ascii'))
            else:
                _add(self.host)
            # TODO: 0 port?
            if self.port and self.port != self.default_port:
                _add(':')
                _add(str(self.port))
        return 'XXXX'.join(parts)
    
    xǁURLǁget_authority__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁURLǁget_authority__mutmut_1': xǁURLǁget_authority__mutmut_1, 
        'xǁURLǁget_authority__mutmut_2': xǁURLǁget_authority__mutmut_2, 
        'xǁURLǁget_authority__mutmut_3': xǁURLǁget_authority__mutmut_3, 
        'xǁURLǁget_authority__mutmut_4': xǁURLǁget_authority__mutmut_4, 
        'xǁURLǁget_authority__mutmut_5': xǁURLǁget_authority__mutmut_5, 
        'xǁURLǁget_authority__mutmut_6': xǁURLǁget_authority__mutmut_6, 
        'xǁURLǁget_authority__mutmut_7': xǁURLǁget_authority__mutmut_7, 
        'xǁURLǁget_authority__mutmut_8': xǁURLǁget_authority__mutmut_8, 
        'xǁURLǁget_authority__mutmut_9': xǁURLǁget_authority__mutmut_9, 
        'xǁURLǁget_authority__mutmut_10': xǁURLǁget_authority__mutmut_10, 
        'xǁURLǁget_authority__mutmut_11': xǁURLǁget_authority__mutmut_11, 
        'xǁURLǁget_authority__mutmut_12': xǁURLǁget_authority__mutmut_12, 
        'xǁURLǁget_authority__mutmut_13': xǁURLǁget_authority__mutmut_13, 
        'xǁURLǁget_authority__mutmut_14': xǁURLǁget_authority__mutmut_14, 
        'xǁURLǁget_authority__mutmut_15': xǁURLǁget_authority__mutmut_15, 
        'xǁURLǁget_authority__mutmut_16': xǁURLǁget_authority__mutmut_16, 
        'xǁURLǁget_authority__mutmut_17': xǁURLǁget_authority__mutmut_17, 
        'xǁURLǁget_authority__mutmut_18': xǁURLǁget_authority__mutmut_18, 
        'xǁURLǁget_authority__mutmut_19': xǁURLǁget_authority__mutmut_19, 
        'xǁURLǁget_authority__mutmut_20': xǁURLǁget_authority__mutmut_20, 
        'xǁURLǁget_authority__mutmut_21': xǁURLǁget_authority__mutmut_21, 
        'xǁURLǁget_authority__mutmut_22': xǁURLǁget_authority__mutmut_22, 
        'xǁURLǁget_authority__mutmut_23': xǁURLǁget_authority__mutmut_23, 
        'xǁURLǁget_authority__mutmut_24': xǁURLǁget_authority__mutmut_24, 
        'xǁURLǁget_authority__mutmut_25': xǁURLǁget_authority__mutmut_25, 
        'xǁURLǁget_authority__mutmut_26': xǁURLǁget_authority__mutmut_26, 
        'xǁURLǁget_authority__mutmut_27': xǁURLǁget_authority__mutmut_27, 
        'xǁURLǁget_authority__mutmut_28': xǁURLǁget_authority__mutmut_28, 
        'xǁURLǁget_authority__mutmut_29': xǁURLǁget_authority__mutmut_29, 
        'xǁURLǁget_authority__mutmut_30': xǁURLǁget_authority__mutmut_30, 
        'xǁURLǁget_authority__mutmut_31': xǁURLǁget_authority__mutmut_31, 
        'xǁURLǁget_authority__mutmut_32': xǁURLǁget_authority__mutmut_32, 
        'xǁURLǁget_authority__mutmut_33': xǁURLǁget_authority__mutmut_33, 
        'xǁURLǁget_authority__mutmut_34': xǁURLǁget_authority__mutmut_34, 
        'xǁURLǁget_authority__mutmut_35': xǁURLǁget_authority__mutmut_35
    }
    
    def get_authority(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁURLǁget_authority__mutmut_orig"), object.__getattribute__(self, "xǁURLǁget_authority__mutmut_mutants"), args, kwargs, self)
        return result 
    
    get_authority.__signature__ = _mutmut_signature(xǁURLǁget_authority__mutmut_orig)
    xǁURLǁget_authority__mutmut_orig.__name__ = 'xǁURLǁget_authority'

    def xǁURLǁto_text__mutmut_orig(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_1(self, full_quote=True):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_2(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = None
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_3(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = None
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_4(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join(None)
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_5(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = 'XX/XX'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_6(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(None, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_7(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=None)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_8(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_9(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, )
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_10(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = None
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_11(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=None,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_12(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=None)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_13(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_14(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       )
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_15(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=False)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_16(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = None
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_17(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=None)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_18(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = None

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_19(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(None, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_20(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=None)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_21(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_22(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, )

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_23(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = None
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_24(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = None
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_25(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(None)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_26(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(None)
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_27(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add('XX:XX')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_28(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add(None)
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_29(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('XX//XX')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_30(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(None)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_31(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' or self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_32(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme or path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_33(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:3] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_34(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] == '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_35(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != 'XX//XX' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_36(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add(None)
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_37(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('XX//XX')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_38(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority or path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_39(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme or authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_40(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:2] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_41(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] == '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_42(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != 'XX/XX':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_43(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add(None)
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_44(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('XX/XX')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_45(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(None)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_46(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add(None)
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_47(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('XX?XX')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_48(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(None)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_49(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add(None)
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_50(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('XX#XX')
            _add(fragment)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_51(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(None)
        return ''.join(parts)

    def xǁURLǁto_text__mutmut_52(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return ''.join(None)

    def xǁURLǁto_text__mutmut_53(self, full_quote=False):
        """Render a string representing the current state of the URL
        object.

        >>> url = URL('http://listen.hatnote.com')
        >>> url.fragment = 'en'
        >>> print(url.to_text())
        http://listen.hatnote.com#en

        By setting the *full_quote* flag, the URL can either be fully
        quoted or minimally quoted. The most common characteristic of
        an encoded-URL is the presence of percent-encoded text (e.g.,
        %60).  Unquoted URLs are more readable and suitable
        for display, whereas fully-quoted URLs are more conservative
        and generally necessary for sending over the network.
        """
        scheme = self.scheme
        path = '/'.join([quote_path_part(p, full_quote=full_quote)
                          for p in self.path_parts])
        authority = self.get_authority(full_quote=full_quote,
                                       with_userinfo=True)
        query_string = self.query_params.to_text(full_quote=full_quote)
        fragment = quote_fragment_part(self.fragment, full_quote=full_quote)

        parts = []
        _add = parts.append
        if scheme:
            _add(scheme)
            _add(':')
        if authority:
            _add('//')
            _add(authority)
        elif (scheme and path[:2] != '//' and self.uses_netloc):
            _add('//')
        if path:
            if scheme and authority and path[:1] != '/':
                _add('/')
                # TODO: i think this is here because relative paths
                # with absolute authorities = undefined
            _add(path)
        if query_string:
            _add('?')
            _add(query_string)
        if fragment:
            _add('#')
            _add(fragment)
        return 'XXXX'.join(parts)
    
    xǁURLǁto_text__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁURLǁto_text__mutmut_1': xǁURLǁto_text__mutmut_1, 
        'xǁURLǁto_text__mutmut_2': xǁURLǁto_text__mutmut_2, 
        'xǁURLǁto_text__mutmut_3': xǁURLǁto_text__mutmut_3, 
        'xǁURLǁto_text__mutmut_4': xǁURLǁto_text__mutmut_4, 
        'xǁURLǁto_text__mutmut_5': xǁURLǁto_text__mutmut_5, 
        'xǁURLǁto_text__mutmut_6': xǁURLǁto_text__mutmut_6, 
        'xǁURLǁto_text__mutmut_7': xǁURLǁto_text__mutmut_7, 
        'xǁURLǁto_text__mutmut_8': xǁURLǁto_text__mutmut_8, 
        'xǁURLǁto_text__mutmut_9': xǁURLǁto_text__mutmut_9, 
        'xǁURLǁto_text__mutmut_10': xǁURLǁto_text__mutmut_10, 
        'xǁURLǁto_text__mutmut_11': xǁURLǁto_text__mutmut_11, 
        'xǁURLǁto_text__mutmut_12': xǁURLǁto_text__mutmut_12, 
        'xǁURLǁto_text__mutmut_13': xǁURLǁto_text__mutmut_13, 
        'xǁURLǁto_text__mutmut_14': xǁURLǁto_text__mutmut_14, 
        'xǁURLǁto_text__mutmut_15': xǁURLǁto_text__mutmut_15, 
        'xǁURLǁto_text__mutmut_16': xǁURLǁto_text__mutmut_16, 
        'xǁURLǁto_text__mutmut_17': xǁURLǁto_text__mutmut_17, 
        'xǁURLǁto_text__mutmut_18': xǁURLǁto_text__mutmut_18, 
        'xǁURLǁto_text__mutmut_19': xǁURLǁto_text__mutmut_19, 
        'xǁURLǁto_text__mutmut_20': xǁURLǁto_text__mutmut_20, 
        'xǁURLǁto_text__mutmut_21': xǁURLǁto_text__mutmut_21, 
        'xǁURLǁto_text__mutmut_22': xǁURLǁto_text__mutmut_22, 
        'xǁURLǁto_text__mutmut_23': xǁURLǁto_text__mutmut_23, 
        'xǁURLǁto_text__mutmut_24': xǁURLǁto_text__mutmut_24, 
        'xǁURLǁto_text__mutmut_25': xǁURLǁto_text__mutmut_25, 
        'xǁURLǁto_text__mutmut_26': xǁURLǁto_text__mutmut_26, 
        'xǁURLǁto_text__mutmut_27': xǁURLǁto_text__mutmut_27, 
        'xǁURLǁto_text__mutmut_28': xǁURLǁto_text__mutmut_28, 
        'xǁURLǁto_text__mutmut_29': xǁURLǁto_text__mutmut_29, 
        'xǁURLǁto_text__mutmut_30': xǁURLǁto_text__mutmut_30, 
        'xǁURLǁto_text__mutmut_31': xǁURLǁto_text__mutmut_31, 
        'xǁURLǁto_text__mutmut_32': xǁURLǁto_text__mutmut_32, 
        'xǁURLǁto_text__mutmut_33': xǁURLǁto_text__mutmut_33, 
        'xǁURLǁto_text__mutmut_34': xǁURLǁto_text__mutmut_34, 
        'xǁURLǁto_text__mutmut_35': xǁURLǁto_text__mutmut_35, 
        'xǁURLǁto_text__mutmut_36': xǁURLǁto_text__mutmut_36, 
        'xǁURLǁto_text__mutmut_37': xǁURLǁto_text__mutmut_37, 
        'xǁURLǁto_text__mutmut_38': xǁURLǁto_text__mutmut_38, 
        'xǁURLǁto_text__mutmut_39': xǁURLǁto_text__mutmut_39, 
        'xǁURLǁto_text__mutmut_40': xǁURLǁto_text__mutmut_40, 
        'xǁURLǁto_text__mutmut_41': xǁURLǁto_text__mutmut_41, 
        'xǁURLǁto_text__mutmut_42': xǁURLǁto_text__mutmut_42, 
        'xǁURLǁto_text__mutmut_43': xǁURLǁto_text__mutmut_43, 
        'xǁURLǁto_text__mutmut_44': xǁURLǁto_text__mutmut_44, 
        'xǁURLǁto_text__mutmut_45': xǁURLǁto_text__mutmut_45, 
        'xǁURLǁto_text__mutmut_46': xǁURLǁto_text__mutmut_46, 
        'xǁURLǁto_text__mutmut_47': xǁURLǁto_text__mutmut_47, 
        'xǁURLǁto_text__mutmut_48': xǁURLǁto_text__mutmut_48, 
        'xǁURLǁto_text__mutmut_49': xǁURLǁto_text__mutmut_49, 
        'xǁURLǁto_text__mutmut_50': xǁURLǁto_text__mutmut_50, 
        'xǁURLǁto_text__mutmut_51': xǁURLǁto_text__mutmut_51, 
        'xǁURLǁto_text__mutmut_52': xǁURLǁto_text__mutmut_52, 
        'xǁURLǁto_text__mutmut_53': xǁURLǁto_text__mutmut_53
    }
    
    def to_text(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁURLǁto_text__mutmut_orig"), object.__getattribute__(self, "xǁURLǁto_text__mutmut_mutants"), args, kwargs, self)
        return result 
    
    to_text.__signature__ = _mutmut_signature(xǁURLǁto_text__mutmut_orig)
    xǁURLǁto_text__mutmut_orig.__name__ = 'xǁURLǁto_text'

    def xǁURLǁ__repr____mutmut_orig(self):
        cn = self.__class__.__name__
        return f'{cn}({self.to_text()!r})'

    def xǁURLǁ__repr____mutmut_1(self):
        cn = None
        return f'{cn}({self.to_text()!r})'
    
    xǁURLǁ__repr____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁURLǁ__repr____mutmut_1': xǁURLǁ__repr____mutmut_1
    }
    
    def __repr__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁURLǁ__repr____mutmut_orig"), object.__getattribute__(self, "xǁURLǁ__repr____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __repr__.__signature__ = _mutmut_signature(xǁURLǁ__repr____mutmut_orig)
    xǁURLǁ__repr____mutmut_orig.__name__ = 'xǁURLǁ__repr__'

    def __str__(self):
        return self.to_text()

    def __unicode__(self):
        return self.to_text()

    def xǁURLǁ__eq____mutmut_orig(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, attr) == getattr(other, attr, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_1(self, other):
        for attr in self._cmp_attrs:
            if getattr(self, attr) == getattr(other, attr, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_2(self, other):
        for attr in self._cmp_attrs:
            if not getattr(None, attr) == getattr(other, attr, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_3(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, None) == getattr(other, attr, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_4(self, other):
        for attr in self._cmp_attrs:
            if not getattr(attr) == getattr(other, attr, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_5(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, ) == getattr(other, attr, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_6(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, attr) != getattr(other, attr, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_7(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, attr) == getattr(None, attr, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_8(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, attr) == getattr(other, None, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_9(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, attr) == getattr(attr, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_10(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, attr) == getattr(other, None):
                return False
        return True

    def xǁURLǁ__eq____mutmut_11(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, attr) == getattr(other, attr, ):
                return False
        return True

    def xǁURLǁ__eq____mutmut_12(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, attr) == getattr(other, attr, None):
                return True
        return True

    def xǁURLǁ__eq____mutmut_13(self, other):
        for attr in self._cmp_attrs:
            if not getattr(self, attr) == getattr(other, attr, None):
                return False
        return False
    
    xǁURLǁ__eq____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁURLǁ__eq____mutmut_1': xǁURLǁ__eq____mutmut_1, 
        'xǁURLǁ__eq____mutmut_2': xǁURLǁ__eq____mutmut_2, 
        'xǁURLǁ__eq____mutmut_3': xǁURLǁ__eq____mutmut_3, 
        'xǁURLǁ__eq____mutmut_4': xǁURLǁ__eq____mutmut_4, 
        'xǁURLǁ__eq____mutmut_5': xǁURLǁ__eq____mutmut_5, 
        'xǁURLǁ__eq____mutmut_6': xǁURLǁ__eq____mutmut_6, 
        'xǁURLǁ__eq____mutmut_7': xǁURLǁ__eq____mutmut_7, 
        'xǁURLǁ__eq____mutmut_8': xǁURLǁ__eq____mutmut_8, 
        'xǁURLǁ__eq____mutmut_9': xǁURLǁ__eq____mutmut_9, 
        'xǁURLǁ__eq____mutmut_10': xǁURLǁ__eq____mutmut_10, 
        'xǁURLǁ__eq____mutmut_11': xǁURLǁ__eq____mutmut_11, 
        'xǁURLǁ__eq____mutmut_12': xǁURLǁ__eq____mutmut_12, 
        'xǁURLǁ__eq____mutmut_13': xǁURLǁ__eq____mutmut_13
    }
    
    def __eq__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁURLǁ__eq____mutmut_orig"), object.__getattribute__(self, "xǁURLǁ__eq____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __eq__.__signature__ = _mutmut_signature(xǁURLǁ__eq____mutmut_orig)
    xǁURLǁ__eq____mutmut_orig.__name__ = 'xǁURLǁ__eq__'

    def xǁURLǁ__ne____mutmut_orig(self, other):
        return not self == other

    def xǁURLǁ__ne____mutmut_1(self, other):
        return self == other

    def xǁURLǁ__ne____mutmut_2(self, other):
        return not self != other
    
    xǁURLǁ__ne____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁURLǁ__ne____mutmut_1': xǁURLǁ__ne____mutmut_1, 
        'xǁURLǁ__ne____mutmut_2': xǁURLǁ__ne____mutmut_2
    }
    
    def __ne__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁURLǁ__ne____mutmut_orig"), object.__getattribute__(self, "xǁURLǁ__ne____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __ne__.__signature__ = _mutmut_signature(xǁURLǁ__ne____mutmut_orig)
    xǁURLǁ__ne____mutmut_orig.__name__ = 'xǁURLǁ__ne__'


try:
    from socket import inet_pton
except ImportError:
    # from https://gist.github.com/nnemkin/4966028
    import ctypes

    class _sockaddr(ctypes.Structure):
        _fields_ = [("sa_family", ctypes.c_short),
                    ("__pad1", ctypes.c_ushort),
                    ("ipv4_addr", ctypes.c_byte * 4),
                    ("ipv6_addr", ctypes.c_byte * 16),
                    ("__pad2", ctypes.c_ulong)]

    WSAStringToAddressA = ctypes.windll.ws2_32.WSAStringToAddressA
    WSAAddressToStringA = ctypes.windll.ws2_32.WSAAddressToStringA

    def inet_pton(address_family, ip_string):
        addr = _sockaddr()
        ip_string = ip_string.encode('ascii')
        addr.sa_family = address_family
        addr_size = ctypes.c_int(ctypes.sizeof(addr))

        if WSAStringToAddressA(ip_string, address_family, None, ctypes.byref(addr), ctypes.byref(addr_size)) != 0:
            raise OSError(ctypes.FormatError())

        if address_family == socket.AF_INET:
            return ctypes.string_at(addr.ipv4_addr, 4)
        if address_family == socket.AF_INET6:
            return ctypes.string_at(addr.ipv6_addr, 16)
        raise OSError('unknown address family')


def x_parse_host__mutmut_orig(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_1(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_2(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, 'XXXX'
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_3(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] or ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_4(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host or '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_5(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if 'XX:XX' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_6(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' not in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_7(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and 'XX[XX' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_8(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' != host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_9(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[1] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_10(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and 'XX]XX' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_11(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' != host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_12(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[+1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_13(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-2]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_14(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = None
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_15(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[2:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_16(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:+1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_17(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-2]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_18(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(None, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_19(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, None)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_20(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_21(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, )
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_22(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(None)
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_23(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = None
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_24(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(None, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_25(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, None)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_26(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_27(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, )
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_28(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = ""  # not an IP
    else:
        family = socket.AF_INET
    return family, host


def x_parse_host__mutmut_29(host):
    """\
    Low-level function used to parse the host portion of a URL.

    Returns a tuple of (family, host) where *family* is a
    :mod:`socket` module constant or ``None``, and host is a string.

    >>> parse_host('googlewebsite.com') == (None, 'googlewebsite.com')
    True
    >>> parse_host('[::1]') == (socket.AF_INET6, '::1')
    True
    >>> parse_host('192.168.1.1') == (socket.AF_INET, '192.168.1.1')
    True

    Odd doctest formatting above due to py3's switch from int to enums
    for :mod:`socket` constants.

    """
    if not host:
        return None, ''
    if ':' in host and '[' == host[0] and ']' == host[-1]:
        host = host[1:-1]
        try:
            inet_pton(socket.AF_INET6, host)
        except OSError as se:
            raise URLParseError(f'invalid IPv6 host: {host!r} ({se!r})')
        except UnicodeEncodeError:
            pass  # TODO: this can't be a real host right?
        else:
            family = socket.AF_INET6
            return family, host
    try:
        inet_pton(socket.AF_INET, host)
    except (OSError, UnicodeEncodeError):
        family = None  # not an IP
    else:
        family = None
    return family, host

x_parse_host__mutmut_mutants : ClassVar[MutantDict] = {
'x_parse_host__mutmut_1': x_parse_host__mutmut_1, 
    'x_parse_host__mutmut_2': x_parse_host__mutmut_2, 
    'x_parse_host__mutmut_3': x_parse_host__mutmut_3, 
    'x_parse_host__mutmut_4': x_parse_host__mutmut_4, 
    'x_parse_host__mutmut_5': x_parse_host__mutmut_5, 
    'x_parse_host__mutmut_6': x_parse_host__mutmut_6, 
    'x_parse_host__mutmut_7': x_parse_host__mutmut_7, 
    'x_parse_host__mutmut_8': x_parse_host__mutmut_8, 
    'x_parse_host__mutmut_9': x_parse_host__mutmut_9, 
    'x_parse_host__mutmut_10': x_parse_host__mutmut_10, 
    'x_parse_host__mutmut_11': x_parse_host__mutmut_11, 
    'x_parse_host__mutmut_12': x_parse_host__mutmut_12, 
    'x_parse_host__mutmut_13': x_parse_host__mutmut_13, 
    'x_parse_host__mutmut_14': x_parse_host__mutmut_14, 
    'x_parse_host__mutmut_15': x_parse_host__mutmut_15, 
    'x_parse_host__mutmut_16': x_parse_host__mutmut_16, 
    'x_parse_host__mutmut_17': x_parse_host__mutmut_17, 
    'x_parse_host__mutmut_18': x_parse_host__mutmut_18, 
    'x_parse_host__mutmut_19': x_parse_host__mutmut_19, 
    'x_parse_host__mutmut_20': x_parse_host__mutmut_20, 
    'x_parse_host__mutmut_21': x_parse_host__mutmut_21, 
    'x_parse_host__mutmut_22': x_parse_host__mutmut_22, 
    'x_parse_host__mutmut_23': x_parse_host__mutmut_23, 
    'x_parse_host__mutmut_24': x_parse_host__mutmut_24, 
    'x_parse_host__mutmut_25': x_parse_host__mutmut_25, 
    'x_parse_host__mutmut_26': x_parse_host__mutmut_26, 
    'x_parse_host__mutmut_27': x_parse_host__mutmut_27, 
    'x_parse_host__mutmut_28': x_parse_host__mutmut_28, 
    'x_parse_host__mutmut_29': x_parse_host__mutmut_29
}

def parse_host(*args, **kwargs):
    result = _mutmut_trampoline(x_parse_host__mutmut_orig, x_parse_host__mutmut_mutants, args, kwargs)
    return result 

parse_host.__signature__ = _mutmut_signature(x_parse_host__mutmut_orig)
x_parse_host__mutmut_orig.__name__ = 'x_parse_host'


def x_parse_url__mutmut_orig(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_1(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = None
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_2(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(None)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_3(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = None
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_4(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(None)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_5(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = None
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_6(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError(None)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_7(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' / url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_8(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('XXcould not parse url: %rXX' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_9(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('COULD NOT PARSE URL: %R' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_10(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = None
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_11(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['XXauthorityXX']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_12(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['AUTHORITY']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_13(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_14(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = None
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_15(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition(None)
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_16(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.partition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_17(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('XX@XX')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_18(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = None

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_19(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(None)

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_20(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.rpartition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_21(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition('XX:XX')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_22(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_23(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = None
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_24(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(None)
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_25(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.rpartition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_26(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition('XX:XX')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_27(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' or ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_28(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host or host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_29(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[1] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_30(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] != '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_31(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == 'XX[XX' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_32(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and 'XX]XX' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_33(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' not in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_34(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = None
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_35(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(None)
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_36(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.rpartition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_37(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition('XX]XX')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_38(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = None
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_39(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right - ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_40(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' - host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_41(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host - ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_42(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + 'XX:XX' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_43(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + 'XX]XX'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_44(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str or port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_45(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[1] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_46(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] != ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_47(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == 'XX:XX':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_48(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = None

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_49(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[2:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_50(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = None
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_51(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(None)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_52(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError(None)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_53(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r' / port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_54(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('XXexpected integer for port, not %rXX'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_55(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('EXPECTED INTEGER FOR PORT, NOT %R'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_56(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = ""

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_57(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = None

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_58(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(None)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_59(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = None
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_60(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['XXusernameXX'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_61(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['USERNAME'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_62(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = None
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_63(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['XXpasswordXX'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_64(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['PASSWORD'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_65(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = None
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_66(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['XXfamilyXX'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_67(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['FAMILY'] = family
    gs['host'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_68(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = None
    gs['port'] = port
    return gs


def x_parse_url__mutmut_69(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['XXhostXX'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_70(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['HOST'] = host
    gs['port'] = port
    return gs


def x_parse_url__mutmut_71(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['port'] = None
    return gs


def x_parse_url__mutmut_72(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['XXportXX'] = port
    return gs


def x_parse_url__mutmut_73(url_text):
    """\
    Used to parse the text for a single URL into a dictionary, used
    internally by the :class:`URL` type.

    Note that "URL" has a very narrow, standards-based
    definition. While :func:`parse_url` may raise
    :class:`URLParseError` under a very limited number of conditions,
    such as non-integer port, a surprising number of strings are
    technically valid URLs. For instance, the text ``"url"`` is a
    valid URL, because it is a relative path.

    In short, do not expect this function to validate form inputs or
    other more colloquial usages of URLs.

    >>> res = parse_url('http://127.0.0.1:3000/?a=1')
    >>> sorted(res.keys())  # res is a basic dictionary
    ['_netloc_sep', 'authority', 'family', 'fragment', 'host', 'password', 'path', 'port', 'query', 'scheme', 'username']
    """
    url_text = str(url_text)
    # raise TypeError('parse_url expected text, not %r' % url_str)
    um = _URL_RE.match(url_text)
    try:
        gs = um.groupdict()
    except AttributeError:
        raise URLParseError('could not parse url: %r' % url_text)

    au_text = gs['authority']
    user, pw, hostinfo = None, None, au_text

    if au_text:
        userinfo, sep, hostinfo = au_text.rpartition('@')
        if sep:
            # TODO: empty userinfo error?
            user, _, pw = userinfo.partition(':')

    host, port = None, None
    if hostinfo:
        host, sep, port_str = hostinfo.partition(':')
        if sep:
            if host and host[0] == '[' and ']' in port_str:
                host_right, _, port_str = port_str.partition(']')
                host = host + ':' + host_right + ']'
                if port_str and port_str[0] == ':':
                    port_str = port_str[1:]

            try:
                port = int(port_str)
            except ValueError:
                if port_str:  # empty ports ok according to RFC 3986 6.2.3
                    raise URLParseError('expected integer for port, not %r'
                                        % port_str)
                port = None

    family, host = parse_host(host)

    gs['username'] = user
    gs['password'] = pw
    gs['family'] = family
    gs['host'] = host
    gs['PORT'] = port
    return gs

x_parse_url__mutmut_mutants : ClassVar[MutantDict] = {
'x_parse_url__mutmut_1': x_parse_url__mutmut_1, 
    'x_parse_url__mutmut_2': x_parse_url__mutmut_2, 
    'x_parse_url__mutmut_3': x_parse_url__mutmut_3, 
    'x_parse_url__mutmut_4': x_parse_url__mutmut_4, 
    'x_parse_url__mutmut_5': x_parse_url__mutmut_5, 
    'x_parse_url__mutmut_6': x_parse_url__mutmut_6, 
    'x_parse_url__mutmut_7': x_parse_url__mutmut_7, 
    'x_parse_url__mutmut_8': x_parse_url__mutmut_8, 
    'x_parse_url__mutmut_9': x_parse_url__mutmut_9, 
    'x_parse_url__mutmut_10': x_parse_url__mutmut_10, 
    'x_parse_url__mutmut_11': x_parse_url__mutmut_11, 
    'x_parse_url__mutmut_12': x_parse_url__mutmut_12, 
    'x_parse_url__mutmut_13': x_parse_url__mutmut_13, 
    'x_parse_url__mutmut_14': x_parse_url__mutmut_14, 
    'x_parse_url__mutmut_15': x_parse_url__mutmut_15, 
    'x_parse_url__mutmut_16': x_parse_url__mutmut_16, 
    'x_parse_url__mutmut_17': x_parse_url__mutmut_17, 
    'x_parse_url__mutmut_18': x_parse_url__mutmut_18, 
    'x_parse_url__mutmut_19': x_parse_url__mutmut_19, 
    'x_parse_url__mutmut_20': x_parse_url__mutmut_20, 
    'x_parse_url__mutmut_21': x_parse_url__mutmut_21, 
    'x_parse_url__mutmut_22': x_parse_url__mutmut_22, 
    'x_parse_url__mutmut_23': x_parse_url__mutmut_23, 
    'x_parse_url__mutmut_24': x_parse_url__mutmut_24, 
    'x_parse_url__mutmut_25': x_parse_url__mutmut_25, 
    'x_parse_url__mutmut_26': x_parse_url__mutmut_26, 
    'x_parse_url__mutmut_27': x_parse_url__mutmut_27, 
    'x_parse_url__mutmut_28': x_parse_url__mutmut_28, 
    'x_parse_url__mutmut_29': x_parse_url__mutmut_29, 
    'x_parse_url__mutmut_30': x_parse_url__mutmut_30, 
    'x_parse_url__mutmut_31': x_parse_url__mutmut_31, 
    'x_parse_url__mutmut_32': x_parse_url__mutmut_32, 
    'x_parse_url__mutmut_33': x_parse_url__mutmut_33, 
    'x_parse_url__mutmut_34': x_parse_url__mutmut_34, 
    'x_parse_url__mutmut_35': x_parse_url__mutmut_35, 
    'x_parse_url__mutmut_36': x_parse_url__mutmut_36, 
    'x_parse_url__mutmut_37': x_parse_url__mutmut_37, 
    'x_parse_url__mutmut_38': x_parse_url__mutmut_38, 
    'x_parse_url__mutmut_39': x_parse_url__mutmut_39, 
    'x_parse_url__mutmut_40': x_parse_url__mutmut_40, 
    'x_parse_url__mutmut_41': x_parse_url__mutmut_41, 
    'x_parse_url__mutmut_42': x_parse_url__mutmut_42, 
    'x_parse_url__mutmut_43': x_parse_url__mutmut_43, 
    'x_parse_url__mutmut_44': x_parse_url__mutmut_44, 
    'x_parse_url__mutmut_45': x_parse_url__mutmut_45, 
    'x_parse_url__mutmut_46': x_parse_url__mutmut_46, 
    'x_parse_url__mutmut_47': x_parse_url__mutmut_47, 
    'x_parse_url__mutmut_48': x_parse_url__mutmut_48, 
    'x_parse_url__mutmut_49': x_parse_url__mutmut_49, 
    'x_parse_url__mutmut_50': x_parse_url__mutmut_50, 
    'x_parse_url__mutmut_51': x_parse_url__mutmut_51, 
    'x_parse_url__mutmut_52': x_parse_url__mutmut_52, 
    'x_parse_url__mutmut_53': x_parse_url__mutmut_53, 
    'x_parse_url__mutmut_54': x_parse_url__mutmut_54, 
    'x_parse_url__mutmut_55': x_parse_url__mutmut_55, 
    'x_parse_url__mutmut_56': x_parse_url__mutmut_56, 
    'x_parse_url__mutmut_57': x_parse_url__mutmut_57, 
    'x_parse_url__mutmut_58': x_parse_url__mutmut_58, 
    'x_parse_url__mutmut_59': x_parse_url__mutmut_59, 
    'x_parse_url__mutmut_60': x_parse_url__mutmut_60, 
    'x_parse_url__mutmut_61': x_parse_url__mutmut_61, 
    'x_parse_url__mutmut_62': x_parse_url__mutmut_62, 
    'x_parse_url__mutmut_63': x_parse_url__mutmut_63, 
    'x_parse_url__mutmut_64': x_parse_url__mutmut_64, 
    'x_parse_url__mutmut_65': x_parse_url__mutmut_65, 
    'x_parse_url__mutmut_66': x_parse_url__mutmut_66, 
    'x_parse_url__mutmut_67': x_parse_url__mutmut_67, 
    'x_parse_url__mutmut_68': x_parse_url__mutmut_68, 
    'x_parse_url__mutmut_69': x_parse_url__mutmut_69, 
    'x_parse_url__mutmut_70': x_parse_url__mutmut_70, 
    'x_parse_url__mutmut_71': x_parse_url__mutmut_71, 
    'x_parse_url__mutmut_72': x_parse_url__mutmut_72, 
    'x_parse_url__mutmut_73': x_parse_url__mutmut_73
}

def parse_url(*args, **kwargs):
    result = _mutmut_trampoline(x_parse_url__mutmut_orig, x_parse_url__mutmut_mutants, args, kwargs)
    return result 

parse_url.__signature__ = _mutmut_signature(x_parse_url__mutmut_orig)
x_parse_url__mutmut_orig.__name__ = 'x_parse_url'


DEFAULT_PARSED_URL = parse_url('')


def x_parse_qsl__mutmut_orig(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_1(qs, keep_blank_values=False, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_2(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = None
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_3(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split(None) for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_4(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('XX&XX') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_5(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(None)]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_6(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split('XX;XX')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_7(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = None
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_8(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_9(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            break
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_10(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = None
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_11(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition(None)
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_12(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.rpartition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_13(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('XX=XX')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_14(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_15(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = ""
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_16(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                break
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_17(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = None
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_18(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(None)
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_19(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace(None, ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_20(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', None))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_21(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace(' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_22(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_23(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('XX+XX', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_24(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', 'XX XX'))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_25(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = None
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_26(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(None)
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_27(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace(None, ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_28(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', None))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_29(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace(' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_30(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_31(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('XX+XX', ' '))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_32(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', 'XX XX'))
        ret.append((key, value))
    return ret


def x_parse_qsl__mutmut_33(qs, keep_blank_values=True, encoding=DEFAULT_ENCODING):
    """
    Converts a query string into a list of (key, value) pairs.
    """
    pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]
    ret = []
    for pair in pairs:
        if not pair:
            continue
        key, _, value = pair.partition('=')
        if not value:
            if keep_blank_values:
                value = None
            else:
                continue
        key = unquote(key.replace('+', ' '))
        if value:
            value = unquote(value.replace('+', ' '))
        ret.append(None)
    return ret

x_parse_qsl__mutmut_mutants : ClassVar[MutantDict] = {
'x_parse_qsl__mutmut_1': x_parse_qsl__mutmut_1, 
    'x_parse_qsl__mutmut_2': x_parse_qsl__mutmut_2, 
    'x_parse_qsl__mutmut_3': x_parse_qsl__mutmut_3, 
    'x_parse_qsl__mutmut_4': x_parse_qsl__mutmut_4, 
    'x_parse_qsl__mutmut_5': x_parse_qsl__mutmut_5, 
    'x_parse_qsl__mutmut_6': x_parse_qsl__mutmut_6, 
    'x_parse_qsl__mutmut_7': x_parse_qsl__mutmut_7, 
    'x_parse_qsl__mutmut_8': x_parse_qsl__mutmut_8, 
    'x_parse_qsl__mutmut_9': x_parse_qsl__mutmut_9, 
    'x_parse_qsl__mutmut_10': x_parse_qsl__mutmut_10, 
    'x_parse_qsl__mutmut_11': x_parse_qsl__mutmut_11, 
    'x_parse_qsl__mutmut_12': x_parse_qsl__mutmut_12, 
    'x_parse_qsl__mutmut_13': x_parse_qsl__mutmut_13, 
    'x_parse_qsl__mutmut_14': x_parse_qsl__mutmut_14, 
    'x_parse_qsl__mutmut_15': x_parse_qsl__mutmut_15, 
    'x_parse_qsl__mutmut_16': x_parse_qsl__mutmut_16, 
    'x_parse_qsl__mutmut_17': x_parse_qsl__mutmut_17, 
    'x_parse_qsl__mutmut_18': x_parse_qsl__mutmut_18, 
    'x_parse_qsl__mutmut_19': x_parse_qsl__mutmut_19, 
    'x_parse_qsl__mutmut_20': x_parse_qsl__mutmut_20, 
    'x_parse_qsl__mutmut_21': x_parse_qsl__mutmut_21, 
    'x_parse_qsl__mutmut_22': x_parse_qsl__mutmut_22, 
    'x_parse_qsl__mutmut_23': x_parse_qsl__mutmut_23, 
    'x_parse_qsl__mutmut_24': x_parse_qsl__mutmut_24, 
    'x_parse_qsl__mutmut_25': x_parse_qsl__mutmut_25, 
    'x_parse_qsl__mutmut_26': x_parse_qsl__mutmut_26, 
    'x_parse_qsl__mutmut_27': x_parse_qsl__mutmut_27, 
    'x_parse_qsl__mutmut_28': x_parse_qsl__mutmut_28, 
    'x_parse_qsl__mutmut_29': x_parse_qsl__mutmut_29, 
    'x_parse_qsl__mutmut_30': x_parse_qsl__mutmut_30, 
    'x_parse_qsl__mutmut_31': x_parse_qsl__mutmut_31, 
    'x_parse_qsl__mutmut_32': x_parse_qsl__mutmut_32, 
    'x_parse_qsl__mutmut_33': x_parse_qsl__mutmut_33
}

def parse_qsl(*args, **kwargs):
    result = _mutmut_trampoline(x_parse_qsl__mutmut_orig, x_parse_qsl__mutmut_mutants, args, kwargs)
    return result 

parse_qsl.__signature__ = _mutmut_signature(x_parse_qsl__mutmut_orig)
x_parse_qsl__mutmut_orig.__name__ = 'x_parse_qsl'


"""
# What follows is the OrderedMultiDict from dictutils.py, circa
# 20161021, used for the QueryParamDict, toward the bottom.
"""

from collections.abc import KeysView, ValuesView, ItemsView
from itertools import zip_longest

_MISSING = object()


PREV, NEXT, KEY, VALUE, SPREV, SNEXT = range(6)


class OrderedMultiDict(dict):
    """A MultiDict is a dictionary that can have multiple values per key
    and the OrderedMultiDict (OMD) is a MultiDict that retains
    original insertion order. Common use cases include:

      * handling query strings parsed from URLs
      * inverting a dictionary to create a reverse index (values to keys)
      * stacking data from multiple dictionaries in a non-destructive way

    The OrderedMultiDict constructor is identical to the built-in
    :class:`dict`, and overall the API constitutes an intuitive
    superset of the built-in type:

    >>> omd = OrderedMultiDict()
    >>> omd['a'] = 1
    >>> omd['b'] = 2
    >>> omd.add('a', 3)
    >>> omd.get('a')
    3
    >>> omd.getlist('a')
    [1, 3]

    Some non-:class:`dict`-like behaviors also make an appearance,
    such as support for :func:`reversed`:

    >>> list(reversed(omd))
    ['b', 'a']

    Note that unlike some other MultiDicts, this OMD gives precedence
    to the most recent value added. ``omd['a']`` refers to ``3``, not
    ``1``.

    >>> omd
    OrderedMultiDict([('a', 1), ('b', 2), ('a', 3)])
    >>> omd.poplast('a')
    3
    >>> omd
    OrderedMultiDict([('a', 1), ('b', 2)])
    >>> omd.pop('a')
    1
    >>> omd
    OrderedMultiDict([('b', 2)])

    If you want a safe-to-modify or flat dictionary, use
    :meth:`OrderedMultiDict.todict()`.

    >>> from pprint import pprint as pp  # preserve printed ordering
    >>> omd = OrderedMultiDict([('a', 1), ('b', 2), ('a', 3)])
    >>> pp(omd.todict())
    {'a': 3, 'b': 2}
    >>> pp(omd.todict(multi=True))
    {'a': [1, 3], 'b': [2]}

    With ``multi=False``, items appear with the keys in to original
    insertion order, alongside the most-recently inserted value for
    that key.

    >>> OrderedMultiDict([('a', 1), ('b', 2), ('a', 3)]).items(multi=False)
    [('a', 3), ('b', 2)]

    .. warning::

       ``dict(omd)`` changed behavior `in Python 3.7
       <https://bugs.python.org/issue34320>`_ due to changes made to
       support the transition from :class:`collections.OrderedDict` to
       the built-in dictionary being ordered. Before 3.7, the result
       would be a new dictionary, with values that were lists, similar
       to ``omd.todict(multi=True)`` (but only shallow-copy; the lists
       were direct references to OMD internal structures). From 3.7
       onward, the values became singular, like
       ``omd.todict(multi=False)``. For reliable cross-version
       behavior, just use :meth:`~OrderedMultiDict.todict()`.

    """
    def __new__(cls, *a, **kw):
        ret = super().__new__(cls)
        ret._clear_ll()
        return ret 
    
    def xǁOrderedMultiDictǁ__init____mutmut_orig(self, *args, **kwargs):
        if len(args) > 1:
            raise TypeError('%s expected at most 1 argument, got %s'
                            % (self.__class__.__name__, len(args)))
        super().__init__()

        if args:
            self.update_extend(args[0])
        if kwargs:
            self.update(kwargs)
    
    def xǁOrderedMultiDictǁ__init____mutmut_1(self, *args, **kwargs):
        if len(args) >= 1:
            raise TypeError('%s expected at most 1 argument, got %s'
                            % (self.__class__.__name__, len(args)))
        super().__init__()

        if args:
            self.update_extend(args[0])
        if kwargs:
            self.update(kwargs)
    
    def xǁOrderedMultiDictǁ__init____mutmut_2(self, *args, **kwargs):
        if len(args) > 2:
            raise TypeError('%s expected at most 1 argument, got %s'
                            % (self.__class__.__name__, len(args)))
        super().__init__()

        if args:
            self.update_extend(args[0])
        if kwargs:
            self.update(kwargs)
    
    def xǁOrderedMultiDictǁ__init____mutmut_3(self, *args, **kwargs):
        if len(args) > 1:
            raise TypeError(None)
        super().__init__()

        if args:
            self.update_extend(args[0])
        if kwargs:
            self.update(kwargs)
    
    def xǁOrderedMultiDictǁ__init____mutmut_4(self, *args, **kwargs):
        if len(args) > 1:
            raise TypeError('%s expected at most 1 argument, got %s' / (self.__class__.__name__, len(args)))
        super().__init__()

        if args:
            self.update_extend(args[0])
        if kwargs:
            self.update(kwargs)
    
    def xǁOrderedMultiDictǁ__init____mutmut_5(self, *args, **kwargs):
        if len(args) > 1:
            raise TypeError('XX%s expected at most 1 argument, got %sXX'
                            % (self.__class__.__name__, len(args)))
        super().__init__()

        if args:
            self.update_extend(args[0])
        if kwargs:
            self.update(kwargs)
    
    def xǁOrderedMultiDictǁ__init____mutmut_6(self, *args, **kwargs):
        if len(args) > 1:
            raise TypeError('%S EXPECTED AT MOST 1 ARGUMENT, GOT %S'
                            % (self.__class__.__name__, len(args)))
        super().__init__()

        if args:
            self.update_extend(args[0])
        if kwargs:
            self.update(kwargs)
    
    def xǁOrderedMultiDictǁ__init____mutmut_7(self, *args, **kwargs):
        if len(args) > 1:
            raise TypeError('%s expected at most 1 argument, got %s'
                            % (self.__class__.__name__, len(args)))
        super().__init__()

        if args:
            self.update_extend(None)
        if kwargs:
            self.update(kwargs)
    
    def xǁOrderedMultiDictǁ__init____mutmut_8(self, *args, **kwargs):
        if len(args) > 1:
            raise TypeError('%s expected at most 1 argument, got %s'
                            % (self.__class__.__name__, len(args)))
        super().__init__()

        if args:
            self.update_extend(args[1])
        if kwargs:
            self.update(kwargs)
    
    def xǁOrderedMultiDictǁ__init____mutmut_9(self, *args, **kwargs):
        if len(args) > 1:
            raise TypeError('%s expected at most 1 argument, got %s'
                            % (self.__class__.__name__, len(args)))
        super().__init__()

        if args:
            self.update_extend(args[0])
        if kwargs:
            self.update(None)
    
    xǁOrderedMultiDictǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__init____mutmut_1': xǁOrderedMultiDictǁ__init____mutmut_1, 
        'xǁOrderedMultiDictǁ__init____mutmut_2': xǁOrderedMultiDictǁ__init____mutmut_2, 
        'xǁOrderedMultiDictǁ__init____mutmut_3': xǁOrderedMultiDictǁ__init____mutmut_3, 
        'xǁOrderedMultiDictǁ__init____mutmut_4': xǁOrderedMultiDictǁ__init____mutmut_4, 
        'xǁOrderedMultiDictǁ__init____mutmut_5': xǁOrderedMultiDictǁ__init____mutmut_5, 
        'xǁOrderedMultiDictǁ__init____mutmut_6': xǁOrderedMultiDictǁ__init____mutmut_6, 
        'xǁOrderedMultiDictǁ__init____mutmut_7': xǁOrderedMultiDictǁ__init____mutmut_7, 
        'xǁOrderedMultiDictǁ__init____mutmut_8': xǁOrderedMultiDictǁ__init____mutmut_8, 
        'xǁOrderedMultiDictǁ__init____mutmut_9': xǁOrderedMultiDictǁ__init____mutmut_9
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__init____mutmut_orig)
    xǁOrderedMultiDictǁ__init____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__init__'

    def xǁOrderedMultiDictǁ__getstate____mutmut_orig(self):
        return list(self.iteritems(multi=True))

    def xǁOrderedMultiDictǁ__getstate____mutmut_1(self):
        return list(None)

    def xǁOrderedMultiDictǁ__getstate____mutmut_2(self):
        return list(self.iteritems(multi=None))

    def xǁOrderedMultiDictǁ__getstate____mutmut_3(self):
        return list(self.iteritems(multi=False))
    
    xǁOrderedMultiDictǁ__getstate____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__getstate____mutmut_1': xǁOrderedMultiDictǁ__getstate____mutmut_1, 
        'xǁOrderedMultiDictǁ__getstate____mutmut_2': xǁOrderedMultiDictǁ__getstate____mutmut_2, 
        'xǁOrderedMultiDictǁ__getstate____mutmut_3': xǁOrderedMultiDictǁ__getstate____mutmut_3
    }
    
    def __getstate__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__getstate____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__getstate____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __getstate__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__getstate____mutmut_orig)
    xǁOrderedMultiDictǁ__getstate____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__getstate__'

    def xǁOrderedMultiDictǁ__setstate____mutmut_orig(self, state):
        self.clear()
        self.update_extend(state)

    def xǁOrderedMultiDictǁ__setstate____mutmut_1(self, state):
        self.clear()
        self.update_extend(None)
    
    xǁOrderedMultiDictǁ__setstate____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__setstate____mutmut_1': xǁOrderedMultiDictǁ__setstate____mutmut_1
    }
    
    def __setstate__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__setstate____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__setstate____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __setstate__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__setstate____mutmut_orig)
    xǁOrderedMultiDictǁ__setstate____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__setstate__'

    def xǁOrderedMultiDictǁ_clear_ll__mutmut_orig(self):
        try:
            _map = self._map
        except AttributeError:
            _map = self._map = {}
            self.root = []
        _map.clear()
        self.root[:] = [self.root, self.root, None]

    def xǁOrderedMultiDictǁ_clear_ll__mutmut_1(self):
        try:
            _map = None
        except AttributeError:
            _map = self._map = {}
            self.root = []
        _map.clear()
        self.root[:] = [self.root, self.root, None]

    def xǁOrderedMultiDictǁ_clear_ll__mutmut_2(self):
        try:
            _map = self._map
        except AttributeError:
            _map = self._map = None
            self.root = []
        _map.clear()
        self.root[:] = [self.root, self.root, None]

    def xǁOrderedMultiDictǁ_clear_ll__mutmut_3(self):
        try:
            _map = self._map
        except AttributeError:
            _map = self._map = {}
            self.root = None
        _map.clear()
        self.root[:] = [self.root, self.root, None]

    def xǁOrderedMultiDictǁ_clear_ll__mutmut_4(self):
        try:
            _map = self._map
        except AttributeError:
            _map = self._map = {}
            self.root = []
        _map.clear()
        self.root[:] = None
    
    xǁOrderedMultiDictǁ_clear_ll__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ_clear_ll__mutmut_1': xǁOrderedMultiDictǁ_clear_ll__mutmut_1, 
        'xǁOrderedMultiDictǁ_clear_ll__mutmut_2': xǁOrderedMultiDictǁ_clear_ll__mutmut_2, 
        'xǁOrderedMultiDictǁ_clear_ll__mutmut_3': xǁOrderedMultiDictǁ_clear_ll__mutmut_3, 
        'xǁOrderedMultiDictǁ_clear_ll__mutmut_4': xǁOrderedMultiDictǁ_clear_ll__mutmut_4
    }
    
    def _clear_ll(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ_clear_ll__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ_clear_ll__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _clear_ll.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ_clear_ll__mutmut_orig)
    xǁOrderedMultiDictǁ_clear_ll__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ_clear_ll'

    def xǁOrderedMultiDictǁ_insert__mutmut_orig(self, k, v):
        root = self.root
        cells = self._map.setdefault(k, [])
        last = root[PREV]
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = cell
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_1(self, k, v):
        root = None
        cells = self._map.setdefault(k, [])
        last = root[PREV]
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = cell
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_2(self, k, v):
        root = self.root
        cells = None
        last = root[PREV]
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = cell
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_3(self, k, v):
        root = self.root
        cells = self._map.setdefault(None, [])
        last = root[PREV]
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = cell
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_4(self, k, v):
        root = self.root
        cells = self._map.setdefault(k, None)
        last = root[PREV]
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = cell
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_5(self, k, v):
        root = self.root
        cells = self._map.setdefault([])
        last = root[PREV]
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = cell
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_6(self, k, v):
        root = self.root
        cells = self._map.setdefault(k, )
        last = root[PREV]
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = cell
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_7(self, k, v):
        root = self.root
        cells = self._map.setdefault(k, [])
        last = None
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = cell
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_8(self, k, v):
        root = self.root
        cells = self._map.setdefault(k, [])
        last = root[PREV]
        cell = None
        last[NEXT] = root[PREV] = cell
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_9(self, k, v):
        root = self.root
        cells = self._map.setdefault(k, [])
        last = root[PREV]
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = None
        cells.append(cell)

    def xǁOrderedMultiDictǁ_insert__mutmut_10(self, k, v):
        root = self.root
        cells = self._map.setdefault(k, [])
        last = root[PREV]
        cell = [last, root, k, v]
        last[NEXT] = root[PREV] = cell
        cells.append(None)
    
    xǁOrderedMultiDictǁ_insert__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ_insert__mutmut_1': xǁOrderedMultiDictǁ_insert__mutmut_1, 
        'xǁOrderedMultiDictǁ_insert__mutmut_2': xǁOrderedMultiDictǁ_insert__mutmut_2, 
        'xǁOrderedMultiDictǁ_insert__mutmut_3': xǁOrderedMultiDictǁ_insert__mutmut_3, 
        'xǁOrderedMultiDictǁ_insert__mutmut_4': xǁOrderedMultiDictǁ_insert__mutmut_4, 
        'xǁOrderedMultiDictǁ_insert__mutmut_5': xǁOrderedMultiDictǁ_insert__mutmut_5, 
        'xǁOrderedMultiDictǁ_insert__mutmut_6': xǁOrderedMultiDictǁ_insert__mutmut_6, 
        'xǁOrderedMultiDictǁ_insert__mutmut_7': xǁOrderedMultiDictǁ_insert__mutmut_7, 
        'xǁOrderedMultiDictǁ_insert__mutmut_8': xǁOrderedMultiDictǁ_insert__mutmut_8, 
        'xǁOrderedMultiDictǁ_insert__mutmut_9': xǁOrderedMultiDictǁ_insert__mutmut_9, 
        'xǁOrderedMultiDictǁ_insert__mutmut_10': xǁOrderedMultiDictǁ_insert__mutmut_10
    }
    
    def _insert(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ_insert__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ_insert__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _insert.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ_insert__mutmut_orig)
    xǁOrderedMultiDictǁ_insert__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ_insert'

    def xǁOrderedMultiDictǁadd__mutmut_orig(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault(k, [])
        self._insert(k, v)
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_1(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = None
        self._insert(k, v)
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_2(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault(None, [])
        self._insert(k, v)
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_3(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault(k, None)
        self._insert(k, v)
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_4(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault([])
        self._insert(k, v)
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_5(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault(k, )
        self._insert(k, v)
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_6(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault(k, [])
        self._insert(None, v)
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_7(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault(k, [])
        self._insert(k, None)
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_8(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault(k, [])
        self._insert(v)
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_9(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault(k, [])
        self._insert(k, )
        values.append(v)

    def xǁOrderedMultiDictǁadd__mutmut_10(self, k, v):
        """Add a single value *v* under a key *k*. Existing values under *k*
        are preserved.
        """
        values = super().setdefault(k, [])
        self._insert(k, v)
        values.append(None)
    
    xǁOrderedMultiDictǁadd__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁadd__mutmut_1': xǁOrderedMultiDictǁadd__mutmut_1, 
        'xǁOrderedMultiDictǁadd__mutmut_2': xǁOrderedMultiDictǁadd__mutmut_2, 
        'xǁOrderedMultiDictǁadd__mutmut_3': xǁOrderedMultiDictǁadd__mutmut_3, 
        'xǁOrderedMultiDictǁadd__mutmut_4': xǁOrderedMultiDictǁadd__mutmut_4, 
        'xǁOrderedMultiDictǁadd__mutmut_5': xǁOrderedMultiDictǁadd__mutmut_5, 
        'xǁOrderedMultiDictǁadd__mutmut_6': xǁOrderedMultiDictǁadd__mutmut_6, 
        'xǁOrderedMultiDictǁadd__mutmut_7': xǁOrderedMultiDictǁadd__mutmut_7, 
        'xǁOrderedMultiDictǁadd__mutmut_8': xǁOrderedMultiDictǁadd__mutmut_8, 
        'xǁOrderedMultiDictǁadd__mutmut_9': xǁOrderedMultiDictǁadd__mutmut_9, 
        'xǁOrderedMultiDictǁadd__mutmut_10': xǁOrderedMultiDictǁadd__mutmut_10
    }
    
    def add(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁadd__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁadd__mutmut_mutants"), args, kwargs, self)
        return result 
    
    add.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁadd__mutmut_orig)
    xǁOrderedMultiDictǁadd__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁadd'

    def xǁOrderedMultiDictǁaddlist__mutmut_orig(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault(k, [])
        for subv in v:
            self_insert(k, subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_1(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if v:
            return
        self_insert = self._insert
        values = super().setdefault(k, [])
        for subv in v:
            self_insert(k, subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_2(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = None
        values = super().setdefault(k, [])
        for subv in v:
            self_insert(k, subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_3(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = None
        for subv in v:
            self_insert(k, subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_4(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault(None, [])
        for subv in v:
            self_insert(k, subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_5(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault(k, None)
        for subv in v:
            self_insert(k, subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_6(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault([])
        for subv in v:
            self_insert(k, subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_7(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault(k, )
        for subv in v:
            self_insert(k, subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_8(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault(k, [])
        for subv in v:
            self_insert(None, subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_9(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault(k, [])
        for subv in v:
            self_insert(k, None)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_10(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault(k, [])
        for subv in v:
            self_insert(subv)
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_11(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault(k, [])
        for subv in v:
            self_insert(k, )
        values.extend(v)

    def xǁOrderedMultiDictǁaddlist__mutmut_12(self, k, v):
        """Add an iterable of values underneath a specific key, preserving
        any values already under that key.

        >>> omd = OrderedMultiDict([('a', -1)])
        >>> omd.addlist('a', range(3))
        >>> omd
        OrderedMultiDict([('a', -1), ('a', 0), ('a', 1), ('a', 2)])

        Called ``addlist`` for consistency with :meth:`getlist`, but
        tuples and other sequences and iterables work.
        """
        if not v:
            return
        self_insert = self._insert
        values = super().setdefault(k, [])
        for subv in v:
            self_insert(k, subv)
        values.extend(None)
    
    xǁOrderedMultiDictǁaddlist__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁaddlist__mutmut_1': xǁOrderedMultiDictǁaddlist__mutmut_1, 
        'xǁOrderedMultiDictǁaddlist__mutmut_2': xǁOrderedMultiDictǁaddlist__mutmut_2, 
        'xǁOrderedMultiDictǁaddlist__mutmut_3': xǁOrderedMultiDictǁaddlist__mutmut_3, 
        'xǁOrderedMultiDictǁaddlist__mutmut_4': xǁOrderedMultiDictǁaddlist__mutmut_4, 
        'xǁOrderedMultiDictǁaddlist__mutmut_5': xǁOrderedMultiDictǁaddlist__mutmut_5, 
        'xǁOrderedMultiDictǁaddlist__mutmut_6': xǁOrderedMultiDictǁaddlist__mutmut_6, 
        'xǁOrderedMultiDictǁaddlist__mutmut_7': xǁOrderedMultiDictǁaddlist__mutmut_7, 
        'xǁOrderedMultiDictǁaddlist__mutmut_8': xǁOrderedMultiDictǁaddlist__mutmut_8, 
        'xǁOrderedMultiDictǁaddlist__mutmut_9': xǁOrderedMultiDictǁaddlist__mutmut_9, 
        'xǁOrderedMultiDictǁaddlist__mutmut_10': xǁOrderedMultiDictǁaddlist__mutmut_10, 
        'xǁOrderedMultiDictǁaddlist__mutmut_11': xǁOrderedMultiDictǁaddlist__mutmut_11, 
        'xǁOrderedMultiDictǁaddlist__mutmut_12': xǁOrderedMultiDictǁaddlist__mutmut_12
    }
    
    def addlist(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁaddlist__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁaddlist__mutmut_mutants"), args, kwargs, self)
        return result 
    
    addlist.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁaddlist__mutmut_orig)
    xǁOrderedMultiDictǁaddlist__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁaddlist'

    def xǁOrderedMultiDictǁget__mutmut_orig(self, k, default=None):
        """Return the value for key *k* if present in the dictionary, else
        *default*. If *default* is not given, ``None`` is returned.
        This method never raises a :exc:`KeyError`.

        To get all values under a key, use :meth:`OrderedMultiDict.getlist`.
        """
        return super().get(k, [default])[-1]

    def xǁOrderedMultiDictǁget__mutmut_1(self, k, default=None):
        """Return the value for key *k* if present in the dictionary, else
        *default*. If *default* is not given, ``None`` is returned.
        This method never raises a :exc:`KeyError`.

        To get all values under a key, use :meth:`OrderedMultiDict.getlist`.
        """
        return super().get(None, [default])[-1]

    def xǁOrderedMultiDictǁget__mutmut_2(self, k, default=None):
        """Return the value for key *k* if present in the dictionary, else
        *default*. If *default* is not given, ``None`` is returned.
        This method never raises a :exc:`KeyError`.

        To get all values under a key, use :meth:`OrderedMultiDict.getlist`.
        """
        return super().get(k, None)[-1]

    def xǁOrderedMultiDictǁget__mutmut_3(self, k, default=None):
        """Return the value for key *k* if present in the dictionary, else
        *default*. If *default* is not given, ``None`` is returned.
        This method never raises a :exc:`KeyError`.

        To get all values under a key, use :meth:`OrderedMultiDict.getlist`.
        """
        return super().get([default])[-1]

    def xǁOrderedMultiDictǁget__mutmut_4(self, k, default=None):
        """Return the value for key *k* if present in the dictionary, else
        *default*. If *default* is not given, ``None`` is returned.
        This method never raises a :exc:`KeyError`.

        To get all values under a key, use :meth:`OrderedMultiDict.getlist`.
        """
        return super().get(k, )[-1]

    def xǁOrderedMultiDictǁget__mutmut_5(self, k, default=None):
        """Return the value for key *k* if present in the dictionary, else
        *default*. If *default* is not given, ``None`` is returned.
        This method never raises a :exc:`KeyError`.

        To get all values under a key, use :meth:`OrderedMultiDict.getlist`.
        """
        return super().get(k, [default])[+1]

    def xǁOrderedMultiDictǁget__mutmut_6(self, k, default=None):
        """Return the value for key *k* if present in the dictionary, else
        *default*. If *default* is not given, ``None`` is returned.
        This method never raises a :exc:`KeyError`.

        To get all values under a key, use :meth:`OrderedMultiDict.getlist`.
        """
        return super().get(k, [default])[-2]
    
    xǁOrderedMultiDictǁget__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁget__mutmut_1': xǁOrderedMultiDictǁget__mutmut_1, 
        'xǁOrderedMultiDictǁget__mutmut_2': xǁOrderedMultiDictǁget__mutmut_2, 
        'xǁOrderedMultiDictǁget__mutmut_3': xǁOrderedMultiDictǁget__mutmut_3, 
        'xǁOrderedMultiDictǁget__mutmut_4': xǁOrderedMultiDictǁget__mutmut_4, 
        'xǁOrderedMultiDictǁget__mutmut_5': xǁOrderedMultiDictǁget__mutmut_5, 
        'xǁOrderedMultiDictǁget__mutmut_6': xǁOrderedMultiDictǁget__mutmut_6
    }
    
    def get(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁget__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁget__mutmut_mutants"), args, kwargs, self)
        return result 
    
    get.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁget__mutmut_orig)
    xǁOrderedMultiDictǁget__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁget'

    def xǁOrderedMultiDictǁgetlist__mutmut_orig(self, k, default=_MISSING):
        """Get all values for key *k* as a list, if *k* is in the
        dictionary, else *default*. The list returned is a copy and
        can be safely mutated. If *default* is not given, an empty
        :class:`list` is returned.
        """
        try:
            return super().__getitem__(k)[:]
        except KeyError:
            if default is _MISSING:
                return []
            return default

    def xǁOrderedMultiDictǁgetlist__mutmut_1(self, k, default=_MISSING):
        """Get all values for key *k* as a list, if *k* is in the
        dictionary, else *default*. The list returned is a copy and
        can be safely mutated. If *default* is not given, an empty
        :class:`list` is returned.
        """
        try:
            return super().__getitem__(None)[:]
        except KeyError:
            if default is _MISSING:
                return []
            return default

    def xǁOrderedMultiDictǁgetlist__mutmut_2(self, k, default=_MISSING):
        """Get all values for key *k* as a list, if *k* is in the
        dictionary, else *default*. The list returned is a copy and
        can be safely mutated. If *default* is not given, an empty
        :class:`list` is returned.
        """
        try:
            return super().__getitem__(k)[:]
        except KeyError:
            if default is not _MISSING:
                return []
            return default
    
    xǁOrderedMultiDictǁgetlist__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁgetlist__mutmut_1': xǁOrderedMultiDictǁgetlist__mutmut_1, 
        'xǁOrderedMultiDictǁgetlist__mutmut_2': xǁOrderedMultiDictǁgetlist__mutmut_2
    }
    
    def getlist(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁgetlist__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁgetlist__mutmut_mutants"), args, kwargs, self)
        return result 
    
    getlist.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁgetlist__mutmut_orig)
    xǁOrderedMultiDictǁgetlist__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁgetlist'

    def xǁOrderedMultiDictǁclear__mutmut_orig(self):
        "Empty the dictionary."
        super().clear()
        self._clear_ll()

    def xǁOrderedMultiDictǁclear__mutmut_1(self):
        "XXEmpty the dictionary.XX"
        super().clear()
        self._clear_ll()

    def xǁOrderedMultiDictǁclear__mutmut_2(self):
        "empty the dictionary."
        super().clear()
        self._clear_ll()

    def xǁOrderedMultiDictǁclear__mutmut_3(self):
        "EMPTY THE DICTIONARY."
        super().clear()
        self._clear_ll()
    
    xǁOrderedMultiDictǁclear__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁclear__mutmut_1': xǁOrderedMultiDictǁclear__mutmut_1, 
        'xǁOrderedMultiDictǁclear__mutmut_2': xǁOrderedMultiDictǁclear__mutmut_2, 
        'xǁOrderedMultiDictǁclear__mutmut_3': xǁOrderedMultiDictǁclear__mutmut_3
    }
    
    def clear(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁclear__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁclear__mutmut_mutants"), args, kwargs, self)
        return result 
    
    clear.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁclear__mutmut_orig)
    xǁOrderedMultiDictǁclear__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁclear'

    def xǁOrderedMultiDictǁsetdefault__mutmut_orig(self, k, default=_MISSING):
        """If key *k* is in the dictionary, return its value. If not, insert
        *k* with a value of *default* and return *default*. *default*
        defaults to ``None``. See :meth:`dict.setdefault` for more
        information.
        """
        if not super().__contains__(k):
            self[k] = None if default is _MISSING else default
        return self[k]

    def xǁOrderedMultiDictǁsetdefault__mutmut_1(self, k, default=_MISSING):
        """If key *k* is in the dictionary, return its value. If not, insert
        *k* with a value of *default* and return *default*. *default*
        defaults to ``None``. See :meth:`dict.setdefault` for more
        information.
        """
        if super().__contains__(k):
            self[k] = None if default is _MISSING else default
        return self[k]

    def xǁOrderedMultiDictǁsetdefault__mutmut_2(self, k, default=_MISSING):
        """If key *k* is in the dictionary, return its value. If not, insert
        *k* with a value of *default* and return *default*. *default*
        defaults to ``None``. See :meth:`dict.setdefault` for more
        information.
        """
        if not super().__contains__(None):
            self[k] = None if default is _MISSING else default
        return self[k]

    def xǁOrderedMultiDictǁsetdefault__mutmut_3(self, k, default=_MISSING):
        """If key *k* is in the dictionary, return its value. If not, insert
        *k* with a value of *default* and return *default*. *default*
        defaults to ``None``. See :meth:`dict.setdefault` for more
        information.
        """
        if not super().__contains__(k):
            self[k] = None
        return self[k]

    def xǁOrderedMultiDictǁsetdefault__mutmut_4(self, k, default=_MISSING):
        """If key *k* is in the dictionary, return its value. If not, insert
        *k* with a value of *default* and return *default*. *default*
        defaults to ``None``. See :meth:`dict.setdefault` for more
        information.
        """
        if not super().__contains__(k):
            self[k] = None if default is not _MISSING else default
        return self[k]
    
    xǁOrderedMultiDictǁsetdefault__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁsetdefault__mutmut_1': xǁOrderedMultiDictǁsetdefault__mutmut_1, 
        'xǁOrderedMultiDictǁsetdefault__mutmut_2': xǁOrderedMultiDictǁsetdefault__mutmut_2, 
        'xǁOrderedMultiDictǁsetdefault__mutmut_3': xǁOrderedMultiDictǁsetdefault__mutmut_3, 
        'xǁOrderedMultiDictǁsetdefault__mutmut_4': xǁOrderedMultiDictǁsetdefault__mutmut_4
    }
    
    def setdefault(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁsetdefault__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁsetdefault__mutmut_mutants"), args, kwargs, self)
        return result 
    
    setdefault.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁsetdefault__mutmut_orig)
    xǁOrderedMultiDictǁsetdefault__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁsetdefault'

    def xǁOrderedMultiDictǁcopy__mutmut_orig(self):
        "Return a shallow copy of the dictionary."
        return self.__class__(self.iteritems(multi=True))

    def xǁOrderedMultiDictǁcopy__mutmut_1(self):
        "XXReturn a shallow copy of the dictionary.XX"
        return self.__class__(self.iteritems(multi=True))

    def xǁOrderedMultiDictǁcopy__mutmut_2(self):
        "return a shallow copy of the dictionary."
        return self.__class__(self.iteritems(multi=True))

    def xǁOrderedMultiDictǁcopy__mutmut_3(self):
        "RETURN A SHALLOW COPY OF THE DICTIONARY."
        return self.__class__(self.iteritems(multi=True))

    def xǁOrderedMultiDictǁcopy__mutmut_4(self):
        "Return a shallow copy of the dictionary."
        return self.__class__(None)

    def xǁOrderedMultiDictǁcopy__mutmut_5(self):
        "Return a shallow copy of the dictionary."
        return self.__class__(self.iteritems(multi=None))

    def xǁOrderedMultiDictǁcopy__mutmut_6(self):
        "Return a shallow copy of the dictionary."
        return self.__class__(self.iteritems(multi=False))
    
    xǁOrderedMultiDictǁcopy__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁcopy__mutmut_1': xǁOrderedMultiDictǁcopy__mutmut_1, 
        'xǁOrderedMultiDictǁcopy__mutmut_2': xǁOrderedMultiDictǁcopy__mutmut_2, 
        'xǁOrderedMultiDictǁcopy__mutmut_3': xǁOrderedMultiDictǁcopy__mutmut_3, 
        'xǁOrderedMultiDictǁcopy__mutmut_4': xǁOrderedMultiDictǁcopy__mutmut_4, 
        'xǁOrderedMultiDictǁcopy__mutmut_5': xǁOrderedMultiDictǁcopy__mutmut_5, 
        'xǁOrderedMultiDictǁcopy__mutmut_6': xǁOrderedMultiDictǁcopy__mutmut_6
    }
    
    def copy(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁcopy__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁcopy__mutmut_mutants"), args, kwargs, self)
        return result 
    
    copy.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁcopy__mutmut_orig)
    xǁOrderedMultiDictǁcopy__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁcopy'

    @classmethod
    def fromkeys(cls, keys, default=None):
        """Create a dictionary from a list of keys, with all the values
        set to *default*, or ``None`` if *default* is not set.
        """
        return cls([(k, default) for k in keys])

    def xǁOrderedMultiDictǁupdate__mutmut_orig(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_1(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is not self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_2(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = None
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_3(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k not in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_4(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=None):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_5(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=False):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_6(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(None, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_7(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, None)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_8(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_9(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, )
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_10(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(None):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_11(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(None, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_12(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, None, None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_13(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr('keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_14(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_15(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', )):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_16(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'XXkeysXX', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_17(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'KEYS', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_18(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = None
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_19(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = None
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_20(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = None
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_21(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen or k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_22(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_23(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k not in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_24(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(None)
                self_add(k, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_25(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(None, v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_26(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, None)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_27(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(v)
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_28(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, )
        for k in F:
            self[k] = F[k]
        return

    def xǁOrderedMultiDictǁupdate__mutmut_29(self, E, **F):
        """Add items from a dictionary or iterable (and/or keyword arguments),
        overwriting values under an existing key. See
        :meth:`dict.update` for more details.
        """
        # E and F are throwback names to the dict() __doc__
        if E is self:
            return
        self_add = self.add
        if isinstance(E, OrderedMultiDict):
            for k in E:
                if k in self:
                    del self[k]
            for k, v in E.iteritems(multi=True):
                self_add(k, v)
        elif callable(getattr(E, 'keys', None)):
            for k in E.keys():
                self[k] = E[k]
        else:
            seen = set()
            seen_add = seen.add
            for k, v in E:
                if k not in seen and k in self:
                    del self[k]
                    seen_add(k)
                self_add(k, v)
        for k in F:
            self[k] = None
        return
    
    xǁOrderedMultiDictǁupdate__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁupdate__mutmut_1': xǁOrderedMultiDictǁupdate__mutmut_1, 
        'xǁOrderedMultiDictǁupdate__mutmut_2': xǁOrderedMultiDictǁupdate__mutmut_2, 
        'xǁOrderedMultiDictǁupdate__mutmut_3': xǁOrderedMultiDictǁupdate__mutmut_3, 
        'xǁOrderedMultiDictǁupdate__mutmut_4': xǁOrderedMultiDictǁupdate__mutmut_4, 
        'xǁOrderedMultiDictǁupdate__mutmut_5': xǁOrderedMultiDictǁupdate__mutmut_5, 
        'xǁOrderedMultiDictǁupdate__mutmut_6': xǁOrderedMultiDictǁupdate__mutmut_6, 
        'xǁOrderedMultiDictǁupdate__mutmut_7': xǁOrderedMultiDictǁupdate__mutmut_7, 
        'xǁOrderedMultiDictǁupdate__mutmut_8': xǁOrderedMultiDictǁupdate__mutmut_8, 
        'xǁOrderedMultiDictǁupdate__mutmut_9': xǁOrderedMultiDictǁupdate__mutmut_9, 
        'xǁOrderedMultiDictǁupdate__mutmut_10': xǁOrderedMultiDictǁupdate__mutmut_10, 
        'xǁOrderedMultiDictǁupdate__mutmut_11': xǁOrderedMultiDictǁupdate__mutmut_11, 
        'xǁOrderedMultiDictǁupdate__mutmut_12': xǁOrderedMultiDictǁupdate__mutmut_12, 
        'xǁOrderedMultiDictǁupdate__mutmut_13': xǁOrderedMultiDictǁupdate__mutmut_13, 
        'xǁOrderedMultiDictǁupdate__mutmut_14': xǁOrderedMultiDictǁupdate__mutmut_14, 
        'xǁOrderedMultiDictǁupdate__mutmut_15': xǁOrderedMultiDictǁupdate__mutmut_15, 
        'xǁOrderedMultiDictǁupdate__mutmut_16': xǁOrderedMultiDictǁupdate__mutmut_16, 
        'xǁOrderedMultiDictǁupdate__mutmut_17': xǁOrderedMultiDictǁupdate__mutmut_17, 
        'xǁOrderedMultiDictǁupdate__mutmut_18': xǁOrderedMultiDictǁupdate__mutmut_18, 
        'xǁOrderedMultiDictǁupdate__mutmut_19': xǁOrderedMultiDictǁupdate__mutmut_19, 
        'xǁOrderedMultiDictǁupdate__mutmut_20': xǁOrderedMultiDictǁupdate__mutmut_20, 
        'xǁOrderedMultiDictǁupdate__mutmut_21': xǁOrderedMultiDictǁupdate__mutmut_21, 
        'xǁOrderedMultiDictǁupdate__mutmut_22': xǁOrderedMultiDictǁupdate__mutmut_22, 
        'xǁOrderedMultiDictǁupdate__mutmut_23': xǁOrderedMultiDictǁupdate__mutmut_23, 
        'xǁOrderedMultiDictǁupdate__mutmut_24': xǁOrderedMultiDictǁupdate__mutmut_24, 
        'xǁOrderedMultiDictǁupdate__mutmut_25': xǁOrderedMultiDictǁupdate__mutmut_25, 
        'xǁOrderedMultiDictǁupdate__mutmut_26': xǁOrderedMultiDictǁupdate__mutmut_26, 
        'xǁOrderedMultiDictǁupdate__mutmut_27': xǁOrderedMultiDictǁupdate__mutmut_27, 
        'xǁOrderedMultiDictǁupdate__mutmut_28': xǁOrderedMultiDictǁupdate__mutmut_28, 
        'xǁOrderedMultiDictǁupdate__mutmut_29': xǁOrderedMultiDictǁupdate__mutmut_29
    }
    
    def update(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁupdate__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁupdate__mutmut_mutants"), args, kwargs, self)
        return result 
    
    update.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁupdate__mutmut_orig)
    xǁOrderedMultiDictǁupdate__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁupdate'

    def xǁOrderedMultiDictǁupdate_extend__mutmut_orig(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_1(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is not self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_2(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = None
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_3(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(None)
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_4(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = None
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_5(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=None)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_6(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=False)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_7(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(None, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_8(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, None):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_9(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr('keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_10(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, ):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_11(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'XXkeysXX'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_12(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'KEYS'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_13(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = None
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_14(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = None

        self_add = self.add
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_15(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = None
        for k, v in iterator:
            self_add(k, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_16(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(None, v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_17(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, None)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_18(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(v)

    def xǁOrderedMultiDictǁupdate_extend__mutmut_19(self, E, **F):
        """Add items from a dictionary, iterable, and/or keyword
        arguments without overwriting existing items present in the
        dictionary. Like :meth:`update`, but adds to existing keys
        instead of overwriting them.
        """
        if E is self:
            iterator = iter(E.items())
        elif isinstance(E, OrderedMultiDict):
            iterator = E.iteritems(multi=True)
        elif hasattr(E, 'keys'):
            iterator = ((k, E[k]) for k in E.keys())
        else:
            iterator = E

        self_add = self.add
        for k, v in iterator:
            self_add(k, )
    
    xǁOrderedMultiDictǁupdate_extend__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁupdate_extend__mutmut_1': xǁOrderedMultiDictǁupdate_extend__mutmut_1, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_2': xǁOrderedMultiDictǁupdate_extend__mutmut_2, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_3': xǁOrderedMultiDictǁupdate_extend__mutmut_3, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_4': xǁOrderedMultiDictǁupdate_extend__mutmut_4, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_5': xǁOrderedMultiDictǁupdate_extend__mutmut_5, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_6': xǁOrderedMultiDictǁupdate_extend__mutmut_6, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_7': xǁOrderedMultiDictǁupdate_extend__mutmut_7, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_8': xǁOrderedMultiDictǁupdate_extend__mutmut_8, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_9': xǁOrderedMultiDictǁupdate_extend__mutmut_9, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_10': xǁOrderedMultiDictǁupdate_extend__mutmut_10, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_11': xǁOrderedMultiDictǁupdate_extend__mutmut_11, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_12': xǁOrderedMultiDictǁupdate_extend__mutmut_12, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_13': xǁOrderedMultiDictǁupdate_extend__mutmut_13, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_14': xǁOrderedMultiDictǁupdate_extend__mutmut_14, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_15': xǁOrderedMultiDictǁupdate_extend__mutmut_15, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_16': xǁOrderedMultiDictǁupdate_extend__mutmut_16, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_17': xǁOrderedMultiDictǁupdate_extend__mutmut_17, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_18': xǁOrderedMultiDictǁupdate_extend__mutmut_18, 
        'xǁOrderedMultiDictǁupdate_extend__mutmut_19': xǁOrderedMultiDictǁupdate_extend__mutmut_19
    }
    
    def update_extend(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁupdate_extend__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁupdate_extend__mutmut_mutants"), args, kwargs, self)
        return result 
    
    update_extend.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁupdate_extend__mutmut_orig)
    xǁOrderedMultiDictǁupdate_extend__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁupdate_extend'

    def xǁOrderedMultiDictǁ__setitem____mutmut_orig(self, k, v):
        if super().__contains__(k):
            self._remove_all(k)
        self._insert(k, v)
        super().__setitem__(k, [v])

    def xǁOrderedMultiDictǁ__setitem____mutmut_1(self, k, v):
        if super().__contains__(None):
            self._remove_all(k)
        self._insert(k, v)
        super().__setitem__(k, [v])

    def xǁOrderedMultiDictǁ__setitem____mutmut_2(self, k, v):
        if super().__contains__(k):
            self._remove_all(None)
        self._insert(k, v)
        super().__setitem__(k, [v])

    def xǁOrderedMultiDictǁ__setitem____mutmut_3(self, k, v):
        if super().__contains__(k):
            self._remove_all(k)
        self._insert(None, v)
        super().__setitem__(k, [v])

    def xǁOrderedMultiDictǁ__setitem____mutmut_4(self, k, v):
        if super().__contains__(k):
            self._remove_all(k)
        self._insert(k, None)
        super().__setitem__(k, [v])

    def xǁOrderedMultiDictǁ__setitem____mutmut_5(self, k, v):
        if super().__contains__(k):
            self._remove_all(k)
        self._insert(v)
        super().__setitem__(k, [v])

    def xǁOrderedMultiDictǁ__setitem____mutmut_6(self, k, v):
        if super().__contains__(k):
            self._remove_all(k)
        self._insert(k, )
        super().__setitem__(k, [v])

    def xǁOrderedMultiDictǁ__setitem____mutmut_7(self, k, v):
        if super().__contains__(k):
            self._remove_all(k)
        self._insert(k, v)
        super().__setitem__(None, [v])

    def xǁOrderedMultiDictǁ__setitem____mutmut_8(self, k, v):
        if super().__contains__(k):
            self._remove_all(k)
        self._insert(k, v)
        super().__setitem__(k, None)

    def xǁOrderedMultiDictǁ__setitem____mutmut_9(self, k, v):
        if super().__contains__(k):
            self._remove_all(k)
        self._insert(k, v)
        super().__setitem__([v])

    def xǁOrderedMultiDictǁ__setitem____mutmut_10(self, k, v):
        if super().__contains__(k):
            self._remove_all(k)
        self._insert(k, v)
        super().__setitem__(k, )
    
    xǁOrderedMultiDictǁ__setitem____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__setitem____mutmut_1': xǁOrderedMultiDictǁ__setitem____mutmut_1, 
        'xǁOrderedMultiDictǁ__setitem____mutmut_2': xǁOrderedMultiDictǁ__setitem____mutmut_2, 
        'xǁOrderedMultiDictǁ__setitem____mutmut_3': xǁOrderedMultiDictǁ__setitem____mutmut_3, 
        'xǁOrderedMultiDictǁ__setitem____mutmut_4': xǁOrderedMultiDictǁ__setitem____mutmut_4, 
        'xǁOrderedMultiDictǁ__setitem____mutmut_5': xǁOrderedMultiDictǁ__setitem____mutmut_5, 
        'xǁOrderedMultiDictǁ__setitem____mutmut_6': xǁOrderedMultiDictǁ__setitem____mutmut_6, 
        'xǁOrderedMultiDictǁ__setitem____mutmut_7': xǁOrderedMultiDictǁ__setitem____mutmut_7, 
        'xǁOrderedMultiDictǁ__setitem____mutmut_8': xǁOrderedMultiDictǁ__setitem____mutmut_8, 
        'xǁOrderedMultiDictǁ__setitem____mutmut_9': xǁOrderedMultiDictǁ__setitem____mutmut_9, 
        'xǁOrderedMultiDictǁ__setitem____mutmut_10': xǁOrderedMultiDictǁ__setitem____mutmut_10
    }
    
    def __setitem__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__setitem____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__setitem____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __setitem__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__setitem____mutmut_orig)
    xǁOrderedMultiDictǁ__setitem____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__setitem__'

    def xǁOrderedMultiDictǁ__getitem____mutmut_orig(self, k):
        return super().__getitem__(k)[-1]

    def xǁOrderedMultiDictǁ__getitem____mutmut_1(self, k):
        return super().__getitem__(None)[-1]

    def xǁOrderedMultiDictǁ__getitem____mutmut_2(self, k):
        return super().__getitem__(k)[+1]

    def xǁOrderedMultiDictǁ__getitem____mutmut_3(self, k):
        return super().__getitem__(k)[-2]
    
    xǁOrderedMultiDictǁ__getitem____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__getitem____mutmut_1': xǁOrderedMultiDictǁ__getitem____mutmut_1, 
        'xǁOrderedMultiDictǁ__getitem____mutmut_2': xǁOrderedMultiDictǁ__getitem____mutmut_2, 
        'xǁOrderedMultiDictǁ__getitem____mutmut_3': xǁOrderedMultiDictǁ__getitem____mutmut_3
    }
    
    def __getitem__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__getitem____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__getitem____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __getitem__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__getitem____mutmut_orig)
    xǁOrderedMultiDictǁ__getitem____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__getitem__'

    def xǁOrderedMultiDictǁ__delitem____mutmut_orig(self, k):
        super().__delitem__(k)
        self._remove_all(k)

    def xǁOrderedMultiDictǁ__delitem____mutmut_1(self, k):
        super().__delitem__(None)
        self._remove_all(k)

    def xǁOrderedMultiDictǁ__delitem____mutmut_2(self, k):
        super().__delitem__(k)
        self._remove_all(None)
    
    xǁOrderedMultiDictǁ__delitem____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__delitem____mutmut_1': xǁOrderedMultiDictǁ__delitem____mutmut_1, 
        'xǁOrderedMultiDictǁ__delitem____mutmut_2': xǁOrderedMultiDictǁ__delitem____mutmut_2
    }
    
    def __delitem__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__delitem____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__delitem____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __delitem__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__delitem____mutmut_orig)
    xǁOrderedMultiDictǁ__delitem____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__delitem__'

    def xǁOrderedMultiDictǁ__eq____mutmut_orig(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_1(self, other):
        if self is not other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_2(self, other):
        if self is other:
            return False
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_3(self, other):
        if self is other:
            return True
        try:
            if len(other) == len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_4(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return True
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_5(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return True
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_6(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = None
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_7(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=None)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_8(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=False)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_9(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = None
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_10(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=None)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_11(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=False)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_12(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = None
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_13(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(None, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_14(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, None, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_15(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=None)
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_16(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_17(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_18(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, )
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_19(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk and selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_20(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk == otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_21(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv == otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_22(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return True
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_23(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if (next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_24(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING or next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_25(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(None, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_26(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, None) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_27(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(_MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_28(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, ) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_29(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is not _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_30(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(None, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_31(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, None) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_32(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(_MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_33(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, ) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_34(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is not _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_35(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return True
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_36(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return False
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_37(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(None, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_38(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, None):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_39(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr('keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_40(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, ):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_41(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'XXkeysXX'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_42(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'KEYS'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_43(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] != self[selfk]
                except KeyError:
                    return False
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_44(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return True
            return True
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_45(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return False
        return False

    def xǁOrderedMultiDictǁ__eq____mutmut_46(self, other):
        if self is other:
            return True
        try:
            if len(other) != len(self):
                return False
        except TypeError:
            return False
        if isinstance(other, OrderedMultiDict):
            selfi = self.iteritems(multi=True)
            otheri = other.iteritems(multi=True)
            zipped_items = zip_longest(selfi, otheri, fillvalue=(None, None))
            for (selfk, selfv), (otherk, otherv) in zipped_items:
                if selfk != otherk or selfv != otherv:
                    return False
            if not(next(selfi, _MISSING) is _MISSING
                   and next(otheri, _MISSING) is _MISSING):
                # leftovers  (TODO: watch for StopIteration?)
                return False
            return True
        elif hasattr(other, 'keys'):
            for selfk in self:
                try:
                    other[selfk] == self[selfk]
                except KeyError:
                    return False
            return True
        return True
    
    xǁOrderedMultiDictǁ__eq____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__eq____mutmut_1': xǁOrderedMultiDictǁ__eq____mutmut_1, 
        'xǁOrderedMultiDictǁ__eq____mutmut_2': xǁOrderedMultiDictǁ__eq____mutmut_2, 
        'xǁOrderedMultiDictǁ__eq____mutmut_3': xǁOrderedMultiDictǁ__eq____mutmut_3, 
        'xǁOrderedMultiDictǁ__eq____mutmut_4': xǁOrderedMultiDictǁ__eq____mutmut_4, 
        'xǁOrderedMultiDictǁ__eq____mutmut_5': xǁOrderedMultiDictǁ__eq____mutmut_5, 
        'xǁOrderedMultiDictǁ__eq____mutmut_6': xǁOrderedMultiDictǁ__eq____mutmut_6, 
        'xǁOrderedMultiDictǁ__eq____mutmut_7': xǁOrderedMultiDictǁ__eq____mutmut_7, 
        'xǁOrderedMultiDictǁ__eq____mutmut_8': xǁOrderedMultiDictǁ__eq____mutmut_8, 
        'xǁOrderedMultiDictǁ__eq____mutmut_9': xǁOrderedMultiDictǁ__eq____mutmut_9, 
        'xǁOrderedMultiDictǁ__eq____mutmut_10': xǁOrderedMultiDictǁ__eq____mutmut_10, 
        'xǁOrderedMultiDictǁ__eq____mutmut_11': xǁOrderedMultiDictǁ__eq____mutmut_11, 
        'xǁOrderedMultiDictǁ__eq____mutmut_12': xǁOrderedMultiDictǁ__eq____mutmut_12, 
        'xǁOrderedMultiDictǁ__eq____mutmut_13': xǁOrderedMultiDictǁ__eq____mutmut_13, 
        'xǁOrderedMultiDictǁ__eq____mutmut_14': xǁOrderedMultiDictǁ__eq____mutmut_14, 
        'xǁOrderedMultiDictǁ__eq____mutmut_15': xǁOrderedMultiDictǁ__eq____mutmut_15, 
        'xǁOrderedMultiDictǁ__eq____mutmut_16': xǁOrderedMultiDictǁ__eq____mutmut_16, 
        'xǁOrderedMultiDictǁ__eq____mutmut_17': xǁOrderedMultiDictǁ__eq____mutmut_17, 
        'xǁOrderedMultiDictǁ__eq____mutmut_18': xǁOrderedMultiDictǁ__eq____mutmut_18, 
        'xǁOrderedMultiDictǁ__eq____mutmut_19': xǁOrderedMultiDictǁ__eq____mutmut_19, 
        'xǁOrderedMultiDictǁ__eq____mutmut_20': xǁOrderedMultiDictǁ__eq____mutmut_20, 
        'xǁOrderedMultiDictǁ__eq____mutmut_21': xǁOrderedMultiDictǁ__eq____mutmut_21, 
        'xǁOrderedMultiDictǁ__eq____mutmut_22': xǁOrderedMultiDictǁ__eq____mutmut_22, 
        'xǁOrderedMultiDictǁ__eq____mutmut_23': xǁOrderedMultiDictǁ__eq____mutmut_23, 
        'xǁOrderedMultiDictǁ__eq____mutmut_24': xǁOrderedMultiDictǁ__eq____mutmut_24, 
        'xǁOrderedMultiDictǁ__eq____mutmut_25': xǁOrderedMultiDictǁ__eq____mutmut_25, 
        'xǁOrderedMultiDictǁ__eq____mutmut_26': xǁOrderedMultiDictǁ__eq____mutmut_26, 
        'xǁOrderedMultiDictǁ__eq____mutmut_27': xǁOrderedMultiDictǁ__eq____mutmut_27, 
        'xǁOrderedMultiDictǁ__eq____mutmut_28': xǁOrderedMultiDictǁ__eq____mutmut_28, 
        'xǁOrderedMultiDictǁ__eq____mutmut_29': xǁOrderedMultiDictǁ__eq____mutmut_29, 
        'xǁOrderedMultiDictǁ__eq____mutmut_30': xǁOrderedMultiDictǁ__eq____mutmut_30, 
        'xǁOrderedMultiDictǁ__eq____mutmut_31': xǁOrderedMultiDictǁ__eq____mutmut_31, 
        'xǁOrderedMultiDictǁ__eq____mutmut_32': xǁOrderedMultiDictǁ__eq____mutmut_32, 
        'xǁOrderedMultiDictǁ__eq____mutmut_33': xǁOrderedMultiDictǁ__eq____mutmut_33, 
        'xǁOrderedMultiDictǁ__eq____mutmut_34': xǁOrderedMultiDictǁ__eq____mutmut_34, 
        'xǁOrderedMultiDictǁ__eq____mutmut_35': xǁOrderedMultiDictǁ__eq____mutmut_35, 
        'xǁOrderedMultiDictǁ__eq____mutmut_36': xǁOrderedMultiDictǁ__eq____mutmut_36, 
        'xǁOrderedMultiDictǁ__eq____mutmut_37': xǁOrderedMultiDictǁ__eq____mutmut_37, 
        'xǁOrderedMultiDictǁ__eq____mutmut_38': xǁOrderedMultiDictǁ__eq____mutmut_38, 
        'xǁOrderedMultiDictǁ__eq____mutmut_39': xǁOrderedMultiDictǁ__eq____mutmut_39, 
        'xǁOrderedMultiDictǁ__eq____mutmut_40': xǁOrderedMultiDictǁ__eq____mutmut_40, 
        'xǁOrderedMultiDictǁ__eq____mutmut_41': xǁOrderedMultiDictǁ__eq____mutmut_41, 
        'xǁOrderedMultiDictǁ__eq____mutmut_42': xǁOrderedMultiDictǁ__eq____mutmut_42, 
        'xǁOrderedMultiDictǁ__eq____mutmut_43': xǁOrderedMultiDictǁ__eq____mutmut_43, 
        'xǁOrderedMultiDictǁ__eq____mutmut_44': xǁOrderedMultiDictǁ__eq____mutmut_44, 
        'xǁOrderedMultiDictǁ__eq____mutmut_45': xǁOrderedMultiDictǁ__eq____mutmut_45, 
        'xǁOrderedMultiDictǁ__eq____mutmut_46': xǁOrderedMultiDictǁ__eq____mutmut_46
    }
    
    def __eq__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__eq____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__eq____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __eq__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__eq____mutmut_orig)
    xǁOrderedMultiDictǁ__eq____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__eq__'

    def xǁOrderedMultiDictǁ__ne____mutmut_orig(self, other):
        return not (self == other)

    def xǁOrderedMultiDictǁ__ne____mutmut_1(self, other):
        return (self == other)

    def xǁOrderedMultiDictǁ__ne____mutmut_2(self, other):
        return not (self != other)
    
    xǁOrderedMultiDictǁ__ne____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__ne____mutmut_1': xǁOrderedMultiDictǁ__ne____mutmut_1, 
        'xǁOrderedMultiDictǁ__ne____mutmut_2': xǁOrderedMultiDictǁ__ne____mutmut_2
    }
    
    def __ne__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__ne____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__ne____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __ne__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__ne____mutmut_orig)
    xǁOrderedMultiDictǁ__ne____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__ne__'

    def xǁOrderedMultiDictǁ__ior____mutmut_orig(self, other):
        self.update(other)
        return self

    def xǁOrderedMultiDictǁ__ior____mutmut_1(self, other):
        self.update(None)
        return self
    
    xǁOrderedMultiDictǁ__ior____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__ior____mutmut_1': xǁOrderedMultiDictǁ__ior____mutmut_1
    }
    
    def __ior__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__ior____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__ior____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __ior__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__ior____mutmut_orig)
    xǁOrderedMultiDictǁ__ior____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__ior__'

    def xǁOrderedMultiDictǁpop__mutmut_orig(self, k, default=_MISSING):
        """Remove all values under key *k*, returning the most-recently
        inserted value. Raises :exc:`KeyError` if the key is not
        present and no *default* is provided.
        """
        try:
            return self.popall(k)[-1]
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
        return default

    def xǁOrderedMultiDictǁpop__mutmut_1(self, k, default=_MISSING):
        """Remove all values under key *k*, returning the most-recently
        inserted value. Raises :exc:`KeyError` if the key is not
        present and no *default* is provided.
        """
        try:
            return self.popall(None)[-1]
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
        return default

    def xǁOrderedMultiDictǁpop__mutmut_2(self, k, default=_MISSING):
        """Remove all values under key *k*, returning the most-recently
        inserted value. Raises :exc:`KeyError` if the key is not
        present and no *default* is provided.
        """
        try:
            return self.popall(k)[+1]
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
        return default

    def xǁOrderedMultiDictǁpop__mutmut_3(self, k, default=_MISSING):
        """Remove all values under key *k*, returning the most-recently
        inserted value. Raises :exc:`KeyError` if the key is not
        present and no *default* is provided.
        """
        try:
            return self.popall(k)[-2]
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
        return default

    def xǁOrderedMultiDictǁpop__mutmut_4(self, k, default=_MISSING):
        """Remove all values under key *k*, returning the most-recently
        inserted value. Raises :exc:`KeyError` if the key is not
        present and no *default* is provided.
        """
        try:
            return self.popall(k)[-1]
        except KeyError:
            if default is not _MISSING:
                raise KeyError(k)
        return default

    def xǁOrderedMultiDictǁpop__mutmut_5(self, k, default=_MISSING):
        """Remove all values under key *k*, returning the most-recently
        inserted value. Raises :exc:`KeyError` if the key is not
        present and no *default* is provided.
        """
        try:
            return self.popall(k)[-1]
        except KeyError:
            if default is _MISSING:
                raise KeyError(None)
        return default
    
    xǁOrderedMultiDictǁpop__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁpop__mutmut_1': xǁOrderedMultiDictǁpop__mutmut_1, 
        'xǁOrderedMultiDictǁpop__mutmut_2': xǁOrderedMultiDictǁpop__mutmut_2, 
        'xǁOrderedMultiDictǁpop__mutmut_3': xǁOrderedMultiDictǁpop__mutmut_3, 
        'xǁOrderedMultiDictǁpop__mutmut_4': xǁOrderedMultiDictǁpop__mutmut_4, 
        'xǁOrderedMultiDictǁpop__mutmut_5': xǁOrderedMultiDictǁpop__mutmut_5
    }
    
    def pop(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁpop__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁpop__mutmut_mutants"), args, kwargs, self)
        return result 
    
    pop.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁpop__mutmut_orig)
    xǁOrderedMultiDictǁpop__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁpop'

    def xǁOrderedMultiDictǁpopall__mutmut_orig(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = super()
        if super_self.__contains__(k):
            self._remove_all(k)
        if default is _MISSING:
            return super_self.pop(k)
        return super_self.pop(k, default)

    def xǁOrderedMultiDictǁpopall__mutmut_1(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = None
        if super_self.__contains__(k):
            self._remove_all(k)
        if default is _MISSING:
            return super_self.pop(k)
        return super_self.pop(k, default)

    def xǁOrderedMultiDictǁpopall__mutmut_2(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = super()
        if super_self.__contains__(None):
            self._remove_all(k)
        if default is _MISSING:
            return super_self.pop(k)
        return super_self.pop(k, default)

    def xǁOrderedMultiDictǁpopall__mutmut_3(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = super()
        if super_self.__contains__(k):
            self._remove_all(None)
        if default is _MISSING:
            return super_self.pop(k)
        return super_self.pop(k, default)

    def xǁOrderedMultiDictǁpopall__mutmut_4(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = super()
        if super_self.__contains__(k):
            self._remove_all(k)
        if default is not _MISSING:
            return super_self.pop(k)
        return super_self.pop(k, default)

    def xǁOrderedMultiDictǁpopall__mutmut_5(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = super()
        if super_self.__contains__(k):
            self._remove_all(k)
        if default is _MISSING:
            return super_self.pop(None)
        return super_self.pop(k, default)

    def xǁOrderedMultiDictǁpopall__mutmut_6(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = super()
        if super_self.__contains__(k):
            self._remove_all(k)
        if default is _MISSING:
            return super_self.pop(k)
        return super_self.pop(None, default)

    def xǁOrderedMultiDictǁpopall__mutmut_7(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = super()
        if super_self.__contains__(k):
            self._remove_all(k)
        if default is _MISSING:
            return super_self.pop(k)
        return super_self.pop(k, None)

    def xǁOrderedMultiDictǁpopall__mutmut_8(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = super()
        if super_self.__contains__(k):
            self._remove_all(k)
        if default is _MISSING:
            return super_self.pop(k)
        return super_self.pop(default)

    def xǁOrderedMultiDictǁpopall__mutmut_9(self, k, default=_MISSING):
        """Remove all values under key *k*, returning them in the form of
        a list. Raises :exc:`KeyError` if the key is not present and no
        *default* is provided.
        """
        super_self = super()
        if super_self.__contains__(k):
            self._remove_all(k)
        if default is _MISSING:
            return super_self.pop(k)
        return super_self.pop(k, )
    
    xǁOrderedMultiDictǁpopall__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁpopall__mutmut_1': xǁOrderedMultiDictǁpopall__mutmut_1, 
        'xǁOrderedMultiDictǁpopall__mutmut_2': xǁOrderedMultiDictǁpopall__mutmut_2, 
        'xǁOrderedMultiDictǁpopall__mutmut_3': xǁOrderedMultiDictǁpopall__mutmut_3, 
        'xǁOrderedMultiDictǁpopall__mutmut_4': xǁOrderedMultiDictǁpopall__mutmut_4, 
        'xǁOrderedMultiDictǁpopall__mutmut_5': xǁOrderedMultiDictǁpopall__mutmut_5, 
        'xǁOrderedMultiDictǁpopall__mutmut_6': xǁOrderedMultiDictǁpopall__mutmut_6, 
        'xǁOrderedMultiDictǁpopall__mutmut_7': xǁOrderedMultiDictǁpopall__mutmut_7, 
        'xǁOrderedMultiDictǁpopall__mutmut_8': xǁOrderedMultiDictǁpopall__mutmut_8, 
        'xǁOrderedMultiDictǁpopall__mutmut_9': xǁOrderedMultiDictǁpopall__mutmut_9
    }
    
    def popall(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁpopall__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁpopall__mutmut_mutants"), args, kwargs, self)
        return result 
    
    popall.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁpopall__mutmut_orig)
    xǁOrderedMultiDictǁpopall__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁpopall'

    def xǁOrderedMultiDictǁpoplast__mutmut_orig(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_1(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is not _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_2(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = None
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_3(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is not _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_4(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError(None)
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_5(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' / type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_6(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('XXempty %rXX' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_7(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('EMPTY %R' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_8(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(None))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_9(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(None)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_10(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is not _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_11(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(None)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_12(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = None
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_13(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(None)
        v = values.pop()
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_14(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = None
        if not values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_15(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if values:
            super().__delitem__(k)
        return v

    def xǁOrderedMultiDictǁpoplast__mutmut_16(self, k=_MISSING, default=_MISSING):
        """Remove and return the most-recently inserted value under the key
        *k*, or the most-recently inserted key if *k* is not
        provided. If no values remain under *k*, it will be removed
        from the OMD.  Raises :exc:`KeyError` if *k* is not present in
        the dictionary, or the dictionary is empty.
        """
        if k is _MISSING:
            if self:
                k = self.root[PREV][KEY]
            else:
                if default is _MISSING:
                    raise KeyError('empty %r' % type(self))
                return default
        try:
            self._remove(k)
        except KeyError:
            if default is _MISSING:
                raise KeyError(k)
            return default
        values = super().__getitem__(k)
        v = values.pop()
        if not values:
            super().__delitem__(None)
        return v
    
    xǁOrderedMultiDictǁpoplast__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁpoplast__mutmut_1': xǁOrderedMultiDictǁpoplast__mutmut_1, 
        'xǁOrderedMultiDictǁpoplast__mutmut_2': xǁOrderedMultiDictǁpoplast__mutmut_2, 
        'xǁOrderedMultiDictǁpoplast__mutmut_3': xǁOrderedMultiDictǁpoplast__mutmut_3, 
        'xǁOrderedMultiDictǁpoplast__mutmut_4': xǁOrderedMultiDictǁpoplast__mutmut_4, 
        'xǁOrderedMultiDictǁpoplast__mutmut_5': xǁOrderedMultiDictǁpoplast__mutmut_5, 
        'xǁOrderedMultiDictǁpoplast__mutmut_6': xǁOrderedMultiDictǁpoplast__mutmut_6, 
        'xǁOrderedMultiDictǁpoplast__mutmut_7': xǁOrderedMultiDictǁpoplast__mutmut_7, 
        'xǁOrderedMultiDictǁpoplast__mutmut_8': xǁOrderedMultiDictǁpoplast__mutmut_8, 
        'xǁOrderedMultiDictǁpoplast__mutmut_9': xǁOrderedMultiDictǁpoplast__mutmut_9, 
        'xǁOrderedMultiDictǁpoplast__mutmut_10': xǁOrderedMultiDictǁpoplast__mutmut_10, 
        'xǁOrderedMultiDictǁpoplast__mutmut_11': xǁOrderedMultiDictǁpoplast__mutmut_11, 
        'xǁOrderedMultiDictǁpoplast__mutmut_12': xǁOrderedMultiDictǁpoplast__mutmut_12, 
        'xǁOrderedMultiDictǁpoplast__mutmut_13': xǁOrderedMultiDictǁpoplast__mutmut_13, 
        'xǁOrderedMultiDictǁpoplast__mutmut_14': xǁOrderedMultiDictǁpoplast__mutmut_14, 
        'xǁOrderedMultiDictǁpoplast__mutmut_15': xǁOrderedMultiDictǁpoplast__mutmut_15, 
        'xǁOrderedMultiDictǁpoplast__mutmut_16': xǁOrderedMultiDictǁpoplast__mutmut_16
    }
    
    def poplast(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁpoplast__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁpoplast__mutmut_mutants"), args, kwargs, self)
        return result 
    
    poplast.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁpoplast__mutmut_orig)
    xǁOrderedMultiDictǁpoplast__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁpoplast'

    def xǁOrderedMultiDictǁ_remove__mutmut_orig(self, k):
        values = self._map[k]
        cell = values.pop()
        cell[PREV][NEXT], cell[NEXT][PREV] = cell[NEXT], cell[PREV]
        if not values:
            del self._map[k]

    def xǁOrderedMultiDictǁ_remove__mutmut_1(self, k):
        values = None
        cell = values.pop()
        cell[PREV][NEXT], cell[NEXT][PREV] = cell[NEXT], cell[PREV]
        if not values:
            del self._map[k]

    def xǁOrderedMultiDictǁ_remove__mutmut_2(self, k):
        values = self._map[k]
        cell = None
        cell[PREV][NEXT], cell[NEXT][PREV] = cell[NEXT], cell[PREV]
        if not values:
            del self._map[k]

    def xǁOrderedMultiDictǁ_remove__mutmut_3(self, k):
        values = self._map[k]
        cell = values.pop()
        cell[PREV][NEXT], cell[NEXT][PREV] = None
        if not values:
            del self._map[k]

    def xǁOrderedMultiDictǁ_remove__mutmut_4(self, k):
        values = self._map[k]
        cell = values.pop()
        cell[PREV][NEXT], cell[NEXT][PREV] = cell[NEXT], cell[PREV]
        if values:
            del self._map[k]
    
    xǁOrderedMultiDictǁ_remove__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ_remove__mutmut_1': xǁOrderedMultiDictǁ_remove__mutmut_1, 
        'xǁOrderedMultiDictǁ_remove__mutmut_2': xǁOrderedMultiDictǁ_remove__mutmut_2, 
        'xǁOrderedMultiDictǁ_remove__mutmut_3': xǁOrderedMultiDictǁ_remove__mutmut_3, 
        'xǁOrderedMultiDictǁ_remove__mutmut_4': xǁOrderedMultiDictǁ_remove__mutmut_4
    }
    
    def _remove(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ_remove__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ_remove__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _remove.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ_remove__mutmut_orig)
    xǁOrderedMultiDictǁ_remove__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ_remove'

    def xǁOrderedMultiDictǁ_remove_all__mutmut_orig(self, k):
        values = self._map[k]
        while values:
            cell = values.pop()
            cell[PREV][NEXT], cell[NEXT][PREV] = cell[NEXT], cell[PREV]
        del self._map[k]

    def xǁOrderedMultiDictǁ_remove_all__mutmut_1(self, k):
        values = None
        while values:
            cell = values.pop()
            cell[PREV][NEXT], cell[NEXT][PREV] = cell[NEXT], cell[PREV]
        del self._map[k]

    def xǁOrderedMultiDictǁ_remove_all__mutmut_2(self, k):
        values = self._map[k]
        while values:
            cell = None
            cell[PREV][NEXT], cell[NEXT][PREV] = cell[NEXT], cell[PREV]
        del self._map[k]

    def xǁOrderedMultiDictǁ_remove_all__mutmut_3(self, k):
        values = self._map[k]
        while values:
            cell = values.pop()
            cell[PREV][NEXT], cell[NEXT][PREV] = None
        del self._map[k]
    
    xǁOrderedMultiDictǁ_remove_all__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ_remove_all__mutmut_1': xǁOrderedMultiDictǁ_remove_all__mutmut_1, 
        'xǁOrderedMultiDictǁ_remove_all__mutmut_2': xǁOrderedMultiDictǁ_remove_all__mutmut_2, 
        'xǁOrderedMultiDictǁ_remove_all__mutmut_3': xǁOrderedMultiDictǁ_remove_all__mutmut_3
    }
    
    def _remove_all(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ_remove_all__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ_remove_all__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _remove_all.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ_remove_all__mutmut_orig)
    xǁOrderedMultiDictǁ_remove_all__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ_remove_all'

    def xǁOrderedMultiDictǁiteritems__mutmut_orig(self, multi=False):
        """Iterate over the OMD's items in insertion order. By default,
        yields only the most-recently inserted value for each key. Set
        *multi* to ``True`` to get all inserted items.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY], curr[VALUE]
                curr = curr[NEXT]
        else:
            for key in self.iterkeys():
                yield key, self[key]

    def xǁOrderedMultiDictǁiteritems__mutmut_1(self, multi=True):
        """Iterate over the OMD's items in insertion order. By default,
        yields only the most-recently inserted value for each key. Set
        *multi* to ``True`` to get all inserted items.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY], curr[VALUE]
                curr = curr[NEXT]
        else:
            for key in self.iterkeys():
                yield key, self[key]

    def xǁOrderedMultiDictǁiteritems__mutmut_2(self, multi=False):
        """Iterate over the OMD's items in insertion order. By default,
        yields only the most-recently inserted value for each key. Set
        *multi* to ``True`` to get all inserted items.
        """
        root = None
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY], curr[VALUE]
                curr = curr[NEXT]
        else:
            for key in self.iterkeys():
                yield key, self[key]

    def xǁOrderedMultiDictǁiteritems__mutmut_3(self, multi=False):
        """Iterate over the OMD's items in insertion order. By default,
        yields only the most-recently inserted value for each key. Set
        *multi* to ``True`` to get all inserted items.
        """
        root = self.root
        curr = None
        if multi:
            while curr is not root:
                yield curr[KEY], curr[VALUE]
                curr = curr[NEXT]
        else:
            for key in self.iterkeys():
                yield key, self[key]

    def xǁOrderedMultiDictǁiteritems__mutmut_4(self, multi=False):
        """Iterate over the OMD's items in insertion order. By default,
        yields only the most-recently inserted value for each key. Set
        *multi* to ``True`` to get all inserted items.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is root:
                yield curr[KEY], curr[VALUE]
                curr = curr[NEXT]
        else:
            for key in self.iterkeys():
                yield key, self[key]

    def xǁOrderedMultiDictǁiteritems__mutmut_5(self, multi=False):
        """Iterate over the OMD's items in insertion order. By default,
        yields only the most-recently inserted value for each key. Set
        *multi* to ``True`` to get all inserted items.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY], curr[VALUE]
                curr = None
        else:
            for key in self.iterkeys():
                yield key, self[key]
    
    xǁOrderedMultiDictǁiteritems__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁiteritems__mutmut_1': xǁOrderedMultiDictǁiteritems__mutmut_1, 
        'xǁOrderedMultiDictǁiteritems__mutmut_2': xǁOrderedMultiDictǁiteritems__mutmut_2, 
        'xǁOrderedMultiDictǁiteritems__mutmut_3': xǁOrderedMultiDictǁiteritems__mutmut_3, 
        'xǁOrderedMultiDictǁiteritems__mutmut_4': xǁOrderedMultiDictǁiteritems__mutmut_4, 
        'xǁOrderedMultiDictǁiteritems__mutmut_5': xǁOrderedMultiDictǁiteritems__mutmut_5
    }
    
    def iteritems(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁiteritems__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁiteritems__mutmut_mutants"), args, kwargs, self)
        return result 
    
    iteritems.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁiteritems__mutmut_orig)
    xǁOrderedMultiDictǁiteritems__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁiteritems'

    def xǁOrderedMultiDictǁiterkeys__mutmut_orig(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_1(self, multi=True):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_2(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = None
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_3(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = None
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_4(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_5(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = None
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_6(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = None
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_7(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = None
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_8(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_9(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = None
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_10(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k in yielded:
                    yielded_add(k)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_11(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(None)
                    yield k
                curr = curr[NEXT]

    def xǁOrderedMultiDictǁiterkeys__mutmut_12(self, multi=False):
        """Iterate over the OMD's keys in insertion order. By default, yields
        each key once, according to the most recent insertion. Set
        *multi* to ``True`` to get all keys, including duplicates, in
        insertion order.
        """
        root = self.root
        curr = root[NEXT]
        if multi:
            while curr is not root:
                yield curr[KEY]
                curr = curr[NEXT]
        else:
            yielded = set()
            yielded_add = yielded.add
            while curr is not root:
                k = curr[KEY]
                if k not in yielded:
                    yielded_add(k)
                    yield k
                curr = None
    
    xǁOrderedMultiDictǁiterkeys__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁiterkeys__mutmut_1': xǁOrderedMultiDictǁiterkeys__mutmut_1, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_2': xǁOrderedMultiDictǁiterkeys__mutmut_2, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_3': xǁOrderedMultiDictǁiterkeys__mutmut_3, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_4': xǁOrderedMultiDictǁiterkeys__mutmut_4, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_5': xǁOrderedMultiDictǁiterkeys__mutmut_5, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_6': xǁOrderedMultiDictǁiterkeys__mutmut_6, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_7': xǁOrderedMultiDictǁiterkeys__mutmut_7, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_8': xǁOrderedMultiDictǁiterkeys__mutmut_8, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_9': xǁOrderedMultiDictǁiterkeys__mutmut_9, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_10': xǁOrderedMultiDictǁiterkeys__mutmut_10, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_11': xǁOrderedMultiDictǁiterkeys__mutmut_11, 
        'xǁOrderedMultiDictǁiterkeys__mutmut_12': xǁOrderedMultiDictǁiterkeys__mutmut_12
    }
    
    def iterkeys(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁiterkeys__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁiterkeys__mutmut_mutants"), args, kwargs, self)
        return result 
    
    iterkeys.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁiterkeys__mutmut_orig)
    xǁOrderedMultiDictǁiterkeys__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁiterkeys'

    def xǁOrderedMultiDictǁitervalues__mutmut_orig(self, multi=False):
        """Iterate over the OMD's values in insertion order. By default,
        yields the most-recently inserted value per unique key.  Set
        *multi* to ``True`` to get all values according to insertion
        order.
        """
        for k, v in self.iteritems(multi=multi):
            yield v

    def xǁOrderedMultiDictǁitervalues__mutmut_1(self, multi=True):
        """Iterate over the OMD's values in insertion order. By default,
        yields the most-recently inserted value per unique key.  Set
        *multi* to ``True`` to get all values according to insertion
        order.
        """
        for k, v in self.iteritems(multi=multi):
            yield v

    def xǁOrderedMultiDictǁitervalues__mutmut_2(self, multi=False):
        """Iterate over the OMD's values in insertion order. By default,
        yields the most-recently inserted value per unique key.  Set
        *multi* to ``True`` to get all values according to insertion
        order.
        """
        for k, v in self.iteritems(multi=None):
            yield v
    
    xǁOrderedMultiDictǁitervalues__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁitervalues__mutmut_1': xǁOrderedMultiDictǁitervalues__mutmut_1, 
        'xǁOrderedMultiDictǁitervalues__mutmut_2': xǁOrderedMultiDictǁitervalues__mutmut_2
    }
    
    def itervalues(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁitervalues__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁitervalues__mutmut_mutants"), args, kwargs, self)
        return result 
    
    itervalues.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁitervalues__mutmut_orig)
    xǁOrderedMultiDictǁitervalues__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁitervalues'

    def xǁOrderedMultiDictǁtodict__mutmut_orig(self, multi=False):
        """Gets a basic :class:`dict` of the items in this dictionary. Keys
        are the same as the OMD, values are the most recently inserted
        values for each key.

        Setting the *multi* arg to ``True`` is yields the same
        result as calling :class:`dict` on the OMD, except that all the
        value lists are copies that can be safely mutated.
        """
        if multi:
            return {k: self.getlist(k) for k in self}
        return {k: self[k] for k in self}

    def xǁOrderedMultiDictǁtodict__mutmut_1(self, multi=True):
        """Gets a basic :class:`dict` of the items in this dictionary. Keys
        are the same as the OMD, values are the most recently inserted
        values for each key.

        Setting the *multi* arg to ``True`` is yields the same
        result as calling :class:`dict` on the OMD, except that all the
        value lists are copies that can be safely mutated.
        """
        if multi:
            return {k: self.getlist(k) for k in self}
        return {k: self[k] for k in self}

    def xǁOrderedMultiDictǁtodict__mutmut_2(self, multi=False):
        """Gets a basic :class:`dict` of the items in this dictionary. Keys
        are the same as the OMD, values are the most recently inserted
        values for each key.

        Setting the *multi* arg to ``True`` is yields the same
        result as calling :class:`dict` on the OMD, except that all the
        value lists are copies that can be safely mutated.
        """
        if multi:
            return {k: self.getlist(None) for k in self}
        return {k: self[k] for k in self}
    
    xǁOrderedMultiDictǁtodict__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁtodict__mutmut_1': xǁOrderedMultiDictǁtodict__mutmut_1, 
        'xǁOrderedMultiDictǁtodict__mutmut_2': xǁOrderedMultiDictǁtodict__mutmut_2
    }
    
    def todict(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁtodict__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁtodict__mutmut_mutants"), args, kwargs, self)
        return result 
    
    todict.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁtodict__mutmut_orig)
    xǁOrderedMultiDictǁtodict__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁtodict'

    def xǁOrderedMultiDictǁsorted__mutmut_orig(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(self.iteritems(multi=True), key=key, reverse=reverse))

    def xǁOrderedMultiDictǁsorted__mutmut_1(self, key=None, reverse=True):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(self.iteritems(multi=True), key=key, reverse=reverse))

    def xǁOrderedMultiDictǁsorted__mutmut_2(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = None
        return cls(sorted(self.iteritems(multi=True), key=key, reverse=reverse))

    def xǁOrderedMultiDictǁsorted__mutmut_3(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(None)

    def xǁOrderedMultiDictǁsorted__mutmut_4(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(None, key=key, reverse=reverse))

    def xǁOrderedMultiDictǁsorted__mutmut_5(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(self.iteritems(multi=True), key=None, reverse=reverse))

    def xǁOrderedMultiDictǁsorted__mutmut_6(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(self.iteritems(multi=True), key=key, reverse=None))

    def xǁOrderedMultiDictǁsorted__mutmut_7(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(key=key, reverse=reverse))

    def xǁOrderedMultiDictǁsorted__mutmut_8(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(self.iteritems(multi=True), reverse=reverse))

    def xǁOrderedMultiDictǁsorted__mutmut_9(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(self.iteritems(multi=True), key=key, ))

    def xǁOrderedMultiDictǁsorted__mutmut_10(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(self.iteritems(multi=None), key=key, reverse=reverse))

    def xǁOrderedMultiDictǁsorted__mutmut_11(self, key=None, reverse=False):
        """Similar to the built-in :func:`sorted`, except this method returns
        a new :class:`OrderedMultiDict` sorted by the provided key
        function, optionally reversed.

        Args:
            key (callable): A callable to determine the sort key of
              each element. The callable should expect an **item**
              (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict(zip(range(3), range(3)))
        >>> omd.sorted(reverse=True)
        OrderedMultiDict([(2, 2), (1, 1), (0, 0)])

        Note that the key function receives an **item** (key-value
        tuple), so the recommended signature looks like:

        >>> omd = OrderedMultiDict(zip('hello', 'world'))
        >>> omd.sorted(key=lambda i: i[1])  # i[0] is the key, i[1] is the val
        OrderedMultiDict([('o', 'd'), ('l', 'l'), ('e', 'o'), ('l', 'r'), ('h', 'w')])
        """
        cls = self.__class__
        return cls(sorted(self.iteritems(multi=False), key=key, reverse=reverse))
    
    xǁOrderedMultiDictǁsorted__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁsorted__mutmut_1': xǁOrderedMultiDictǁsorted__mutmut_1, 
        'xǁOrderedMultiDictǁsorted__mutmut_2': xǁOrderedMultiDictǁsorted__mutmut_2, 
        'xǁOrderedMultiDictǁsorted__mutmut_3': xǁOrderedMultiDictǁsorted__mutmut_3, 
        'xǁOrderedMultiDictǁsorted__mutmut_4': xǁOrderedMultiDictǁsorted__mutmut_4, 
        'xǁOrderedMultiDictǁsorted__mutmut_5': xǁOrderedMultiDictǁsorted__mutmut_5, 
        'xǁOrderedMultiDictǁsorted__mutmut_6': xǁOrderedMultiDictǁsorted__mutmut_6, 
        'xǁOrderedMultiDictǁsorted__mutmut_7': xǁOrderedMultiDictǁsorted__mutmut_7, 
        'xǁOrderedMultiDictǁsorted__mutmut_8': xǁOrderedMultiDictǁsorted__mutmut_8, 
        'xǁOrderedMultiDictǁsorted__mutmut_9': xǁOrderedMultiDictǁsorted__mutmut_9, 
        'xǁOrderedMultiDictǁsorted__mutmut_10': xǁOrderedMultiDictǁsorted__mutmut_10, 
        'xǁOrderedMultiDictǁsorted__mutmut_11': xǁOrderedMultiDictǁsorted__mutmut_11
    }
    
    def sorted(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁsorted__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁsorted__mutmut_mutants"), args, kwargs, self)
        return result 
    
    sorted.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁsorted__mutmut_orig)
    xǁOrderedMultiDictǁsorted__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁsorted'

    def xǁOrderedMultiDictǁsortedvalues__mutmut_orig(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_1(self, key=None, reverse=True):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_2(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = None
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_3(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = None
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_4(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = None
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_5(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(None, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_6(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=None, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_7(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=None)
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_8(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_9(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_10(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, )
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_11(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=reverse)
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_12(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = None
        for k in self.iterkeys(multi=True):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_13(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=None):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_14(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=False):
            ret.add(k, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_15(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(None, sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_16(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, None)
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_17(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(sorted_val_map[k].pop())
        return ret

    def xǁOrderedMultiDictǁsortedvalues__mutmut_18(self, key=None, reverse=False):
        """Returns a copy of the :class:`OrderedMultiDict` with the same keys
        in the same order as the original OMD, but the values within
        each keyspace have been sorted according to *key* and
        *reverse*.

        Args:
            key (callable): A single-argument callable to determine
              the sort key of each element. The callable should expect
              an **item** (key-value pair tuple).
            reverse (bool): Set to ``True`` to reverse the ordering.

        >>> omd = OrderedMultiDict()
        >>> omd.addlist('even', [6, 2])
        >>> omd.addlist('odd', [1, 5])
        >>> omd.add('even', 4)
        >>> omd.add('odd', 3)
        >>> somd = omd.sortedvalues()
        >>> somd.getlist('even')
        [2, 4, 6]
        >>> somd.keys(multi=True) == omd.keys(multi=True)
        True
        >>> omd == somd
        False
        >>> somd
        OrderedMultiDict([('even', 2), ('even', 4), ('odd', 1), ('odd', 3), ('even', 6), ('odd', 5)])

        As demonstrated above, contents and key order are
        retained. Only value order changes.
        """
        try:
            superself_iteritems = super().iteritems()
        except AttributeError:
            superself_iteritems = super().items()
        # (not reverse) because they pop off in reverse order for reinsertion
        sorted_val_map = {k: sorted(v, key=key, reverse=(not reverse))
                               for k, v in superself_iteritems}
        ret = self.__class__()
        for k in self.iterkeys(multi=True):
            ret.add(k, )
        return ret
    
    xǁOrderedMultiDictǁsortedvalues__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁsortedvalues__mutmut_1': xǁOrderedMultiDictǁsortedvalues__mutmut_1, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_2': xǁOrderedMultiDictǁsortedvalues__mutmut_2, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_3': xǁOrderedMultiDictǁsortedvalues__mutmut_3, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_4': xǁOrderedMultiDictǁsortedvalues__mutmut_4, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_5': xǁOrderedMultiDictǁsortedvalues__mutmut_5, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_6': xǁOrderedMultiDictǁsortedvalues__mutmut_6, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_7': xǁOrderedMultiDictǁsortedvalues__mutmut_7, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_8': xǁOrderedMultiDictǁsortedvalues__mutmut_8, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_9': xǁOrderedMultiDictǁsortedvalues__mutmut_9, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_10': xǁOrderedMultiDictǁsortedvalues__mutmut_10, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_11': xǁOrderedMultiDictǁsortedvalues__mutmut_11, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_12': xǁOrderedMultiDictǁsortedvalues__mutmut_12, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_13': xǁOrderedMultiDictǁsortedvalues__mutmut_13, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_14': xǁOrderedMultiDictǁsortedvalues__mutmut_14, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_15': xǁOrderedMultiDictǁsortedvalues__mutmut_15, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_16': xǁOrderedMultiDictǁsortedvalues__mutmut_16, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_17': xǁOrderedMultiDictǁsortedvalues__mutmut_17, 
        'xǁOrderedMultiDictǁsortedvalues__mutmut_18': xǁOrderedMultiDictǁsortedvalues__mutmut_18
    }
    
    def sortedvalues(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁsortedvalues__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁsortedvalues__mutmut_mutants"), args, kwargs, self)
        return result 
    
    sortedvalues.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁsortedvalues__mutmut_orig)
    xǁOrderedMultiDictǁsortedvalues__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁsortedvalues'

    def xǁOrderedMultiDictǁinverted__mutmut_orig(self):
        """Returns a new :class:`OrderedMultiDict` with values and keys
        swapped, like creating dictionary transposition or reverse
        index.  Insertion order is retained and all keys and values
        are represented in the output.

        >>> omd = OMD([(0, 2), (1, 2)])
        >>> omd.inverted().getlist(2)
        [0, 1]

        Inverting twice yields a copy of the original:

        >>> omd.inverted().inverted()
        OrderedMultiDict([(0, 2), (1, 2)])
        """
        return self.__class__((v, k) for k, v in self.iteritems(multi=True))

    def xǁOrderedMultiDictǁinverted__mutmut_1(self):
        """Returns a new :class:`OrderedMultiDict` with values and keys
        swapped, like creating dictionary transposition or reverse
        index.  Insertion order is retained and all keys and values
        are represented in the output.

        >>> omd = OMD([(0, 2), (1, 2)])
        >>> omd.inverted().getlist(2)
        [0, 1]

        Inverting twice yields a copy of the original:

        >>> omd.inverted().inverted()
        OrderedMultiDict([(0, 2), (1, 2)])
        """
        return self.__class__(None)

    def xǁOrderedMultiDictǁinverted__mutmut_2(self):
        """Returns a new :class:`OrderedMultiDict` with values and keys
        swapped, like creating dictionary transposition or reverse
        index.  Insertion order is retained and all keys and values
        are represented in the output.

        >>> omd = OMD([(0, 2), (1, 2)])
        >>> omd.inverted().getlist(2)
        [0, 1]

        Inverting twice yields a copy of the original:

        >>> omd.inverted().inverted()
        OrderedMultiDict([(0, 2), (1, 2)])
        """
        return self.__class__((v, k) for k, v in self.iteritems(multi=None))

    def xǁOrderedMultiDictǁinverted__mutmut_3(self):
        """Returns a new :class:`OrderedMultiDict` with values and keys
        swapped, like creating dictionary transposition or reverse
        index.  Insertion order is retained and all keys and values
        are represented in the output.

        >>> omd = OMD([(0, 2), (1, 2)])
        >>> omd.inverted().getlist(2)
        [0, 1]

        Inverting twice yields a copy of the original:

        >>> omd.inverted().inverted()
        OrderedMultiDict([(0, 2), (1, 2)])
        """
        return self.__class__((v, k) for k, v in self.iteritems(multi=False))
    
    xǁOrderedMultiDictǁinverted__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁinverted__mutmut_1': xǁOrderedMultiDictǁinverted__mutmut_1, 
        'xǁOrderedMultiDictǁinverted__mutmut_2': xǁOrderedMultiDictǁinverted__mutmut_2, 
        'xǁOrderedMultiDictǁinverted__mutmut_3': xǁOrderedMultiDictǁinverted__mutmut_3
    }
    
    def inverted(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁinverted__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁinverted__mutmut_mutants"), args, kwargs, self)
        return result 
    
    inverted.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁinverted__mutmut_orig)
    xǁOrderedMultiDictǁinverted__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁinverted'

    def xǁOrderedMultiDictǁcounts__mutmut_orig(self):
        """Returns a mapping from key to number of values inserted under that
        key. Like :py:class:`collections.Counter`, but returns a new
        :class:`OrderedMultiDict`.
        """
        # Returns an OMD because Counter/OrderedDict may not be
        # available, and neither Counter nor dict maintain order.
        super_getitem = super().__getitem__
        return self.__class__((k, len(super_getitem(k))) for k in self)

    def xǁOrderedMultiDictǁcounts__mutmut_1(self):
        """Returns a mapping from key to number of values inserted under that
        key. Like :py:class:`collections.Counter`, but returns a new
        :class:`OrderedMultiDict`.
        """
        # Returns an OMD because Counter/OrderedDict may not be
        # available, and neither Counter nor dict maintain order.
        super_getitem = None
        return self.__class__((k, len(super_getitem(k))) for k in self)

    def xǁOrderedMultiDictǁcounts__mutmut_2(self):
        """Returns a mapping from key to number of values inserted under that
        key. Like :py:class:`collections.Counter`, but returns a new
        :class:`OrderedMultiDict`.
        """
        # Returns an OMD because Counter/OrderedDict may not be
        # available, and neither Counter nor dict maintain order.
        super_getitem = super().__getitem__
        return self.__class__(None)
    
    xǁOrderedMultiDictǁcounts__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁcounts__mutmut_1': xǁOrderedMultiDictǁcounts__mutmut_1, 
        'xǁOrderedMultiDictǁcounts__mutmut_2': xǁOrderedMultiDictǁcounts__mutmut_2
    }
    
    def counts(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁcounts__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁcounts__mutmut_mutants"), args, kwargs, self)
        return result 
    
    counts.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁcounts__mutmut_orig)
    xǁOrderedMultiDictǁcounts__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁcounts'

    def xǁOrderedMultiDictǁkeys__mutmut_orig(self, multi=False):
        """Returns a list containing the output of :meth:`iterkeys`.  See
        that method's docs for more details.
        """
        return list(self.iterkeys(multi=multi))

    def xǁOrderedMultiDictǁkeys__mutmut_1(self, multi=True):
        """Returns a list containing the output of :meth:`iterkeys`.  See
        that method's docs for more details.
        """
        return list(self.iterkeys(multi=multi))

    def xǁOrderedMultiDictǁkeys__mutmut_2(self, multi=False):
        """Returns a list containing the output of :meth:`iterkeys`.  See
        that method's docs for more details.
        """
        return list(None)

    def xǁOrderedMultiDictǁkeys__mutmut_3(self, multi=False):
        """Returns a list containing the output of :meth:`iterkeys`.  See
        that method's docs for more details.
        """
        return list(self.iterkeys(multi=None))
    
    xǁOrderedMultiDictǁkeys__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁkeys__mutmut_1': xǁOrderedMultiDictǁkeys__mutmut_1, 
        'xǁOrderedMultiDictǁkeys__mutmut_2': xǁOrderedMultiDictǁkeys__mutmut_2, 
        'xǁOrderedMultiDictǁkeys__mutmut_3': xǁOrderedMultiDictǁkeys__mutmut_3
    }
    
    def keys(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁkeys__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁkeys__mutmut_mutants"), args, kwargs, self)
        return result 
    
    keys.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁkeys__mutmut_orig)
    xǁOrderedMultiDictǁkeys__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁkeys'

    def xǁOrderedMultiDictǁvalues__mutmut_orig(self, multi=False):
        """Returns a list containing the output of :meth:`itervalues`.  See
        that method's docs for more details.
        """
        return list(self.itervalues(multi=multi))

    def xǁOrderedMultiDictǁvalues__mutmut_1(self, multi=True):
        """Returns a list containing the output of :meth:`itervalues`.  See
        that method's docs for more details.
        """
        return list(self.itervalues(multi=multi))

    def xǁOrderedMultiDictǁvalues__mutmut_2(self, multi=False):
        """Returns a list containing the output of :meth:`itervalues`.  See
        that method's docs for more details.
        """
        return list(None)

    def xǁOrderedMultiDictǁvalues__mutmut_3(self, multi=False):
        """Returns a list containing the output of :meth:`itervalues`.  See
        that method's docs for more details.
        """
        return list(self.itervalues(multi=None))
    
    xǁOrderedMultiDictǁvalues__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁvalues__mutmut_1': xǁOrderedMultiDictǁvalues__mutmut_1, 
        'xǁOrderedMultiDictǁvalues__mutmut_2': xǁOrderedMultiDictǁvalues__mutmut_2, 
        'xǁOrderedMultiDictǁvalues__mutmut_3': xǁOrderedMultiDictǁvalues__mutmut_3
    }
    
    def values(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁvalues__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁvalues__mutmut_mutants"), args, kwargs, self)
        return result 
    
    values.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁvalues__mutmut_orig)
    xǁOrderedMultiDictǁvalues__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁvalues'

    def xǁOrderedMultiDictǁitems__mutmut_orig(self, multi=False):
        """Returns a list containing the output of :meth:`iteritems`.  See
        that method's docs for more details.
        """
        return list(self.iteritems(multi=multi))

    def xǁOrderedMultiDictǁitems__mutmut_1(self, multi=True):
        """Returns a list containing the output of :meth:`iteritems`.  See
        that method's docs for more details.
        """
        return list(self.iteritems(multi=multi))

    def xǁOrderedMultiDictǁitems__mutmut_2(self, multi=False):
        """Returns a list containing the output of :meth:`iteritems`.  See
        that method's docs for more details.
        """
        return list(None)

    def xǁOrderedMultiDictǁitems__mutmut_3(self, multi=False):
        """Returns a list containing the output of :meth:`iteritems`.  See
        that method's docs for more details.
        """
        return list(self.iteritems(multi=None))
    
    xǁOrderedMultiDictǁitems__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁitems__mutmut_1': xǁOrderedMultiDictǁitems__mutmut_1, 
        'xǁOrderedMultiDictǁitems__mutmut_2': xǁOrderedMultiDictǁitems__mutmut_2, 
        'xǁOrderedMultiDictǁitems__mutmut_3': xǁOrderedMultiDictǁitems__mutmut_3
    }
    
    def items(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁitems__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁitems__mutmut_mutants"), args, kwargs, self)
        return result 
    
    items.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁitems__mutmut_orig)
    xǁOrderedMultiDictǁitems__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁitems'

    def __iter__(self):
        return self.iterkeys()

    def xǁOrderedMultiDictǁ__reversed____mutmut_orig(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_1(self):
        root = None
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_2(self):
        root = self.root
        curr = None
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_3(self):
        root = self.root
        curr = root[PREV]
        lengths = None
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_4(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = None
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_5(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = None
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_6(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_7(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = None
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_8(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = None
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_9(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(None)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_10(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(None, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_11(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, None) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_12(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(1) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_13(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, ) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_14(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 2) == len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_15(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) != len(vals):
                yield k
            lengths[k] += 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_16(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] = 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_17(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] -= 1
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_18(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 2
            curr = curr[PREV]

    def xǁOrderedMultiDictǁ__reversed____mutmut_19(self):
        root = self.root
        curr = root[PREV]
        lengths = {}
        lengths_sd = lengths.setdefault
        get_values = super().__getitem__
        while curr is not root:
            k = curr[KEY]
            vals = get_values(k)
            if lengths_sd(k, 1) == len(vals):
                yield k
            lengths[k] += 1
            curr = None
    
    xǁOrderedMultiDictǁ__reversed____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__reversed____mutmut_1': xǁOrderedMultiDictǁ__reversed____mutmut_1, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_2': xǁOrderedMultiDictǁ__reversed____mutmut_2, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_3': xǁOrderedMultiDictǁ__reversed____mutmut_3, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_4': xǁOrderedMultiDictǁ__reversed____mutmut_4, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_5': xǁOrderedMultiDictǁ__reversed____mutmut_5, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_6': xǁOrderedMultiDictǁ__reversed____mutmut_6, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_7': xǁOrderedMultiDictǁ__reversed____mutmut_7, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_8': xǁOrderedMultiDictǁ__reversed____mutmut_8, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_9': xǁOrderedMultiDictǁ__reversed____mutmut_9, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_10': xǁOrderedMultiDictǁ__reversed____mutmut_10, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_11': xǁOrderedMultiDictǁ__reversed____mutmut_11, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_12': xǁOrderedMultiDictǁ__reversed____mutmut_12, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_13': xǁOrderedMultiDictǁ__reversed____mutmut_13, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_14': xǁOrderedMultiDictǁ__reversed____mutmut_14, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_15': xǁOrderedMultiDictǁ__reversed____mutmut_15, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_16': xǁOrderedMultiDictǁ__reversed____mutmut_16, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_17': xǁOrderedMultiDictǁ__reversed____mutmut_17, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_18': xǁOrderedMultiDictǁ__reversed____mutmut_18, 
        'xǁOrderedMultiDictǁ__reversed____mutmut_19': xǁOrderedMultiDictǁ__reversed____mutmut_19
    }
    
    def __reversed__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__reversed____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__reversed____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __reversed__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__reversed____mutmut_orig)
    xǁOrderedMultiDictǁ__reversed____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__reversed__'

    def xǁOrderedMultiDictǁ__repr____mutmut_orig(self):
        cn = self.__class__.__name__
        kvs = ', '.join([repr((k, v)) for k, v in self.iteritems(multi=True)])
        return f'{cn}([{kvs}])'

    def xǁOrderedMultiDictǁ__repr____mutmut_1(self):
        cn = None
        kvs = ', '.join([repr((k, v)) for k, v in self.iteritems(multi=True)])
        return f'{cn}([{kvs}])'

    def xǁOrderedMultiDictǁ__repr____mutmut_2(self):
        cn = self.__class__.__name__
        kvs = None
        return f'{cn}([{kvs}])'

    def xǁOrderedMultiDictǁ__repr____mutmut_3(self):
        cn = self.__class__.__name__
        kvs = ', '.join(None)
        return f'{cn}([{kvs}])'

    def xǁOrderedMultiDictǁ__repr____mutmut_4(self):
        cn = self.__class__.__name__
        kvs = 'XX, XX'.join([repr((k, v)) for k, v in self.iteritems(multi=True)])
        return f'{cn}([{kvs}])'

    def xǁOrderedMultiDictǁ__repr____mutmut_5(self):
        cn = self.__class__.__name__
        kvs = ', '.join([repr(None) for k, v in self.iteritems(multi=True)])
        return f'{cn}([{kvs}])'

    def xǁOrderedMultiDictǁ__repr____mutmut_6(self):
        cn = self.__class__.__name__
        kvs = ', '.join([repr((k, v)) for k, v in self.iteritems(multi=None)])
        return f'{cn}([{kvs}])'

    def xǁOrderedMultiDictǁ__repr____mutmut_7(self):
        cn = self.__class__.__name__
        kvs = ', '.join([repr((k, v)) for k, v in self.iteritems(multi=False)])
        return f'{cn}([{kvs}])'
    
    xǁOrderedMultiDictǁ__repr____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁ__repr____mutmut_1': xǁOrderedMultiDictǁ__repr____mutmut_1, 
        'xǁOrderedMultiDictǁ__repr____mutmut_2': xǁOrderedMultiDictǁ__repr____mutmut_2, 
        'xǁOrderedMultiDictǁ__repr____mutmut_3': xǁOrderedMultiDictǁ__repr____mutmut_3, 
        'xǁOrderedMultiDictǁ__repr____mutmut_4': xǁOrderedMultiDictǁ__repr____mutmut_4, 
        'xǁOrderedMultiDictǁ__repr____mutmut_5': xǁOrderedMultiDictǁ__repr____mutmut_5, 
        'xǁOrderedMultiDictǁ__repr____mutmut_6': xǁOrderedMultiDictǁ__repr____mutmut_6, 
        'xǁOrderedMultiDictǁ__repr____mutmut_7': xǁOrderedMultiDictǁ__repr____mutmut_7
    }
    
    def __repr__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁ__repr____mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁ__repr____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __repr__.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁ__repr____mutmut_orig)
    xǁOrderedMultiDictǁ__repr____mutmut_orig.__name__ = 'xǁOrderedMultiDictǁ__repr__'

    def xǁOrderedMultiDictǁviewkeys__mutmut_orig(self):
        "OMD.viewkeys() -> a set-like object providing a view on OMD's keys"
        return KeysView(self)

    def xǁOrderedMultiDictǁviewkeys__mutmut_1(self):
        "XXOMD.viewkeys() -> a set-like object providing a view on OMD's keysXX"
        return KeysView(self)

    def xǁOrderedMultiDictǁviewkeys__mutmut_2(self):
        "omd.viewkeys() -> a set-like object providing a view on omd's keys"
        return KeysView(self)

    def xǁOrderedMultiDictǁviewkeys__mutmut_3(self):
        "OMD.VIEWKEYS() -> A SET-LIKE OBJECT PROVIDING A VIEW ON OMD'S KEYS"
        return KeysView(self)

    def xǁOrderedMultiDictǁviewkeys__mutmut_4(self):
        "OMD.viewkeys() -> a set-like object providing a view on OMD's keys"
        return KeysView(None)
    
    xǁOrderedMultiDictǁviewkeys__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁviewkeys__mutmut_1': xǁOrderedMultiDictǁviewkeys__mutmut_1, 
        'xǁOrderedMultiDictǁviewkeys__mutmut_2': xǁOrderedMultiDictǁviewkeys__mutmut_2, 
        'xǁOrderedMultiDictǁviewkeys__mutmut_3': xǁOrderedMultiDictǁviewkeys__mutmut_3, 
        'xǁOrderedMultiDictǁviewkeys__mutmut_4': xǁOrderedMultiDictǁviewkeys__mutmut_4
    }
    
    def viewkeys(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁviewkeys__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁviewkeys__mutmut_mutants"), args, kwargs, self)
        return result 
    
    viewkeys.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁviewkeys__mutmut_orig)
    xǁOrderedMultiDictǁviewkeys__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁviewkeys'

    def xǁOrderedMultiDictǁviewvalues__mutmut_orig(self):
        "OMD.viewvalues() -> an object providing a view on OMD's values"
        return ValuesView(self)

    def xǁOrderedMultiDictǁviewvalues__mutmut_1(self):
        "XXOMD.viewvalues() -> an object providing a view on OMD's valuesXX"
        return ValuesView(self)

    def xǁOrderedMultiDictǁviewvalues__mutmut_2(self):
        "omd.viewvalues() -> an object providing a view on omd's values"
        return ValuesView(self)

    def xǁOrderedMultiDictǁviewvalues__mutmut_3(self):
        "OMD.VIEWVALUES() -> AN OBJECT PROVIDING A VIEW ON OMD'S VALUES"
        return ValuesView(self)

    def xǁOrderedMultiDictǁviewvalues__mutmut_4(self):
        "OMD.viewvalues() -> an object providing a view on OMD's values"
        return ValuesView(None)
    
    xǁOrderedMultiDictǁviewvalues__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁviewvalues__mutmut_1': xǁOrderedMultiDictǁviewvalues__mutmut_1, 
        'xǁOrderedMultiDictǁviewvalues__mutmut_2': xǁOrderedMultiDictǁviewvalues__mutmut_2, 
        'xǁOrderedMultiDictǁviewvalues__mutmut_3': xǁOrderedMultiDictǁviewvalues__mutmut_3, 
        'xǁOrderedMultiDictǁviewvalues__mutmut_4': xǁOrderedMultiDictǁviewvalues__mutmut_4
    }
    
    def viewvalues(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁviewvalues__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁviewvalues__mutmut_mutants"), args, kwargs, self)
        return result 
    
    viewvalues.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁviewvalues__mutmut_orig)
    xǁOrderedMultiDictǁviewvalues__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁviewvalues'

    def xǁOrderedMultiDictǁviewitems__mutmut_orig(self):
        "OMD.viewitems() -> a set-like object providing a view on OMD's items"
        return ItemsView(self)

    def xǁOrderedMultiDictǁviewitems__mutmut_1(self):
        "XXOMD.viewitems() -> a set-like object providing a view on OMD's itemsXX"
        return ItemsView(self)

    def xǁOrderedMultiDictǁviewitems__mutmut_2(self):
        "omd.viewitems() -> a set-like object providing a view on omd's items"
        return ItemsView(self)

    def xǁOrderedMultiDictǁviewitems__mutmut_3(self):
        "OMD.VIEWITEMS() -> A SET-LIKE OBJECT PROVIDING A VIEW ON OMD'S ITEMS"
        return ItemsView(self)

    def xǁOrderedMultiDictǁviewitems__mutmut_4(self):
        "OMD.viewitems() -> a set-like object providing a view on OMD's items"
        return ItemsView(None)
    
    xǁOrderedMultiDictǁviewitems__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁOrderedMultiDictǁviewitems__mutmut_1': xǁOrderedMultiDictǁviewitems__mutmut_1, 
        'xǁOrderedMultiDictǁviewitems__mutmut_2': xǁOrderedMultiDictǁviewitems__mutmut_2, 
        'xǁOrderedMultiDictǁviewitems__mutmut_3': xǁOrderedMultiDictǁviewitems__mutmut_3, 
        'xǁOrderedMultiDictǁviewitems__mutmut_4': xǁOrderedMultiDictǁviewitems__mutmut_4
    }
    
    def viewitems(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁOrderedMultiDictǁviewitems__mutmut_orig"), object.__getattribute__(self, "xǁOrderedMultiDictǁviewitems__mutmut_mutants"), args, kwargs, self)
        return result 
    
    viewitems.__signature__ = _mutmut_signature(xǁOrderedMultiDictǁviewitems__mutmut_orig)
    xǁOrderedMultiDictǁviewitems__mutmut_orig.__name__ = 'xǁOrderedMultiDictǁviewitems'



try:
    # try to import the built-in one anyways
    from .dictutils import OrderedMultiDict
except ImportError:
    pass

OMD = OrderedMultiDict


class QueryParamDict(OrderedMultiDict):
    """A subclass of :class:`~dictutils.OrderedMultiDict` specialized for
    representing query string values. Everything is fully unquoted on
    load and all parsed keys and values are strings by default.

    As the name suggests, multiple values are supported and insertion
    order is preserved.

    >>> qp = QueryParamDict.from_text(u'key=val1&key=val2&utm_source=rtd')
    >>> qp.getlist('key')
    [u'val1', u'val2']
    >>> qp['key']
    u'val2'
    >>> qp.add('key', 'val3')
    >>> qp.to_text()
    'key=val1&key=val2&utm_source=rtd&key=val3'

    See :class:`~dictutils.OrderedMultiDict` for more API features.
    """

    @classmethod
    def from_text(cls, query_string):
        """
        Parse *query_string* and return a new :class:`QueryParamDict`.
        """
        pairs = parse_qsl(query_string, keep_blank_values=True)
        return cls(pairs)

    def xǁQueryParamDictǁto_text__mutmut_orig(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_1(self, full_quote=True):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_2(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = None
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_3(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=None):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_4(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=False):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_5(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = None
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_6(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(None, full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_7(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=None)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_8(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_9(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), )
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_10(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(None), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_11(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is not None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_12(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(None)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_13(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = None
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_14(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(None, full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_15(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=None)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_16(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_17(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), )
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_18(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(None), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_19(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append(None)
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_20(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join(None))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_21(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('XX=XX'.join((key, val)))
        return '&'.join(ret_list)

    def xǁQueryParamDictǁto_text__mutmut_22(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return '&'.join(None)

    def xǁQueryParamDictǁto_text__mutmut_23(self, full_quote=False):
        """
        Render and return a query string.

        Args:
           full_quote (bool): Whether or not to percent-quote special
              characters or leave them decoded for readability.
        """
        ret_list = []
        for k, v in self.iteritems(multi=True):
            key = quote_query_part(to_unicode(k), full_quote=full_quote)
            if v is None:
                ret_list.append(key)
            else:
                val = quote_query_part(to_unicode(v), full_quote=full_quote)
                ret_list.append('='.join((key, val)))
        return 'XX&XX'.join(ret_list)
    
    xǁQueryParamDictǁto_text__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁQueryParamDictǁto_text__mutmut_1': xǁQueryParamDictǁto_text__mutmut_1, 
        'xǁQueryParamDictǁto_text__mutmut_2': xǁQueryParamDictǁto_text__mutmut_2, 
        'xǁQueryParamDictǁto_text__mutmut_3': xǁQueryParamDictǁto_text__mutmut_3, 
        'xǁQueryParamDictǁto_text__mutmut_4': xǁQueryParamDictǁto_text__mutmut_4, 
        'xǁQueryParamDictǁto_text__mutmut_5': xǁQueryParamDictǁto_text__mutmut_5, 
        'xǁQueryParamDictǁto_text__mutmut_6': xǁQueryParamDictǁto_text__mutmut_6, 
        'xǁQueryParamDictǁto_text__mutmut_7': xǁQueryParamDictǁto_text__mutmut_7, 
        'xǁQueryParamDictǁto_text__mutmut_8': xǁQueryParamDictǁto_text__mutmut_8, 
        'xǁQueryParamDictǁto_text__mutmut_9': xǁQueryParamDictǁto_text__mutmut_9, 
        'xǁQueryParamDictǁto_text__mutmut_10': xǁQueryParamDictǁto_text__mutmut_10, 
        'xǁQueryParamDictǁto_text__mutmut_11': xǁQueryParamDictǁto_text__mutmut_11, 
        'xǁQueryParamDictǁto_text__mutmut_12': xǁQueryParamDictǁto_text__mutmut_12, 
        'xǁQueryParamDictǁto_text__mutmut_13': xǁQueryParamDictǁto_text__mutmut_13, 
        'xǁQueryParamDictǁto_text__mutmut_14': xǁQueryParamDictǁto_text__mutmut_14, 
        'xǁQueryParamDictǁto_text__mutmut_15': xǁQueryParamDictǁto_text__mutmut_15, 
        'xǁQueryParamDictǁto_text__mutmut_16': xǁQueryParamDictǁto_text__mutmut_16, 
        'xǁQueryParamDictǁto_text__mutmut_17': xǁQueryParamDictǁto_text__mutmut_17, 
        'xǁQueryParamDictǁto_text__mutmut_18': xǁQueryParamDictǁto_text__mutmut_18, 
        'xǁQueryParamDictǁto_text__mutmut_19': xǁQueryParamDictǁto_text__mutmut_19, 
        'xǁQueryParamDictǁto_text__mutmut_20': xǁQueryParamDictǁto_text__mutmut_20, 
        'xǁQueryParamDictǁto_text__mutmut_21': xǁQueryParamDictǁto_text__mutmut_21, 
        'xǁQueryParamDictǁto_text__mutmut_22': xǁQueryParamDictǁto_text__mutmut_22, 
        'xǁQueryParamDictǁto_text__mutmut_23': xǁQueryParamDictǁto_text__mutmut_23
    }
    
    def to_text(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁQueryParamDictǁto_text__mutmut_orig"), object.__getattribute__(self, "xǁQueryParamDictǁto_text__mutmut_mutants"), args, kwargs, self)
        return result 
    
    to_text.__signature__ = _mutmut_signature(xǁQueryParamDictǁto_text__mutmut_orig)
    xǁQueryParamDictǁto_text__mutmut_orig.__name__ = 'xǁQueryParamDictǁto_text'

# end urlutils.py
